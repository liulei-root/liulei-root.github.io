<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>编程基础 堆、栈、常量池详解</title>
      <link href="2021/10217153.html"/>
      <url>2021/10217153.html</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="编程基础-堆、栈、常量池详解"><a href="#编程基础-堆、栈、常量池详解" class="headerlink" title="编程基础 堆、栈、常量池详解"></a>编程基础 堆、栈、常量池详解</h2><h4 id="1-Java中的数据储存"><a href="#1-Java中的数据储存" class="headerlink" title="1. Java中的数据储存"></a>1. Java中的数据储存</h4><p>Java代码中，数据一般存储在下面这6个地方，其中最常见的面试重点就是堆栈以及常量池了，这也是需要着重学习和理解的知识点。</p><ol><li><p>寄存器：最快的存储区, 由编译器根据需求进行分配,我们在程序中无法控制.</p></li><li><p>栈：存放基本类型的变量数据和对象的引用，但对象本身不存放在栈中，而是存放在堆（new 出来的对象）或者常量池中（字符串常量对象存放在常量池中。）</p></li><li><p>堆：存放所有new出来的对象。</p></li><li><p>静态域：存放静态成员（由static修饰）</p></li><li><p>常量池：存放字符串常量和基本类型常量（常量由public static final修饰）。</p></li><li><p> 非RAM存储：硬盘等永久存储空间</p></li></ol><p>这里我们主要关心<strong>栈，堆和常量池</strong>，下面通过一些例子来给大家详细分析一下。</p><h4 id="2-堆栈的特性"><a href="#2-堆栈的特性" class="headerlink" title="2. 堆栈的特性"></a>2. 堆栈的特性</h4><ul><li><p>首先我们要知道，对于栈和常量池中的对象是可以共享的，对于堆中的对象是不可以共享的。</p></li><li><p>栈中的数据大小和生命周期是可以确定的，当没有引用指向数据时，这个数据就会消失。</p></li><li><p>堆中的对象的由垃圾回收器负责回收，因此大小和生命周期不需要确定，具有很大的灵活性。</p></li></ul><h4 id="3-字符串在堆栈、常量池中的存储"><a href="#3-字符串在堆栈、常量池中的存储" class="headerlink" title="3. 字符串在堆栈、常量池中的存储"></a>3. 字符串在堆栈、常量池中的存储</h4><p>对于字符串，其对象的引用都是存储在栈中的。</p><p>如果是编译期已经创建好(<strong><em>直接用双引号定义的</em></strong>)的就存储在常量池中，如果是运行期（**<em>new出来的**</em>）才能确定的就存储在堆中。</p><p>对于equals相等的字符串，在常量池中永远只有一份，在堆中可以有多份。</p><p>如以下代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">1. String s1 = "china"; 2. String s2 = "china"; 3. String s3 = "china"; 4. String ss1 = new String("china"); 5. String ss2 = new String("china"); 6. String ss3 = new String("china"); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解释：</strong>黄色这3个箭头，对于通过new产生一个字符串时，会先去常量池中查找是否已经有了”china”对象，如果没有则在常量池中创建一个此字符串对象，然后堆中再创建一个常量池中此”china”对象的拷贝对象。</p><p><strong>经典面试题：</strong>String s = new String(“xyz”)；产生几个对象？一个或两个，如果常量池中原来没有”xyz”，就是两个。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20211021143837713.png" alt="image-20211021143837713"></p><h4 id="4-基础类型的变量和常量在堆栈、常量池中的存储"><a href="#4-基础类型的变量和常量在堆栈、常量池中的存储" class="headerlink" title="4. 基础类型的变量和常量在堆栈、常量池中的存储"></a>4. 基础类型的变量和常量在堆栈、常量池中的存储</h4><p>对于基础类型的变量和常量：变量和引用存储在栈中，常量存储在常量池中。</p><p>如以下代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">1. int i1 = 9; 2. int i2 = 9; 3. int i3 = 9;  4. public static final int INT1 = 9; 5. public static final int INT2 = 9; 6. public static final int INT3 = 9; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20211021143915652.png" alt="image-20211021143915652"></p><h4 id="5-成员变量和局部变量在堆栈、常量池中的存储"><a href="#5-成员变量和局部变量在堆栈、常量池中的存储" class="headerlink" title="5. 成员变量和局部变量在堆栈、常量池中的存储"></a>5. 成员变量和局部变量在堆栈、常量池中的存储</h4><p>对于成员变量和局部变量：成员变量就是方法外部，类的内部定义的变量；局部变量就是方法或语句块内部定义的变量。<strong>注意：局部变量必须初始化</strong>。</p><p>形式参数是局部变量，局部变量的数据存于栈内存中，栈内存中的局部变量随着方法的消失而消失。成员变量存储在堆中的对象里面，由垃圾回收器负责回收。</p><p>如以下代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">1. class BirthDate { 2.   private int day; 3.   private int month; 4.   private int year;   5.   public BirthDate(int d, int m, int y) { 6.     day = d;  7.     month = m;  8.     year = y; 9.   } 10.   省略get,set方法……… 11. } 12.  13. public class Test{ 14.   public static void main(String args[]){ 15.     int date = 9; 16.     Test test = new Test();    17.     test.change(date);  18.     BirthDate d1= new BirthDate(7,7,1970);     19.   }  20.  21.   public void change1(int i){ 22.      i = 1234; 23.   } 24. }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20211021143940086.png" alt="image-20211021143940086"></p><p><strong>解释：</strong>对于以上这段代码，date为局部变量，i,d,m,y都是形参为局部变量，day，month，year为成员变量。下面分析一下代码执行时候的变化：</p><ol><li><p>main方法开始执行：int date = 9;</p><p>date局部变量，基础类型，引用和值都存在栈中。</p></li><li><p>Test test = new Test();</p><p>test为对象引用，存在栈中，对象(new Test())存在堆中。</p></li><li><p>test.change(date);</p><p>i为局部变量，引用和值存在栈中。当方法change执行完成后，i就会从栈中消失。</p></li><li><p>BirthDate d1= new BirthDate(7,7,1970); </p><p>d1为对象引用，存在栈中，对象(new BirthDate())存在堆中，其中d，m，y为局部变量存储在栈中，且它们的类型为基础类型，因此它们的数据也存储在栈中。day,month,year为成员变量，它们存储在堆中(new BirthDate()里面)。当BirthDate构造方法执行完之后，d,m,y将从栈中消失。</p></li><li><p>main方法执行完之后，date变量，test，d1引用将从栈中消失，new Test(),new BirthDate()将等待垃圾回收。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 堆 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 常量池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程基础 进制的定义，二进制、十进制、十六进制的相互转换</title>
      <link href="2021/101529978.html"/>
      <url>2021/101529978.html</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="编程基础-进制的定义，二进制、十进制、十六进制的相互转换"><a href="#编程基础-进制的定义，二进制、十进制、十六进制的相互转换" class="headerlink" title="编程基础 进制的定义，二进制、十进制、十六进制的相互转换"></a>编程基础 进制的定义，二进制、十进制、十六进制的相互转换</h2><h3 id="1-进制的定义"><a href="#1-进制的定义" class="headerlink" title="1. 进制的定义"></a>1. 进制的定义</h3><p>首先我们需要先了解什么是进制？进制是学习计算机语言最基本的知识，所以一定要掌握。其实它很简单，我们日常生活中有很多进制的例子，例如：</p><ul><li>一分钟六十秒，逢六十进一，就是六十进制；</li><li>一天二十四小时，逢二十四进一，就是二十四进制；</li><li>一星期七天，逢七进一，就是七进制；</li><li>一年十二个月，逢十二进一，就是十二进制；</li><li>小学数学是逢十进一，就是十进制；</li><li>而计算机中的数据只有 0 和 1，逢二进一，就是二进制。</li></ul><p>所以进制就是逢几进一，r 进制就是逢 r 进一。计算机只能识别二进制，人类最习惯使用的是十进制，而为了实际需要，又建立了八进制和十六进制。八进制就是逢八进一，十六进制就是逢十六进一。</p><h3 id="2-进制的规范"><a href="#2-进制的规范" class="headerlink" title="2. 进制的规范"></a>2. 进制的规范</h3><p>C语言中规定了八进制数前面要加<code>0</code>（注意是数字零而不是字母 o），十六进制数前面要加<code>0x</code>或<code>0X</code>，而十进制前面什么都不加。这是为什么呢？</p><p>比如 5，到底是十进制、八进制还是十六进制？什么都不加就默认是十进制。如果希望 5 是八进制，那么前面就加上 <code>0</code>；如果希望 5 是十六进制，那么前面就加上<code>0x</code>或<code>0X</code>。</p><h3 id="3-进制的进位运算"><a href="#3-进制的进位运算" class="headerlink" title="3. 进制的进位运算"></a>3. 进制的进位运算</h3><h4 id="3-1-十进制"><a href="#3-1-十进制" class="headerlink" title="3.1 十进制"></a>3.1 十进制</h4><p>十进制为逢十进一，它只有 0、1、2、3、4、5、6、7、8、9 这十个基数。逢十进一的意思就是：9 再加 1 就变为 10，即向十位进了一位，原来个位回归 0。</p><h4 id="3-2-二进制"><a href="#3-2-二进制" class="headerlink" title="3.2 二进制"></a>3.2 二进制</h4><p>二进制为逢二进一，它只有 0 和 1 两个基数。逢二进一的意思就是：</p><ul><li>1 再加 1 就变成 10，即向前进了一位，原来的 1 变成 0；</li><li>再加 1 就是 11；</li><li>再加 1 又逢二，再往前进一位，进一位后第二个 1 又逢二再进位，就是 100 了；</li><li>再加 1 变成 101，再加 1 变成 110，再加 1 变成 111，再加 1 变成 1000……</li></ul><table><thead><tr><th>十进制</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>二进制</td><td>0</td><td>1</td><td>10</td><td>11</td><td>100</td><td>101</td><td>110</td><td>111</td><td>1000</td></tr></tbody></table><p>无论是十进制、二进制、八进制还是十六进制，都只是计数的一种方式，只不过它们用的是不同的进制，所以表现形式不一样，但本质上都是同一个数字。理解了上面内容，后面很多知识就很容易理解了。</p><h4 id="3-3-八进制"><a href="#3-3-八进制" class="headerlink" title="3.3 八进制"></a>3.3 八进制</h4><p>八进制就是逢八进一，它只有 0、1、2、3、4、5、6、7 这八个基数。</p><p>由上可以总结出，r 进制有 r 个基数，而且基数里面最大的是 r–1，因为基数都是从 0 开始的。比如五进制中，基数最大的是 4，基数分别为 0、1、2、3、4。</p><h4 id="3-4-十六进制"><a href="#3-4-十六进制" class="headerlink" title="3.4 十六进制"></a>3.4 十六进制</h4><p>十六进制肯定有十六个基数。它的基数除了十进制的 0<del>9 之外，还有字母 A</del>F，总共加起来是十六个。注意，字母不区分大小写。十六进制是逢十六进一，F 是十五，加 1 就变成十六了，逢十六就进一，即<code>0x10</code>。</p><h4 id="3-5-进制表"><a href="#3-5-进制表" class="headerlink" title="3.5 进制表"></a>3.5 进制表</h4><p>下面是常用进制对照表，大家可以看一下。</p><table><thead><tr><th>十进制</th><th>二进制</th><th>八进制</th><th>十六进制</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>2</td><td>10</td><td>2</td><td>2</td></tr><tr><td>3</td><td>11</td><td>3</td><td>3</td></tr><tr><td>4</td><td>100</td><td>4</td><td>4</td></tr><tr><td>5</td><td>101</td><td>5</td><td>5</td></tr><tr><td>6</td><td>110</td><td>6</td><td>6</td></tr><tr><td>7</td><td>111</td><td>7</td><td>7</td></tr><tr><td>8</td><td>1000</td><td>10</td><td>8</td></tr><tr><td>9</td><td>1001</td><td>11</td><td>9</td></tr><tr><td>10</td><td>1010</td><td>12</td><td>A</td></tr><tr><td>11</td><td>1011</td><td>13</td><td>B</td></tr><tr><td>12</td><td>1100</td><td>14</td><td>C</td></tr><tr><td>13</td><td>1101</td><td>15</td><td>D</td></tr><tr><td>14</td><td>1110</td><td>16</td><td>E</td></tr><tr><td>15</td><td>1111</td><td>17</td><td>F</td></tr></tbody></table><h3 id="4-进制的相互转换"><a href="#4-进制的相互转换" class="headerlink" title="4. 进制的相互转换"></a>4. 进制的相互转换</h3><p>从上面的介绍我们知道了进制只是数字的不同表现形式，它们本质上表示的是同一个数。那么既然是同一个数，进制之间可不可以相互转换呢？答案是肯定的。下面我们就对二进制、十进制、十六进制进行相互转换，让大家更清晰的了解进制。</p><h4 id="4-1-二进制与十进制的相互转化"><a href="#4-1-二进制与十进制的相互转化" class="headerlink" title="4.1 二进制与十进制的相互转化"></a>4.1 二进制与十进制的相互转化</h4><ul><li><p><strong><em>十进制转二进制的转换原理</em></strong>：除以2，反向取余数，直到商为0终止。</p><p>例如：9(十进制)→1001(二进制），转换过程如下图：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20211015101727802.png" alt="image-20211015101727802"></p></li><li><p><strong><em>二进制转十进制的转换原理</em></strong>： 就是用进制的定义：二进制的每一个乘以2的n次方，n从0开始，每次递增1。然后得出来的每个数相加。</p><p>例如：1110(二进制)→ 14(十进制)  ，转换过程：<br>$$<br>1<em>2^3+1</em>2^2+1<em>2^1+0</em>2^0=14<br>$$<br><strong>推荐记住2的指数9以内的数：1、2、4、8、16、32、64、128、256、1024。</strong></p></li><li><p><strong><em>负数</em></strong>：这时候需引入补码的概念，一个byte第八位（最前位）是确定符号的位，0为正，1为负，但考虑到+0与-0值相等，为了使逻辑成立没有偏差，所以提出了补码表示法。</p><p>补码的计算公式：</p><p>​    正数：源码、反码和补码都相同。</p><p>​    负数：补码 = 反码（符号位保持不变） + 1</p><p>注意： 负数在计算补码的时候，在源码取反的过程中要保留符号位不变，其他位取反，例如：10001010取反11110101（第一个1不变）,补码就为11110110。</p><p><strong>注意：</strong></p><p>看一个二进制是否是正数还是负数，需要先说明其是存储在计算机中，然后要搞清楚其在计算机中是以有符号进行存储还是无符号进行存储。</p><ol><li><p>如果是无符号存储，则其为一个正数。</p></li><li><p>若是有符号存储，则为补码存储。</p><p> (补码存储)需要看其最高位，最高位为0，为正数; 反之，为负数。</p></li></ol><p>如果仅仅是给了一堆二进制：比如10101010，你如果不说是在哪存的？那么它是没有正负概念的。</p></li><li><p><strong><em>小数</em></strong></p><ol><li>十进制的小数转换为二进制，主要是小数部分乘以2，取整数部分依次从左往右放在小数点后，直至小数点后为0。例如十进制的0.125，要转换为二进制的小数，结果就是0.001。</li></ol><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20211015114658103.png" alt="image-20211015114658103"></p></li></ul><ol start="2"><li><p>二进制的小数转换为十进制主要是乘以2的负次方，从小数点后开始，依次乘以2的负一次方，2的负二次方，2的负三次方等。例如二进制数0.001转换为十进制，结果就是0.125。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20211015114944660.png" alt="image-20211015114944660"></p></li></ol><h4 id="4-2-二进制与十六进制的相互转换"><a href="#4-2-二进制与十六进制的相互转换" class="headerlink" title="4.2 二进制与十六进制的相互转换"></a>4.2 二进制与十六进制的相互转换</h4><p>二进制转换成十六进制的方法是，取四合一法，即从二进制的小数点为分界点，向左（或向右）每四位取成一位。需要注意的是，在向左（或向右）取四位时，取到最高位（最低位）如果无法凑足四位，就可以在小数点的最左边（或最右边）补0，进行换算。</p><p><strong>注意：</strong>16进制的表示法，用字母H后缀表示，比如B<code>H</code>就表示16进制数11；也可以用<code>0X</code>前缀表示，比如<code>0X</code>23就是16进制的23</p><p>这个转换比较简单，只需要记好二进制数的每四位对应一个16进制数，就能轻易的转换。而他们的对应关系在上面的进制表里也写的很清楚，为了方便理解，我再把对应关系放在下面：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20211015142555296.png" alt="image-20211015142555296"></p><p>举个例子：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20211015143026299.png" alt="image-20211015143026299"></p><h4 id="4-3-十进制与十六进制的相互转换"><a href="#4-3-十进制与十六进制的相互转换" class="headerlink" title="4.3 十进制与十六进制的相互转换"></a>4.3 十进制与十六进制的相互转换</h4><p>进行转换之前，先要知道十六进制与十进制的区别和表示方法：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20211015144911194.png" alt="image-20211015144911194"></p><ul><li><p><strong><em>十进制转十六进制</em></strong>（方式一）</p><p>可以采取十进制转二进制那种方式，也就是整除取余法，例如：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20211015144844844.png" alt="image-20211015144844844"></p></li><li><p><strong><em>十进制转十六进制</em></strong>（方式二）</p><p>十进制数转化为十六进制数可以先转二进制再转十六进制，例如：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20211015145136897.png" alt="image-20211015145136897"></p></li><li><p><strong><em>十六进制转十进制</em></strong></p><p>这和二进制转十进制相似，例如：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20211015145247671.png" alt="image-20211015145247671"></p></li></ul><h3 id="5-人类为什么最习惯用十进制"><a href="#5-人类为什么最习惯用十进制" class="headerlink" title="5. 人类为什么最习惯用十进制"></a>5. 人类为什么最习惯用十进制</h3><p>人类为什么最习惯用逢十进一的十进制？对于世界上大部分的国家，即便之前因为交通不发达，他们彼此之间并不知道在世界的某一个角落还有另一个民族的存在，但是他们使用的都是十进制！这是为什么？</p><p>原因很简单，就是因为我们都有十个手指！进制的起源是用于记数的，人类刚开始都是用手指计数的。即使是现在的小朋友算数也还是喜欢用手指，所以人类最习惯用十进制。</p><h3 id="6-计算机为什么用的是二进制"><a href="#6-计算机为什么用的是二进制" class="headerlink" title="6. 计算机为什么用的是二进制"></a>6. 计算机为什么用的是二进制</h3><p>那么为什么计算机使用的是二进制呢？</p><p>因为二进制从硬件上比较容易实现。任何事物最少也有两种不同的状态，所以区分成两种状态比较容易。但是要将一个硬件硬生生地区分成十种不同的状态，这个就太难、太复杂了。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>进制是学习计算机必须要掌握的内容，也是一个重点。</p><ul><li>掌握进制的概念，区分八进制数、十进制数和十六进制数的表示方法。注意八进制数是以<code>0</code>开头，十六进制数是以<code>0x</code>或<code>0X</code>开头，以及了解其原因。</li><li>掌握进制只是数字的不同表现形式，它们本质上表示的是同一个数。</li><li>了解为什么人类习惯使用十进制而计算机使用的却是二进制。</li><li>掌握进制间的相互转化</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二进制 </tag>
            
            <tag> 十进制 </tag>
            
            <tag> 十六进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea创建SpringMVC配置文件模板，spring.xml、mybatis.xml、web.xml模板一应俱全</title>
      <link href="2021/092833402.html"/>
      <url>2021/092833402.html</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="idea创建SpringMVC配置文件模板，spring-xml、mybatis-xml、web-xml模板一应俱全"><a href="#idea创建SpringMVC配置文件模板，spring-xml、mybatis-xml、web-xml模板一应俱全" class="headerlink" title="idea创建SpringMVC配置文件模板，spring.xml、mybatis.xml、web.xml模板一应俱全"></a>idea创建SpringMVC配置文件模板，spring.xml、mybatis.xml、web.xml模板一应俱全</h2><p>在SSM项目开发中，会用到很多的配置文件，比如spring-mvc.xml,web.xml,mybatis-config.xml等等，在开发过程中我们往往只想往里面添加我们想要的配置即可，其他的像配置文件的dtd，文件头等既难记，也不好写，jdbc.properties等配置文件的内容几乎不会改变写起来也比较繁琐，好在idea提供给大家创建模板的功能，可以给大家减少这些繁琐的操作。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210928093139697.png" alt="image-20210928093139697"></p><p>下面提供一整套的配置文件模板供大家使用：</p><h4 id="1、spring-xml模板"><a href="#1、spring-xml模板" class="headerlink" title="1、spring.xml模板"></a>1、spring.xml模板</h4><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>context</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/context<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>p</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/p<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>aop</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/aop<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>tx</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/tx<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsdhttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsdhttp://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsdhttp://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2、web-xml模板"><a href="#2、web-xml模板" class="headerlink" title="2、web.xml模板"></a>2、web.xml模板</h4><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>web-app</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://xmlns.jcp.org/xml/ns/javaee<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://xmlns.jcp.org/xml/ns/javaee                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd<span class="token punctuation">"</span></span>         <span class="token attr-name">version</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>4.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>web-app</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3、mybatis-config-xml模板"><a href="#3、mybatis-config-xml模板" class="headerlink" title="3、mybatis-config.xml模板"></a>3、mybatis-config.xml模板</h4><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">configuration</span>        <span class="token name">PUBLIC</span> <span class="token string">"-//mybatis.org//DTD Config 3.0//EN"</span>        <span class="token string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4、mapper-xml模板"><a href="#4、mapper-xml模板" class="headerlink" title="4、mapper.xml模板"></a>4、mapper.xml模板</h4><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">mapper</span> <span class="token name">PUBLIC</span> <span class="token string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="token string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span> <span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5、jdbc-properties模板"><a href="#5、jdbc-properties模板" class="headerlink" title="5、jdbc.properties模板"></a>5、jdbc.properties模板</h4><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/javaeedatabase?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT%2B8&amp;useSSL=false&amp;allowPublicKeyRetrieval=truejdbc.username=rootjdbc.password=root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6、log4j-properties模板"><a href="#6、log4j-properties模板" class="headerlink" title="6、log4j.properties模板"></a>6、log4j.properties模板</h4><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"># Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
            <tag> 配置文件 </tag>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java高级 SSM项目部署以及ajax的详细使用过程</title>
      <link href="2021/092842322.html"/>
      <url>2021/092842322.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java高级-SSM项目部署以及ajax的详细使用过程"><a href="#Java高级-SSM项目部署以及ajax的详细使用过程" class="headerlink" title="Java高级 SSM项目部署以及ajax的详细使用过程"></a>Java高级 SSM项目部署以及ajax的详细使用过程</h2><p>[toc]</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​        很多刚开始学习JavaEE的新手同学，都或多或少地觉得使用Ajax来实现http请求是一件棘手的事情。今天我通过写一个简单的案例来给大家一个清晰的流程和思路。案例比较简单，希望能帮上大家。下面附上我的代码分解：</p><h3 id="1、开发环境"><a href="#1、开发环境" class="headerlink" title="1、开发环境"></a>1、开发环境</h3><pre class="line-numbers language-apl" data-language="apl"><code class="language-apl">jdk8 + tomcat8 + idea2019 + MySql8 + SQLyog<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2、数据库"><a href="#2、数据库" class="headerlink" title="2、数据库"></a>2、数据库</h3><pre class="line-numbers language-apl" data-language="apl"><code class="language-apl">/*Navicat MySQL Data TransferSource Host     : localhost:3306Source Database : mybatisTarget Host     : localhost:3306Target Database : mybatisDate: 2021-09-26 11:24:31*//*执行sql脚本时，不让外键受影响导致出错*/SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for user-- ----------------------------DROP TABLE IF EXISTS `user`;CREATE TABLE `user` (  `id` INT(11) NOT NULL AUTO_INCREMENT,  `username` VARCHAR(32) NOT NULL COMMENT '用户名称',  `password` VARCHAR(255) DEFAULT NULL,  `birthday` DATE DEFAULT NULL COMMENT '生日',  `sex` CHAR(1) DEFAULT NULL COMMENT '性别',  `address` VARCHAR(256) DEFAULT NULL COMMENT '地址',  PRIMARY KEY (`id`)) ENGINE=INNODB AUTO_INCREMENT=30 DEFAULT CHARSET=utf8; -- ------------------------------ Records of user-- ----------------------------INSERT INTO `user` VALUES ('1', '张三', '123', '2014-07-10', '2', '成都市');INSERT INTO `user` VALUES ('2', '李四', '123', '2014-07-10', '1', '成都市');INSERT INTO `user` VALUES ('3', '王五', '123', '2014-07-10', '1', '重庆市');INSERT INTO `user` VALUES ('4', '赵六', '123', '2014-07-10', '1', '重庆市');INSERT INTO `user` VALUES ('5', '田七', '123', '2014-07-10', '1', '扬州市');INSERT INTO `user` VALUES ('6', '迪迦', '222', '2014-07-10', '1', '扬州市');INSERT INTO `user` VALUES ('7', '泰罗', '222', '2014-07-10', '2', '北京市');INSERT INTO `user` VALUES ('8', '艾斯', '222', '2017-05-03', '1', '北京市');INSERT INTO `user` VALUES ('9', '爱迪', '222', '2017-05-03', '2', '昆明市');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、工程配置"><a href="#3、工程配置" class="headerlink" title="3、工程配置"></a>3、工程配置</h3><p><strong>在idea中创建maven工程“ajaxDemo”，然后进行以下配置：</strong></p><h4 id="3-1-项目结构"><a href="#3-1-项目结构" class="headerlink" title="3.1 项目结构"></a>3.1 项目结构</h4><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210927160553830.png" alt="image-20210927160553830"></p><h4 id="3-2-配置工程支持WEB开发"><a href="#3-2-配置工程支持WEB开发" class="headerlink" title="3.2 配置工程支持WEB开发"></a>3.2 配置工程支持WEB开发</h4><ol><li><p>在File选项卡中找到Project Structure选项进入</p></li><li><p>在Project Settings里找到Modules，点击左上方”+”，找到WEB模块，点击确定加入WEB模块</p></li><li><p>点击添加的WEB模块位置，将Deployment Descriptors里面的path修改成刚才我们建立的web.xml文件的位置</p></li><li><p>在Web Resource Directories里面的路径修改成我们的web路径</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210927162413475.png" alt="image-20210927162413475"></p></li><li><p>点击Artfacts选项，点击“+”，选择Web Application:Exploaded，选择from modules，找到我们刚才建立的web工程点击确定，这样才能让我们可以在WEBAPP目录下建立JSP文件，并且tomcat服务器找到该WEB项目进行部署和运行。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210927163443640.png" alt="image-20210927163443640"></p></li></ol><h4 id="3-3-配置文件"><a href="#3-3-配置文件" class="headerlink" title="3.3 配置文件"></a>3.3 配置文件</h4><h5 id="3-3-1-spring-dao-xml配置文件"><a href="#3-3-1-spring-dao-xml配置文件" class="headerlink" title="3.3.1 spring-dao.xml配置文件"></a>3.3.1 spring-dao.xml配置文件</h5><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>context</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/context<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>p</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/p<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>aop</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/aop<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>tx</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/tx<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsdhttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsdhttp://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsdhttp://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 读取配置--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>property-placeholder</span> <span class="token attr-name">location</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>classpath*:jdbc.properties<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token comment">&lt;!--数据源--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.alibaba.druid.pool.DruidDataSource<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>driverClassName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${jdbc.driver}<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>url<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${jdbc.url}<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${jdbc.username}<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${jdbc.password}<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 配置SqlSessionFactory --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span>  <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sqlSessionFactory<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.mybatis.spring.SqlSessionFactoryBean<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- 设置数据源 --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mapperLocations<span class="token punctuation">"</span></span>  <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>classpath*:mapper/*.xml<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 配置Mapper扫描 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.mybatis.spring.mapper.MapperScannerConfigurer<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- 设置Mapper扫描包 --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>basePackage<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.wedu.dao<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>     <span class="token comment">&lt;!-- 配置Service扫描 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>component-scan</span> <span class="token attr-name">base-package</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.wedu.service<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.wedu.service.impl.UserServiceImpl<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-3-2-spring-service-xml配置文件"><a href="#3-3-2-spring-service-xml配置文件" class="headerlink" title="3.3.2 spring-service.xml配置文件"></a>3.3.2 spring-service.xml配置文件</h5><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>context</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/context<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>p</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/p<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>aop</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/aop<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>tx</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/tx<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsdhttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsdhttp://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsdhttp://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 配置Service扫描 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>component-scan</span> <span class="token attr-name">base-package</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.wedu.service<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-3-3-spring-trans-xml配置文件-事务相关配置，目前的这个demo用不上，大家可以先看看"><a href="#3-3-3-spring-trans-xml配置文件-事务相关配置，目前的这个demo用不上，大家可以先看看" class="headerlink" title="3.3.3 spring-trans.xml配置文件(事务相关配置，目前的这个demo用不上，大家可以先看看)"></a>3.3.3 spring-trans.xml配置文件(事务相关配置，目前的这个demo用不上，大家可以先看看)</h5><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>context</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/context<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>p</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/p<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>aop</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/aop<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>tx</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/tx<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsdhttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsdhttp://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsdhttp://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 事务管理器 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>transactionManager<span class="token punctuation">"</span></span><span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.springframework.jdbc.datasource.DataSourceTransactionManager<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- 数据源 --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 通知 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>advice</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>txAdvice<span class="token punctuation">"</span></span> <span class="token attr-name">transaction-manager</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>transactionManager<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>attributes</span><span class="token punctuation">&gt;</span></span>            <span class="token comment">&lt;!-- 传播行为 --&gt;</span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>method</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>save*<span class="token punctuation">"</span></span> <span class="token attr-name">propagation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>REQUIRED<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>method</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>insert*<span class="token punctuation">"</span></span> <span class="token attr-name">propagation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>REQUIRED<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>method</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>add*<span class="token punctuation">"</span></span> <span class="token attr-name">propagation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>REQUIRED<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>method</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>create*<span class="token punctuation">"</span></span> <span class="token attr-name">propagation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>REQUIRED<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>method</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>delete*<span class="token punctuation">"</span></span> <span class="token attr-name">propagation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>REQUIRED<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>method</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>update*<span class="token punctuation">"</span></span> <span class="token attr-name">propagation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>REQUIRED<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>method</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>find*<span class="token punctuation">"</span></span> <span class="token attr-name">propagation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>SUPPORTS<span class="token punctuation">"</span></span> <span class="token attr-name">read-only</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>method</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>select*<span class="token punctuation">"</span></span> <span class="token attr-name">propagation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>SUPPORTS<span class="token punctuation">"</span></span> <span class="token attr-name">read-only</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>method</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>get*<span class="token punctuation">"</span></span> <span class="token attr-name">propagation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>SUPPORTS<span class="token punctuation">"</span></span> <span class="token attr-name">read-only</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>method</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>query*<span class="token punctuation">"</span></span> <span class="token attr-name">propagation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>SUPPORTS<span class="token punctuation">"</span></span> <span class="token attr-name">read-only</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">tx:</span>attributes</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">tx:</span>advice</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 切面 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>config</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>advisor</span> <span class="token attr-name">advice-ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>txAdvice<span class="token punctuation">"</span></span>                     <span class="token attr-name">pointcut</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>execution(* com.wedu.service.*.*(..))<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">aop:</span>config</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--    &lt;jdbc:embedded-database id="dataSource"/&gt;--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-3-4-spring-mvc-xml配置文件"><a href="#3-3-4-spring-mvc-xml配置文件" class="headerlink" title="3.3.4 spring-mvc.xml配置文件"></a>3.3.4 spring-mvc.xml配置文件</h5><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>context</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/context<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>p</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/p<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>aop</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/aop<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>tx</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/tx<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>mvc</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/mvc<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsdhttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsdhttp://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsdhttp://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 配置Controller扫描 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>component-scan</span> <span class="token attr-name">base-package</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.wedu.controller<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token comment">&lt;!-- 配置注解驱动 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>annotation-driven</span> <span class="token punctuation">/&gt;</span></span>    <span class="token comment">&lt;!-- 配置视图解析器 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span><span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.springframework.web.servlet.view.InternalResourceViewResolver<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- 前缀 --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>prefix<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/pages/<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        <span class="token comment">&lt;!-- 后缀 --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>suffix<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>.jsp<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>interceptors</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- 拦截器记录操作日志 --&gt;</span>        <span class="token comment">&lt;!-- 使用bean直接定义在&lt;mvc:interceptors&gt;下面的拦截器将拦截所有请求 --&gt;</span>        <span class="token comment">&lt;!-- 这个是全局的，当使用下面的拦截器时，需要把这个拦截器注释掉 --&gt;</span>        <span class="token comment">&lt;!-- &lt;bean class="com.springmvc.interceptor.MyInterceptor"/&gt;--&gt;</span>        <span class="token comment">&lt;!-- 定义多个拦截器，顺序执行 --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>interceptor</span><span class="token punctuation">&gt;</span></span>   <span class="token comment">&lt;!-- 拦截器 --&gt;</span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>mapping</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/**<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>     <span class="token comment">&lt;!-- 配置拦截器作用的路径 /**表示拦截所有url路径包括子url路径--&gt;</span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>exclude-mapping</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/resources/**<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>   <span class="token comment">&lt;!-- 配置不需要拦截器作用的路径 --&gt;</span>            <span class="token comment">&lt;!-- 定义在&lt;mvc:interceptor&gt;下面的拦截器，表示匹配路径请求才进行拦截 --&gt;</span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.wedu.interceptor.JournalInterceptor<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">mvc:</span>interceptor</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">mvc:</span>interceptors</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--自定义消息转换器的编码,解决后台传输json回前台时，中文乱码问题--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>annotation-driven</span> <span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>message-converters</span> <span class="token attr-name">register-defaults</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.springframework.http.converter.StringHttpMessageConverter<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>supportedMediaTypes<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>list</span><span class="token punctuation">&gt;</span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>application/json;charset=utf-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>text/html;charset=utf-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span>                        <span class="token comment">&lt;!-- application 可以在任意 form 表单里面 enctype 属性默认找到 --&gt;</span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">&gt;</span></span>application/x-www-form-urlencoded<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">&gt;</span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>list</span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.springframework.http.converter.json.MappingJackson2HttpMessageConverter<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">mvc:</span>message-converters</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">mvc:</span>annotation-driven</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-3-5-web-xml配置文件"><a href="#3-3-5-web-xml配置文件" class="headerlink" title="3.3.5 web.xml配置文件"></a>3.3.5 web.xml配置文件</h5><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>web-app</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://xmlns.jcp.org/xml/ns/javaee<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://xmlns.jcp.org/xml/ns/javaee                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd<span class="token punctuation">"</span></span>         <span class="token attr-name">version</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>4.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>display-name</span><span class="token punctuation">&gt;</span></span>ajaxProject<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>display-name</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 配置spring --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>context-param</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">&gt;</span></span>contextConfigLocation<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">&gt;</span></span>classpath:spring/spring-*.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>context-param</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 配置监听器加载spring --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>listener</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>listener-class</span><span class="token punctuation">&gt;</span></span>org.springframework.web.context.ContextLoaderListener<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>listener-class</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>listener</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 配置过滤器，解决post的乱码问题 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">&gt;</span></span>encoding<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-class</span><span class="token punctuation">&gt;</span></span>org.springframework.web.filter.CharacterEncodingFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-class</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-mapping</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">&gt;</span></span>encoding<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">&gt;</span></span>/*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-mapping</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 使用filter实现登录控制 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">&gt;</span></span>LoginFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-class</span><span class="token punctuation">&gt;</span></span>com.wedu.filter.LoginFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-class</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-mapping</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">&gt;</span></span>LoginFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- 所有的页面需要登录后才能访问 --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">&gt;</span></span>/pages/*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-mapping</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-mapping</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">&gt;</span></span>LoginFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- 日志功能需要登录后才能访问 --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">&gt;</span></span>/journal/*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-mapping</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 配置SpringMVC --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">&gt;</span></span>ProjectManagementSystem<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">&gt;</span></span>org.springframework.web.servlet.DispatcherServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">&gt;</span></span>contextConfigLocation<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">&gt;</span></span>classpath*:spring/spring-mvc.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- 配置springmvc什么时候启动，参数必须为整数 --&gt;</span>        <span class="token comment">&lt;!-- 如果为0或者大于0，则springMVC随着容器启动而启动 --&gt;</span>        <span class="token comment">&lt;!-- 如果小于0，则在第一次请求进来的时候启动 --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>load-on-startup</span><span class="token punctuation">&gt;</span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>load-on-startup</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">&gt;</span></span>ProjectManagementSystem<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- 所有的请求都进入springMVC --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">&gt;</span></span>*.do<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>welcome-file-list</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>welcome-file</span><span class="token punctuation">&gt;</span></span>index.jsp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>welcome-file</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>welcome-file</span><span class="token punctuation">&gt;</span></span>index.html<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>welcome-file</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>welcome-file-list</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>web-app</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-3-6-jdbc-properties配置文件-数据库连接配置"><a href="#3-3-6-jdbc-properties配置文件-数据库连接配置" class="headerlink" title="3.3.6 jdbc.properties配置文件(数据库连接配置)"></a>3.3.6 jdbc.properties配置文件(数据库连接配置)</h5><pre class="line-numbers language-apl" data-language="apl"><code class="language-apl">jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ajaxdemo?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT%2B8&amp;useSSL=false&amp;allowPublicKeyRetrieval=truejdbc.username=rootjdbc.password=root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-3-7-log4j-properties配置文件-日志文件配置"><a href="#3-3-7-log4j-properties配置文件-日志文件配置" class="headerlink" title="3.3.7 log4j.properties配置文件(日志文件配置)"></a>3.3.7 log4j.properties配置文件(日志文件配置)</h5><pre class="line-numbers language-apl" data-language="apl"><code class="language-apl"># Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-3-8-mapper配置文件-sql语句"><a href="#3-3-8-mapper配置文件-sql语句" class="headerlink" title="3.3.8 mapper配置文件(sql语句)"></a>3.3.8 mapper配置文件(sql语句)</h5><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">mapper</span> <span class="token name">PUBLIC</span> <span class="token string">"-//mybatis.org//DTD Mapper 3.0//EN"</span>        <span class="token string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span> <span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.wedu.dao.UserDao<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>login<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.wedu.bean.User<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.wedu.bean.User<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>select * from user where username = #{username} and password = #{password}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4、创建类和jsp文件"><a href="#4、创建类和jsp文件" class="headerlink" title="4、创建类和jsp文件"></a>4、创建类和jsp文件</h3><h4 id="4-1-创建实体类User"><a href="#4-1-创建实体类User" class="headerlink" title="4.1 创建实体类User"></a>4.1 创建实体类User</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.wedu.bean;import java.util.Date;public class User {    private Integer id;    private String username;    private String password;    private String address;    private Date birthday;    private char sex;    public User(Integer id, String username, String password, String address, Date birthday, char sex) {        this.id = id;        this.username = username;        this.password = password;        this.address = address;        this.birthday = birthday;        this.sex = sex;    }    public User() {    }    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getUsername() {        return username;    }    public void setUsername(String username) {        this.username = username;    }    public String getPassword() {        return password;    }    public void setPassword(String password) {        this.password = password;    }    public String getAddress() {        return address;    }    public void setAddress(String address) {        this.address = address;    }    public Date getBirthday() {        return birthday;    }    public void setBirthday(Date birthday) {        this.birthday = birthday;    }    public char getSex() {        return sex;    }    public void setSex(char sex) {        this.sex = sex;    }    @Override    public String toString() {        return "User{" +                "id=" + id +                ", username='" + username + '\'' +                ", password='" + password + '\'' +                ", address='" + address + '\'' +                ", birthday=" + birthday +                ", sex=" + sex +                '}';    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-数据访问层UserDao，对应UserMapper"><a href="#4-2-数据访问层UserDao，对应UserMapper" class="headerlink" title="4.2 数据访问层UserDao，对应UserMapper"></a>4.2 数据访问层UserDao，对应UserMapper</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.wedu.dao;import com.wedu.bean.User;public interface UserDao {    User login(User user);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-3-service层UserService"><a href="#4-3-service层UserService" class="headerlink" title="4.3 service层UserService"></a>4.3 service层UserService</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.wedu.service;import com.wedu.bean.User;public interface UserService {    User login(User user);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-4-UserService的实现类UserServiceImpl"><a href="#4-4-UserService的实现类UserServiceImpl" class="headerlink" title="4.4 UserService的实现类UserServiceImpl"></a>4.4 UserService的实现类UserServiceImpl</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.wedu.service.impl;import com.wedu.bean.User;import com.wedu.dao.UserDao;import com.wedu.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Propagation;import org.springframework.transaction.annotation.Transactional;@Service@Transactionalpublic class UserServiceImpl implements UserService {    @Autowired    private UserDao userDao;    @Override @Transactional(propagation = Propagation.NOT_SUPPORTED)//如果是查询，事务挂起    public User login(User user) {        // TODO Auto-generated method stub        return userDao.login(user);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-5-test，service层写好之后，可以写一个测试类测试数据是否能够访问到"><a href="#4-5-test，service层写好之后，可以写一个测试类测试数据是否能够访问到" class="headerlink" title="4.5 test，service层写好之后，可以写一个测试类测试数据是否能够访问到"></a>4.5 test，service层写好之后，可以写一个测试类测试数据是否能够访问到</h4><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210928001703131.png" alt="image-20210928001703131"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.wedu.test;import com.wedu.bean.User;import com.wedu.service.UserService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class test {        @Test        public void findUsers(){            ApplicationContext context = new ClassPathXmlApplicationContext("spring/spring-dao.xml");            UserService userService = (UserService) context.getBean("userService");            User u = new User();            u.setUsername("王五");            u.setPassword("123");            User user =userService.login(u);            System.out.println(user.toString());        }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数据访问成功：<br><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210928001754008.png" alt="image-20210928001754008"></p><h4 id="4-6-controller控制层"><a href="#4-6-controller控制层" class="headerlink" title="4.6 controller控制层"></a>4.6 controller控制层</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.wedu.controller;import com.wedu.bean.User;import com.wedu.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controller@RequestMapping("/user")public class UserController {    @Autowired    private UserService userService;    /**     * 登录     *     * @param user     */    @RequestMapping("login")    @ResponseBody    public User login(@RequestBody User user) {//使用@RequestBody Map&lt;String,String&gt; map也是可以的,接收前台传过来的参数        //返回用户信息，要使用@ResponseBody将返回值转换为JSON        return userService.login(user);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-7-jsp代码"><a href="#4-7-jsp代码" class="headerlink" title="4.7 jsp代码"></a>4.7 jsp代码</h4><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;<span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>登录<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bootstrap-3.3.7-dist/js/bootstrap.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bootstrap-3.3.7-dist/js/bootstrap.min.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>js/jquery-3.3.1.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>js/jquery-3.2.1.min.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span>          <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bootstrap-3.3.7-dist/css/bootstrap.css<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span>          <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bootstrap-3.3.7-dist/css/bootstrap.min.css<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">        <span class="token selector">td</span> <span class="token punctuation">{</span>            <span class="token property">padding</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">        <span class="token keyword">var</span> state <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//默认登录成功</span>        <span class="token function">$</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ready</span><span class="token punctuation">(</span>            <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//登录</span>                <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#login"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span>                    <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        $<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                            url <span class="token operator">:</span> <span class="token string">"user/login.do"</span><span class="token punctuation">,</span>                            type <span class="token operator">:</span> <span class="token string">"POST"</span><span class="token punctuation">,</span>                            <span class="token comment">/* data : "json", */</span>                            contentType <span class="token operator">:</span> <span class="token string">"application/json;charset=utf-8"</span><span class="token punctuation">,</span>                            <span class="token comment">//向后端传输的数据</span>                            data <span class="token operator">:</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                                username <span class="token operator">:</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#username"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">val</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                password <span class="token operator">:</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#password"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">val</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                            <span class="token comment">//处理后端返回的数据</span>                            <span class="token function-variable function">success</span> <span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                <span class="token comment">//将得到的前台数据转换为json</span>                                <span class="token comment">/*var message = JSON.stringify(result);*/</span>                                <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"接受到的数据是："</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出默认的json字符串</span>                                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> result <span class="token operator">!=</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                    <span class="token comment">//alert("接受到的数据是：" + message.username);</span>                                    <span class="token keyword">var</span> username <span class="token operator">=</span> result<span class="token punctuation">.</span>username<span class="token punctuation">;</span>                                    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token punctuation">;</span>                                    <span class="token keyword">var</span> password <span class="token operator">=</span> result<span class="token punctuation">.</span>password<span class="token punctuation">;</span>                                    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span>                                    <span class="token comment">//在前台做验证</span>                                    <span class="token keyword">if</span> <span class="token punctuation">(</span>username <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> username <span class="token operator">!=</span> <span class="token string">""</span>                                        <span class="token operator">&amp;&amp;</span> password <span class="token operator">!=</span> <span class="token keyword">null</span>                                        <span class="token operator">&amp;&amp;</span> password <span class="token operator">!=</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"用户登录成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                        window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>href<span class="token operator">=</span><span class="token string">"https://liulei-root.github.io/"</span><span class="token punctuation">;</span>                                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                                        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"用户登录失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                    <span class="token punctuation">}</span>                                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                                    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"用户登录失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token punctuation">}</span>                                <span class="token comment">//alert("接受到的数据是：" + message);</span>                            <span class="token punctuation">}</span><span class="token punctuation">,</span>                            <span class="token comment">//处理失败返回的数据</span>                            <span class="token function-variable function">error</span> <span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"用户登录失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${pageContext.request.contextPath }/user/login.do<span class="token punctuation">"</span></span>      <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>panel panel-default<span class="token punctuation">"</span></span> <span class="token style-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token style language-css"><span class="token property">width</span><span class="token punctuation">:</span>400px<span class="token punctuation">;</span> <span class="token property">margin</span><span class="token punctuation">:</span>40px auto</span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>panel-heading<span class="token punctuation">"</span></span>             <span class="token style-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token style language-css"><span class="token property">text-align</span><span class="token punctuation">:</span>center<span class="token punctuation">;</span><span class="token property">font-weight</span><span class="token punctuation">:</span>bold<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>用户登录<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>panel-body<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token style-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token style language-css"><span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">stylae</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width: 30%; <span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>用户名：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token style-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token style language-css"><span class="token property">width</span><span class="token punctuation">:</span> 70%<span class="token punctuation">;</span> </span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span>                                                    <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>form-control<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>请输入用户名<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token style-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token style language-css"><span class="token property">width</span><span class="token punctuation">:</span> 30%<span class="token punctuation">;</span> </span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>密<span class="token entity named-entity" title="&nbsp;">&amp;nbsp;</span><span class="token entity named-entity" title="&nbsp;">&amp;nbsp;</span>码：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token style-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token style language-css"><span class="token property">width</span><span class="token punctuation">:</span> 70%<span class="token punctuation">;</span> </span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span>                                                    <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>form-control<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>请输入密码<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">&gt;</span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">colspan</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span> <span class="token style-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token style language-css"><span class="token property">text-align</span><span class="token punctuation">:</span>center<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>btn btn-primary<span class="token punctuation">"</span></span>                                <span class="token attr-name">data-toggle</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>register<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>注册<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>btn btn-primary<span class="token punctuation">"</span></span>                                <span class="token attr-name">data-toggle</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>login<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>登录<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>引入bootstrap和jquery：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210928002522545.png" alt="image-20210928002522545"></p><p>最后配置tomcat运行。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210928002624050.png" alt="image-20210928002624050"></p><p>结束！！！</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ajax </tag>
            
            <tag> SpringMVC </tag>
            
            <tag> SSM </tag>
            
            <tag> Spring </tag>
            
            <tag> mbatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java高级 表单form提交中action和ajax使用区别</title>
      <link href="2021/092633819.html"/>
      <url>2021/092633819.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java高级-表单form提交中action和ajax使用区别"><a href="#Java高级-表单form提交中action和ajax使用区别" class="headerlink" title="Java高级 表单form提交中action和ajax使用区别"></a>Java高级 表单form提交中action和ajax使用区别</h2><p>前几天看见很多身边的人在学习ajax的时候出现了一个问题，就是不知道什么时候用action+submit提交数据，什么时候用ajax；还有人有疑问表示，不知道使用Ajax时是否需要使用到form表单的action属性。下面我用一个简单的登录案例为大家介绍一下action和ajax的具体区别是什么。</p><h4 id="1-action"><a href="#1-action" class="headerlink" title="1. action"></a>1. action</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;form id="login" action="/user/login" method="post"&gt;    &lt;input name="username" type="text" id="username"/&gt;    &lt;input name="password" type="password" id="password"/&gt;    &lt;input type="submit" value="登录"&gt;     &lt;input type="reset" value="重置"&gt;&lt;/form&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：</p><ul><li>使用action，input组合提交需要有“name”这个属性，值与实体类对应，然后传至后台。</li><li>点击提交通过action中的路径/user/login找到对应的控制器，数据传至后台，由后端控制界面跳转。</li><li>action用于整个界面跳转，数据传到后端可以通过控制器跳转到不同的页面，比如上面的代码：登录界面为一个单独的界面，当用户输入信息通过后端代码进行验证时，数据比对成功跳转到成功页面，否则跳转失败页面。</li><li>form表单默认采用get方式请求，可以通过method属性来设置请求方法。</li><li>action提交还可以通过js拼接字符串的方式携带参数，如：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;body&gt;  &lt;form id="login" action="/user/login" method="post"&gt;    &lt;input name="username" type="text" id="username"/&gt;    &lt;input name="password" type="password" id="password"/&gt;    &lt;input type="submit" value="登录" onClick="test()" &gt;     &lt;input type="reset" value="重置"&gt;  &lt;/form&gt;&lt;/body&gt;&lt;script&gt;    function test(){        var f = document.getElementsByTagName("form")[0];        f.action=f.action+"username="+document.getElementById("username").value;        alert(f.action);    }&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-ajax"><a href="#2-ajax" class="headerlink" title="2. ajax"></a>2. ajax</h4><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token operator">&lt;</span>body<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>form id<span class="token operator">=</span><span class="token string">"Userlogin"</span> action<span class="token operator">=</span><span class="token string">"/user/login"</span> method<span class="token operator">=</span><span class="token string">"post"</span><span class="token operator">&gt;</span>     <span class="token operator">&lt;</span>input name<span class="token operator">=</span><span class="token string">"userName"</span> type<span class="token operator">=</span><span class="token string">"text"</span> id<span class="token operator">=</span><span class="token string">"UserName"</span><span class="token operator">/</span><span class="token operator">&gt;</span>     <span class="token operator">&lt;</span>input name<span class="token operator">=</span><span class="token string">"password"</span> type<span class="token operator">=</span><span class="token string">"password"</span> id<span class="token operator">=</span><span class="token string">"password"</span><span class="token operator">/</span><span class="token operator">&gt;</span>     <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"button"</span> value<span class="token operator">=</span><span class="token string">"登录"</span> onClick<span class="token operator">=</span><span class="token string">"login()"</span><span class="token operator">&gt;</span>      <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"reset"</span>value<span class="token operator">=</span><span class="token string">"重置"</span><span class="token operator">&gt;</span>  <span class="token operator">&lt;</span><span class="token operator">/</span>form<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">&gt;</span><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">&gt;</span>        <span class="token keyword">function</span> <span class="token function">login</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            $<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                type<span class="token operator">:</span> <span class="token string">"POST"</span><span class="token punctuation">,</span><span class="token comment">//方法类型</span>                dataType<span class="token operator">:</span> <span class="token string">"json"</span><span class="token punctuation">,</span><span class="token comment">//服务器返回的数据类型</span>                url<span class="token operator">:</span> <span class="token string">"/user/login"</span> <span class="token punctuation">,</span><span class="token comment">//控制器url</span>                data<span class="token operator">:</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#login'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">serialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token function-variable function">success</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//测试是否有数据</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">.</span>resultCode <span class="token operator">==</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//200正确</span>                        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"成功登陆！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>href <span class="token operator">=</span> <span class="token string">'跳转路径'</span><span class="token punctuation">;</span><span class="token comment">//成功后跳转到某界面</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">else</span><span class="token punctuation">{</span>                      <span class="token function">alert</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token function-variable function">error</span> <span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"登录失败！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong></p><ul><li>在提交按钮上写上事件来触发ajax</li><li>input标签的type属性不能时submit，需要改成button，这样才能实现局部刷新，而不是页面跳转</li><li>action属性必须有，但是值可以为空，为空表示由本页面处理数据</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 表单提交 </tag>
            
            <tag> ajax </tag>
            
            <tag> action </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划经典例题“0-1背包”细节分析</title>
      <link href="2021/081138113.html"/>
      <url>2021/081138113.html</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="动态规划经典例题“0-1背包”细节分析"><a href="#动态规划经典例题“0-1背包”细节分析" class="headerlink" title="动态规划经典例题“0-1背包”细节分析"></a>动态规划经典例题“0-1背包”细节分析</h2><h3 id="1、动态规划原理回顾"><a href="#1、动态规划原理回顾" class="headerlink" title="1、动态规划原理回顾"></a>1、动态规划原理回顾</h3><ol><li><p>java实现动态规划的两种方式<br>方法一：递归<br>方法二：循环</p></li><li><p>原理<br>动态规划简单说就是当前结果仅依赖于几个子问题的结果</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">比如汉诺塔问题，把n个盘从A移动到C，仅依赖于：①把n-1个盘A --&gt;B (a步)②把最后一个盘从A --&gt;C (1步)③把n-1个盘B–&gt;C (b步)先得到 res=a+b+1而其中的a，b 又可以类似res一样分别分解成子问题，(b同理)a=a(n-1)+b(n-1)+1a(n-1)=a(n-2)+b(n-2)+1…a(2)=a(1)+b(1)+1此时a(1)=b(1)=1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、问题原型"><a href="#2、问题原型" class="headerlink" title="2、问题原型"></a>2、问题原型</h3></li></ol><p>如果对动态规划不熟悉的小伙伴可以先看看我的前一篇文章：</p><p><a href="https://blog.csdn.net/liulei952413829/article/details/119041491">算法思维——简单的方式打开动态规划</a></p><p><a href="https://liulei-root.github.io/2021/072326875.html">个人博客地址：https://liulei-root.github.io/2021/072326875.html</a></p><p><strong>0-1背包问题</strong>：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/1.jpg" alt="1"></p><ul><li>给定n个重量为w1，w2，w3，…,wn，价值为v1，v2，v3，…,vn的物品和容量为C的背包</li><li>求这个物品中一个最有价值的子集，使得在满足背包的容量的前提下，包内的总价值最大</li><li>注意：0-1背包问题指的是每个物品只能使用一次</li></ul><p><strong>思路解析</strong>：</p><p>在思考解题方式之前，根据我们对动态规划算法的了解，我们首先需要找到这个问题的状态转移方程，这是解决动态规划问题的核心，接下来我们一起来分析这个问题：</p><ul><li>背包问题无非有以下两种情况之一：</li><li>情况一，第i件物品太重放不进去,此时总价值为：f(w(i-1),C)</li><li>情况二，放入第i件物品，此时总价值为：v(i)+f(w(i-1),C-w(i))</li><li>于是得到状态转移方程，也就是两种选择中总价值最大的方案：放入或不放入 f(w(i),C) = max( f(w(i-1),C) , v(i)+f(w(i−1),C−w(i)) )</li></ul><h3 id="3、递归方法"><a href="#3、递归方法" class="headerlink" title="3、递归方法"></a>3、递归方法</h3><p>首先我们用递归的方式来尝试解决这个问题。</p><p>我们用f ( n , C ) 表示将前n个物品放进容量为C的背包里，得到的最大的价值。</p><p>我们用自顶向下的角度来看，假如我们已经进行到了最后一步（即求解将n个物品放到背包里获得的最大价值）,此时我们便有两种选择：</p><ol><li>不放第n个物品，此时总价值为F ( n − 1 , C )</li><li>放置第n个物品，此时总价值为v(n) + F ( n − 1 , C − w(n) ) )</li></ol><p>使用递归方式实现，有一个严重的问题需要解决，就是直接采用自顶向下的递归算法会导致要不止一次的解决公共子问题，因此效率是相当低下的。</p><p>我们可以将已经求得的子问题的结果保存下来，这样对子问题只会求解一次，这便是记忆化搜索，也就是我下面代码中memo的用法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.wedu.demo;public class KnapsackProblem {    private static int[][] memo;//中间变量，优化递归（记忆化搜索）    /**     * 自顶向下：递归     * @param w         物品重量     * @param v         物品价值     * @param index     当前待选择的物品索引     * @param capacity  当前背包有效容量     * @return          最大价值     */    public static int reKnapsack(int[] w, int[] v, int index, int capacity){        //如果索引无效或者容量不足，直接返回当前价值0        if (index &lt; 0 || capacity &lt;= 0)            return 0;        //如果此子问题已经求解过，则直接返回上次求解的结果        if (memo[index][capacity] != 0) {            return memo[index][capacity];        }        //不放第index个物品所得价值        int res = reKnapsack(w, v, index - 1, capacity);        //放第index个物品所得价值（前提是：第index个物品可以放得下）        if (w[index] &lt;= capacity) {            res = Math.max(res, v[index] + reKnapsack(w, v, index - 1, capacity - w[index]));        }        //添加子问题的解，便于下次直接使用        memo[index][capacity] = res;        return res;    }    public static void main(String[] args) {        int[] w = {2, 1, 3, 2};        int[] v = {12, 10, 20, 15};        int length = w.length;        int C = 5;//包大小        memo = new int[length][C + 1];//初始化中间变量        System.out.println(reKnapsack(w, v, length-1, 5));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4、循环方法"><a href="#4、循环方法" class="headerlink" title="4、循环方法"></a>4、循环方法</h3><p>循环方法，也是动态规划问题最常用的解题方法，使用这个方法，我们需要先找到三个关键目标：</p><ol><li><p><strong>建立状态转移方程</strong></p><p>上面已经推导过：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">dp[i][j] = Math.max(dp[i][j], v[i] + dp[i - 1][j - w[i]])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>缓存并复用以往结果</strong></p><p>我们使用二维数组来记录子问题的解：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int[][] dp = new int[length][C + 1];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>按顺序从小往大算</strong></p><p>循环遍历。</p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.wedu.demo;public class KnapsackProblem {    /**     * 自底向上：x     * @param w     物品重量     * @param v     物品价值     * @param C     当前背包有效容量     * @return      最大价值     */    public static int dpKnapsack(int[] w, int[] v, int C){        int length = w.length;        if (length == 0) {            return 0;        }        int[][] dp = new int[length][C + 1];        //初始化第一行        //仅考虑容量为C的背包放第0个物品的情况        for (int i = 0; i &lt;= C; i++) {            dp[0][i] = w[0] &lt;= i ? v[0] : 0;        }        //填充其他行和列        for (int i = 1; i &lt; length; i++) {            for (int j = 0; j &lt;= C; j++) {                dp[i][j] = dp[i - 1][j];                if (w[i] &lt;= j) {                    dp[i][j] = Math.max(dp[i][j], v[i] + dp[i - 1][j - w[i]]);                }            }        }        return dp[length - 1][C];    }    public static void main(String[] args) {        int[] w = {2, 1, 3, 2};        int[] v = {12, 10, 20, 15};        int C = 5;//包大小        System.out.println(dpKnapsack(w, v, 5));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5、拓展"><a href="#5、拓展" class="headerlink" title="5、拓展"></a>5、拓展</h3><ul><li><p><strong>问题</strong>：给定一个仅包含正整数的非空数组，确定该数组是否可以分成两部分，要求两部分的和相等</p></li><li><p>问题解析：</p><p>该问题我们可以利用背包问题的思想进行求解。</p></li></ul><p>假设给定元素个数为n的数组arr，数组元素的和为sum，对应于背包问题，等价于有n个物品，每个物品的重量和价值均为为arr[i]，背包的限重为sum/2，求解背包中的物品最大价值为多少？</p><ul><li>要求使用本章介绍的循环方法完成此题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法思维——简单的方式打开动态规划</title>
      <link href="2021/072326875.html"/>
      <url>2021/072326875.html</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="算法思维——简单的方式打开动态规划"><a href="#算法思维——简单的方式打开动态规划" class="headerlink" title="算法思维——简单的方式打开动态规划"></a>算法思维——简单的方式打开动态规划</h2><h3 id="1、什么是动态规划？"><a href="#1、什么是动态规划？" class="headerlink" title="1、什么是动态规划？"></a>1、什么是动态规划？</h3><p>“你怎么给一个4岁的孩子讲清楚动态规划？”</p><p>“首先你在纸上写下这样一串加法运算：1+1+1+1+1+1+1”<br>“他们的和是多少？”<br>数完之后回答“等于7”</p><p>“继续在算式的左边加一个1”<br>“现在等于几？”<br>很快就能回答出来“等于8”</p><p>“为什么第二次能够回答这么快呢？”<br>“因为你只加了一个1”<br>“所以这一次你不用再一个一个的数一遍了，你已经知道前面的答案是7。”</p><p>“那么什么是动态规划呢？没错，它就是把一个大的问题拆解成一堆小问题，解析时记住前面小问题的答案，为后面的解答节省时间，这就是动态规划”</p><p>相信很多人之前看到这个概念就已经打退堂鼓了，现在你是否对它有了一个新的认识？</p><h3 id="2、动态规划的核心思想"><a href="#2、动态规划的核心思想" class="headerlink" title="2、动态规划的核心思想"></a>2、动态规划的核心思想</h3><p>按照上面的解释，动态规划是把一个大问题拆解成一堆小问题，这个本身没啥问题，但是这个不是动态规划的核心思想，或者说，一个”大问题“之所以能用”动态规划“解决，并不是因为它能拆解成—堆小问题。</p><p>事实上任何大问题都能拆解成小问题，而它是否属于动态规划范畴，<strong>取决于用动态规划解决的这些”小问题“会不会被重复调用</strong>。</p><p>思想①：问题的答案依赖于问题的规模，也就是问题的所有答案构成了一个数列。</p><p><strong><em>举个例子：</em></strong></p><p>1个人有2条腿，2个人有4条腿，…. n 个人有多少条腿?答案是2n条腿。这里的2n,是问题的答案，n则是问题的规模，显然问题的答案是依赖于问题的规模的。答案是因变量，问题规模是自变量。因此，问题在所有规模下的答案可以构成一个数列(f(1),f(2),…,f(n))，比如这个“数腿”的例子就构成了间隔为2的等差数列(0,2,4,.. . ,2n)。</p><p>思想②：大规模问题的答案可以由小规模问题的答案递推得到，也就是f(n)的值可以由<br>{f(i)i&lt;n}中的个别求得。还是刚刚“数腿”的例子，显然f(n)可以基于f(n -1)求得: f(n)= f(n -1)+2。</p><h3 id="3、什么时候适合使用动态规划呢？"><a href="#3、什么时候适合使用动态规划呢？" class="headerlink" title="3、什么时候适合使用动态规划呢？"></a>3、什么时候适合使用动态规划呢？</h3><p>能用动态规划解决，不代表什么时候都适合用。比如刚刚的“数腿”例子，你可以写成f(n) = 2n的显式表达式形式，那么杀鸡就不必用牛刀了。但是，在许多场景，f(n)的显式式子是不易得到的，大多数情况下甚至无法得到，动态规划的魅力就出来了。</p><h3 id="4、应用动态规划——将动态规划拆分成三个子目标"><a href="#4、应用动态规划——将动态规划拆分成三个子目标" class="headerlink" title="4、应用动态规划——将动态规划拆分成三个子目标"></a>4、应用动态规划——将动态规划拆分成三个子目标</h3><p>当要应用动态规划来解决问题时，归根结底就是想办法完成以下三个关键目标：</p><ol><li><p><strong>建立状态转移方程</strong></p><p>这一步是最难的，大部分人都被卡在这里。这一步没太多的规律可说，只需抓住一个思维：当做已经知道f(1)~ f(n -1)的值，然后想办法利用它们求得f(n)。在“数腿”的例子中，状态转移方程即为f(n) = f(n —1)＋f(1)，即f(n) = f(n —1)＋2。</p></li><li><p><strong>缓存并复用以往结果</strong></p><p>这一步不难，但是很重要。如果没有合适地处理，很有可能就是指数和线性时间复杂度的区别。假设在“数腿”的例子中，我们不能用显式方程，只能用状态转移方程来解。如果现在<br>f(100）未知，但是刚刚求解过一次f(99)。如果不将其缓存起来，那么求f(100)时，我们就必须花100次加法运算重新获取。但是如果刚刚缓存过，只需复用这个子结果，那么将只需一次加法运算即可。</p></li><li><p><strong>按顺序从小往大算</strong></p><p>这里的“小”和“大”对应的是问题的规模，在这里也就是我们要从f(0). f(1) ，….到f(n)依次顺序计算。这一点在“数腿”的例子来看，似乎显而易见，因为状态方程基本限制了你只能从小到大一步步递推出最终的结果（假设我们仍然不能用显式方程)。然而当问题复杂起来的时候，你又可能乱了套，所以必须记住这也是目标之一。</p></li></ol><h3 id="5、案例解析"><a href="#5、案例解析" class="headerlink" title="5、案例解析"></a>5、案例解析</h3><p>动态规划实际上就是要我们在推导出状态转移万程后，根据状态转移方程用计算机暴力求解出答案。请切记一点：想用显式表达式？在动态规划中是不存在的！</p><p>因为要暴力计算，所以上面说的目标有两个是涉及到代码层面的：</p><ol><li>缓存中间结果：也就是搞个数组之类的存储空间记录中间结果。</li><li>按顺序从小往大计算：也就是搞个for循环依次计算。</li></ol><p>俗话说的好：talk is cheap, show me the code. 下面我们将用3个例子来给大家详细分析一下动态规划，案例的难度是从简单到困难递升的，保证合你们的胃口。</p><p><strong><em>案例一(简单)：</em></strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">斐波那契数列:0,1,1,2,3，5,8,13,21,34,55,89,144,233......它遵循这样的规律:当前值为前两个值的和。那么第n个值为多少?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们很快就能根据上面的解释，分析出这个案例的状态转移方程：f(n) = f(n-1)+ f(n-2)。接下来我们用两种代码方式来完成它，让大家清澈的认识一下动态规划的魅力。</p><ul><li><p>递归</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public int fib(n){    if(n&lt;2)       return n;    else       return fib(n-1) + fib(n-2)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码简单易懂，然而这代码却极其低效。先不说这种递归的方式造成栈空间的极大浪费，就仅仅是该算法的时间复杂度已经是O(2^n)了。“指数级别时间复杂度”的算法和“不能用”没啥区别！</p><p>为什么是指数时间复杂度？上面的代码通过展示求解f(4)的过程如下：随着递归的深入，计算任务不断地翻倍！</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210723114724142.png" alt="image-20210723114724142"></p></li><li><p>动态规划</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Fib {    //用于缓存以往结果，以便复用（目标2）    private static List&lt;Integer&gt; list = new ArrayList();    public static int fib(int n){//按顺序从小打大算（目标3）        for (int i = 0; i &lt; n; i++) {            if (i&lt;2)                list.add(i);            else                //使用状态转移方程（目标1）               list.add(list.get(list.size()-1)+list.get(list.size()-2));        }        return list.get(list.size()-1);    }    public static void main(String[] args) {        System.out.println("用户输入");        System.out.println(fib(new Scanner(System.in).nextInt()));    }}//输出用户输入7输出8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用动态规划的方式，我们只需要进行一下圈起来的地方进行计算即可：<br><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210723164001775.png" alt="image-20210723164001775"></p><p>时间复杂度瞬间降为O(n)。</p></li></ul><p><strong><em>案例二（中等）：</em></strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">一个机器人位于一个m x n网格的左上角 (起始点在下图中标记为“Start”)。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角(在下图中标记为“Finish”)。问总共有多少条不同的路径?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210723165431232.png" alt="image-20210723165431232"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：m = 3, n = 7（上图）输出：28<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>先自己思考 1 min…..再看答案。</p><p>解这题，如前所述，我们需要完成三个子目标：</p><ol><li><p>建立状态转移方程。该题就难在这里，这一步搞不定基本上GG了。实际上，如上图所示，第i行第j列的格子的路径数，是等于它左边格子和上面格子的路径数之和：<br><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210723171110921.png" alt="image-20210723171110921"></p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210723164704521.png" alt="image-20210723164704521"></p></li><li><p>缓存并复用以往结果。与之前说的一维数列不同，这里的中间结果可以构成一个二维数列(如上图所示），所以需要用二维的数组或者列表来存储。</p></li><li><p>按顺序从小往大算。这次有两个维度，所以需两个循环，分别逐行和逐列让问题从小规模到大规模计算。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//m是行数，n是列数 public int uniquePaths(int m, int n) {        int[][] f = new int[m][n];        for (int i = 0; i &lt; m; ++i) {            f[i][0] = 1;//左边界        }        for (int j = 0; j &lt; n; ++j) {            f[0][j] = 1;//上边界        }        for (int i = 1; i &lt; m; ++i) {            for (int j = 1; j &lt; n; ++j) {                f[i][j] = f[i - 1][j] + f[i][j - 1];            }        }        return f[m - 1][n - 1];    }    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度：O(m n)。</p><p>空间复杂度：O(m n)，即为存储所有状态需要的空间。注意到 f(i, j) 仅与第 i 行和第 i-1行的状态有关，因此我们可以使用滚动数组代替代码中的二维数组，使空间复杂度降低为 O(n)。</p><p>此外，由于我们交换行列的值并不会对答案产生影响，因此我们总可以通过交换m和n使得m ≤n，这样空间复杂度降低至 O(min(m, n))。</p></li></ol><p><strong><em>案例三（困难）：</em></strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">给你一个字符串&nbsp;s&nbsp;和一个字符规律&nbsp;p，请你来实现一个支持 '.'&nbsp;和&nbsp;'*'&nbsp;的正则表达式匹配。'.' 匹配任意单个字符'*' 匹配零个或多个前面的那一个元素所谓匹配，是要涵盖&nbsp;整个&nbsp;字符串 s 的，而不是部分字符串。    示例 1：输入：s = "aa" p = "a"输出：false解释："a" 无法匹配 "aa" 整个字符串。    示例 2:输入：s = "aa" p = "a*"输出：true解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。    示例&nbsp;3：输入：s = "ab" p = ".*"输出：true解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。    示例 4：输入：s = "aab" p = "c*a*b"输出：true解释：因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。    示例 5：输入：s = "mississippi" p = "mis*is*p*."输出：false提示：0 &lt;= s.length&nbsp;&lt;= 200 &lt;= p.length&nbsp;&lt;= 30s&nbsp;可能为空，且只包含从&nbsp;a-z&nbsp;的小写字母。p&nbsp;可能为空，且只包含从&nbsp;a-z&nbsp;的小写字母，以及字符&nbsp;.&nbsp;和&nbsp;*。保证每次出现字符&nbsp;* 时，前面都匹配到有效的字符。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看到这个题目的时候，人已经晕了，先花3分钟看懂题目…好了，我们一起来分析答案吧。</p><p>老样子，我们需要完成三个目标：</p><ol><li><p>建立状态转移方程。这里的状态转移方程有些复杂，我折腾了一段时间才总结出来的，如果看不懂就跳过不用纠结，毕竟文章的重点不在此。</p><p>首先我们进行如下定义：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">f(i,j) : pattern的第0~i个字符与string的第0~j个字符的匹配结果。结果只取True(匹配成功)，或者False (匹配失败)。P.i: pattern的第i个字符。S.j : string的第j个字符。m(i,j):单个字符P.i;和S.j的匹配结果。结果只取True(匹配成功)，或者False (匹配失败)。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>那么参考下面的图片，可得下面的状态转移方程。具体地说有两种情况：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">(1)如果P.i为星号外的任意字符，用“x”表示。这种情况显而易见, f(i,j)是基于f(i-1,j-1)的结果(可能成功或者失败的)继续配对。    (2).如果P.i为星号“*”。如下图右边，分三种子情况。①箭头1描述了 P.i-1 匹配成功了0次的情况，所以继承前面匹配的结果f(i-2,j);②箭头2描述了 P.i-1 成功匹配了1次的情况，所以继承这1次的结果f(i-1,j);③箭头3表示 P.i-1 成功匹配超过1次，所以基于左边的结果继续匹配f(i,j - 1)&amp; m(i - 1,j)。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210723173420297.png" alt="image-20210723173420297"></p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210723173503538.png" alt="image-20210723173503538"></p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210723173536445.png" alt="image-20210723173536445"></p><p>​                                                        (2)pattern的第i个字符为”*”</p><ol start="2"><li>缓存并复用以往结果。如下图仍然用二维数组，存的是布尔型。</li><li>按顺序从小往大算，参考代码。</li></ol><p>代码实现如下，里面提到的哨兵是用于处理临界问题的，自己跑跑代码就懂了：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean isMatch(String s, String p) {       int m = s.length();       int n = p.length();          boolean[][] f = new boolean[m + 1][n + 1];       f[0][0] = true;       for (int i = 0; i &lt;= m; ++i) {           for (int j = 1; j &lt;= n; ++j) {               if (p.charAt(j - 1) == '*') {                   f[i][j] = f[i][j - 2];                   if (matches(s, p, i, j - 1)) {                       f[i][j] = f[i][j] || f[i - 1][j];                   }               } else {                   if (matches(s, p, i, j)) {                       f[i][j] = f[i - 1][j - 1];                   }               }           }       }       return f[m][n];   }      public boolean matches(String s, String p, int i, int j) {       if (i == 0) {           return false;       }       if (p.charAt(j - 1) == '.') {           return true;       }       return s.charAt(i - 1) == p.charAt(j - 1);   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度：O(m n)，其中m和n分别是字符串s和p的长度。我们需要计算出所有的状态，并且每个状态在进行转移时的时间复杂度为O(1)。<br>空间复杂度：O(m n)，即为存储所有状态使用的空间。</p></li></ol><h3 id="6、动态规划问题类别"><a href="#6、动态规划问题类别" class="headerlink" title="6、动态规划问题类别"></a>6、动态规划问题类别</h3><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210723112430841.png" alt="image-20210723112430841"></p><p>其中在DP类型部分，面试中最常考察的就是「线性DP」，而在优化方法部分，最常见的是「RMQ优化」，即使用线段树或其它数据结构查询区间最小值，来优化DP的转移过程，这个就暂时不解释了，难度过高。</p><h3 id="7、总结"><a href="#7、总结" class="headerlink" title="7、总结"></a>7、总结</h3><p>动态规划与其说是一个算法，不如说是一种方法论。该方法论主要致力于将合适的问题拆分成三个子目标——击破：</p><ol><li>建立状态转移方程</li><li>缓存并复用以往结果</li><li>按顺序从小往大算</li></ol><p>完成这三个目标，你将所向披靡。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Math.random()获得短信验证码功能需要的随机数</title>
      <link href="2021/071610614.html"/>
      <url>2021/071610614.html</url>
      
        <content type="html"><![CDATA[<h2 id="使用Math-random-获得短信验证码功能需要的随机数"><a href="#使用Math-random-获得短信验证码功能需要的随机数" class="headerlink" title="使用Math.random()获得短信验证码功能需要的随机数"></a>使用Math.random()获得短信验证码功能需要的随机数</h2><p>在项目中看到一个需求，要用到6位数字的随机数，虽然知道是用random()函数获得，不过获取六位数字的计算方式还是想不起来了，经过一系列演算后得到结果如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">(int)((Math.random()*9+1)*100000)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Math.random()的取值结果应该是0-1（事实上取不到 0 和１）之间的随机小数，像这样：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210716095254084.png" alt="image-20210716095254084"></p><p>乘以9之后就得到了0-9（大于0小于9）之间的随机小数：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210716095455351.png" alt="image-20210716095455351"></p><p>经过int类型转换之后，应该是 0-8 之间的随机整数，<strong>因为double转int向下取整</strong>，所以  “+1”之后就会得到1-9之间的小数，乘以10000来获取6位的整型数字。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210716102125454.png" alt="image-20210716102125454"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数 </tag>
            
            <tag> random </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java高级 如何理解Spring IoC中的控制反转、依赖倒置原则、依赖注入、控制反转容器？</title>
      <link href="2021/070754183.html"/>
      <url>2021/070754183.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java高级-如何理解Spring-IoC中的控制反转、依赖倒置原则、依赖注入、控制反转容器？"><a href="#Java高级-如何理解Spring-IoC中的控制反转、依赖倒置原则、依赖注入、控制反转容器？" class="headerlink" title="Java高级 如何理解Spring IoC中的控制反转、依赖倒置原则、依赖注入、控制反转容器？"></a>Java高级 如何理解Spring IoC中的控制反转、依赖倒置原则、依赖注入、控制反转容器？</h2><h3 id="1、IOC的优点"><a href="#1、IOC的优点" class="headerlink" title="1、IOC的优点"></a>1、IOC的优点</h3><p>DI和IOC其实是一个思想，它们的的好处是：如果依赖的类修改了，比如修改了构造函数，如果没有依赖注入，则需要修改对依赖对象进行调用的类，如果使用了依赖注入则不需要。</p><p>spring IOC的好处是，对象的构建如果依赖非常多的对象，且层次很深，外层在构造对象时很麻烦且不一定知道如何构建这么多层次的对象。 IOC 帮我们管理对象的创建，只需要在配置文件里指定如何构建，每一个对象的配置文件都在类编写的时候指定了，所以最外层对象不需要关心深层次对象如何创建的，前人都写好了。</p><h3 id="2、依赖倒置原则"><a href="#2、依赖倒置原则" class="headerlink" title="2、依赖倒置原则"></a>2、依赖倒置原则</h3><p>要了解<strong>控制反转( Inversion of Control )</strong>, 有必要先了解软件设计的一个重要思想：<strong>依赖倒置原则（Dependency Inversion Principle ）</strong>。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/v2-d53c75e91d959acbb0d95a835212ada5_hd.jpg" alt="img"></p><p><strong>什么是依赖倒置原则？</strong>假设我们设计一辆汽车：先设计轮子，然后根据轮子大小设计底盘，接着根据底盘设计车身，最后根据车身设计好整个汽车。这里就出现了一个“依赖”关系：汽车依赖车身，车身依赖底盘，底盘依赖轮子。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/v2-c68248bb5d9b4d64d22600571e996446_hd.jpg" alt="img"></p><p>这样的设计看起来没问题，但是可维护性却很低。假设设计完工之后，上司却突然说根据市场需求的变动，要我们把车子的轮子设计都改大一码。这下我们就蛋疼了：因为我们是根据轮子的尺寸设计的底盘，轮子的尺寸一改，底盘的设计就得修改；同样因为我们是根据底盘设计的车身，那么车身也得改，同理汽车设计也得改——整个设计几乎都得改！</p><p>我们现在换一种思路。我们先设计汽车的大概样子，然后根据汽车的样子来设计车身，根据车身来设计底盘，最后根据底盘来设计轮子。这时候，依赖关系就倒置过来了：轮子依赖底盘， 底盘依赖车身， 车身依赖汽车。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/v2-e64bf72c5c04412f626b21753aa9e1a1_hd.jpg" alt="img"></p><p>这时候，上司再说要改动轮子的设计，我们就只需要改动轮子的设计，而不需要动底盘，车身，汽车的设计了。</p><p>这就是依赖倒置原则——把原本的高层建筑依赖底层建筑“倒置”过来，变成底层建筑依赖高层建筑。高层建筑决定需要什么，底层去实现这样的需求，但是高层并不用管底层是怎么实现的。这样就不会出现前面的“牵一发动全身”的情况。</p><h3 id="3、什么是控制反转？"><a href="#3、什么是控制反转？" class="headerlink" title="3、什么是控制反转？"></a>3、什么是控制反转？</h3><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/v2-d53c75e91d959acbb0d95a835212ada5_hd.jpg" alt="img"></p><p><strong>控制反转（Inversion of Control）</strong> 就是依赖倒置原则的一种代码设计的思路。具体采用的方法就是所谓的<strong>依赖注入（Dependency Injection）</strong>。其实这些概念初次接触都会感到云里雾里的。说穿了，这几种概念的关系大概如下：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/v2-ee924f8693cff51785ad6637ac5b21c1_hd.jpg" alt="img"></p><p>为了理解这几个概念，我们还是用上面汽车的例子。只不过这次换成代码。我们先定义四个Class，车，车身，底盘，轮胎。然后初始化这辆车，最后跑这辆车。代码结构如下：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/v2-8ec294de7d0f9013788e3fb5c76069ef_hd.jpg" alt="img"></p><p>这样，就相当于上面第一个例子，上层建筑依赖下层建筑——每一个类的构造函数都直接调用了底层代码的构造函数。假设我们需要改动一下轮胎（Tire）类，把它的尺寸变成动态的，而不是一直都是30。我们需要这样改：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/v2-64e8b19eeb70d9cf87c27fe4c5c0fc81_hd.jpg" alt="img"></p><p>由于我们修改了轮胎的定义，为了让整个程序正常运行，我们需要做以下改动：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/v2-82e0c12a1b26f7979ed9241e169affda_hd.jpg" alt="img"></p><p>由此我们可以看到，仅仅是为了修改轮胎的构造函数，这种设计却需要<strong>修改整个上层所有类的构造函数</strong>！在软件工程中，<strong>这样的设计几乎是不可维护的</strong>——在实际工程项目中，有的类可能会是几千个类的底层，如果每次修改这个类，我们都要修改所有以它作为依赖的类，那软件的维护成本就太高了。</p><p>所以我们需要进行控制反转（IoC），及上层控制下层，而不是下层控制着上层。我们用依赖注入（Dependency Injection）这种方式来实现控制反转。<strong>所谓依赖注入，就是把底层类作为参数传入上层类，实现上层类对下层类的“控制</strong>”。这里我们用<strong>构造方法传递的依赖注入方式</strong>重新写车类的定义：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/v2-c920a0540ce0651003a5326f6ef9891d_hd.jpg" alt="img"></p><p>这里我们再把轮胎尺寸变成动态的，同样为了让整个系统顺利运行，我们需要做如下修改：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/v2-99ad2cd809fcb86dd791ff7f65fb1779_hd.jpg" alt="img"></p><p>看到没？这里<strong>我只需要修改轮胎类就行了，不用修改其他任何上层类。</strong>这显然是更容易维护的代码。不仅如此，在实际的工程中，这种设计模式还有利于<strong>不同组的协同合作和单元测试：</strong>比如开发这四个类的分别是四个不同的组，那么只要定义好了接口，四个不同的组可以同时进行开发而不相互受限制；而对于单元测试，如果我们要写Car类的单元测试，就只需要Mock一下Framework类传入Car就行了，而不用把Framework, Bottom, Tire全部new一遍再来构造Car。</p><p>这里我们是采用的<strong>构造函数传入</strong>的方式进行的依赖注入。其实还有另外两种方法：<strong>Setter传递</strong>和<strong>接口传递</strong>。这里就不多讲了，核心思路都是一样的，都是为了实现<strong>控制反转</strong>。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/v2-861683acac47577c81f2b7493dd05649_hd.jpg" alt="img"></p><h3 id="4、什么是控制反转容器（IoC-Container）"><a href="#4、什么是控制反转容器（IoC-Container）" class="headerlink" title="4、什么是控制反转容器（IoC Container）"></a>4、什么是控制反转容器（<strong>IoC Container</strong>）</h3><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/v2-d53c75e91d959acbb0d95a835212ada5_hd.jpg" alt="img"></p><p>看到这里你应该能理解什么控制反转和依赖注入了。那什么是**控制反转容器(IoC Container)**呢？其实上面的例子中，对车类进行初始化的那段代码发生的地方，就是控制反转容器。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/v2-c845802f9187953ed576e0555f76da42_hd.jpg" alt="img"></p><p>显然你也应该观察到了，因为采用了依赖注入，在初始化的过程中就不可避免的会写大量的new。这里IoC容器就解决了这个问题。<strong>这个容器可以自动对你的代码进行初始化，你只需要维护一个Configuration（可以是xml可以是一段代码），而不用每次初始化一辆车都要亲手去写那一大段初始化的代码</strong>。这是引入IoC Container的第一个好处。</p><p>IoC Container的第二个好处是：<strong>我们在创建实例的时候不需要了解其中的细节。</strong>在上面的例子中，我们自己手动创建一个车instance时候，是从底层往上层new的：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/v2-555b2be7d76e78511a6d6fed3304927f_hd.jpg" alt="img"></p><p>这个过程中，我们需要了解整个Car/Framework/Bottom/Tire类构造函数是怎么定义的，才能一步一步new/注入。</p><p>而IoC Container在进行这个工作的时候是反过来的，它先从最上层开始往下找依赖关系，到达最底层之后再往上一步一步new（有点像深度优先遍历）：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/v2-24a96669241e81439c636e83976ba152_hd.jpg" alt="img"></p><p>这里IoC Container可以直接隐藏具体的创建实例的细节，在我们来看它就像一个工厂：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/v2-5ca61395f37cef73c7bbe7808f9ea219_720w.jpg" alt="img"></p><p>我们就像是工厂的客户。我们只需要向工厂请求一个Car实例，然后它就给我们按照Config创建了一个Car实例。我们完全不用管这个Car实例是怎么一步一步被创建出来。</p><p>实际项目中，有的Service Class可能是十年前写的，有几百个类作为它的底层。假设我们新写的一个API需要实例化这个Service，我们总不可能回头去搞清楚这几百个类的构造函数吧？IoC Container的这个特性就很完美的解决了这类问题——<strong>因为这个架构要求你在写class的时候需要写相应的Config文件，所以你要初始化很久以前的Service类的时候，前人都已经写好了Config文件，你直接在需要用的地方注入这个Service就可以了</strong>。这大大增加了项目的可维护性且降低了开发难度。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/v2-d53c75e91d959acbb0d95a835212ada5_720w.jpg" alt="img"></p><p>这里只是很粗略的讲了一下我自己对IoC和DI的理解。主要的目的是在于<strong>最大限度避免晦涩难懂的专业词汇，用尽量简洁，通俗，直观的例子</strong>来解释这些概念。如果让大家能有一个类似“哦！原来就是这么个玩意嘛！”的印象，我觉得就OK了。想要深入了解的话，可以上网查阅一些更权威的资料。这里推荐一下 <a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Dependency_injection">Dependency injection </a>和 <a href="https://link.zhihu.com/?target=https://martinfowler.com/articles/injection.html">Inversion of Control Containers and the Dependency Injection pattern</a> 这两篇文章，讲的很好很详细。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring IoC </tag>
            
            <tag> 底层原理 </tag>
            
            <tag> DI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 报错 Updates were rejected because the remote contains work that you do</title>
      <link href="2021/060421155.html"/>
      <url>2021/060421155.html</url>
      
        <content type="html"><![CDATA[<h2 id="Git-报错-Updates-were-rejected-because-the-remote-contains-work-that-you-do"><a href="#Git-报错-Updates-were-rejected-because-the-remote-contains-work-that-you-do" class="headerlink" title="Git 报错 Updates were rejected because the remote contains work that you do"></a>Git 报错 Updates were rejected because the remote contains work that you do</h2><p>这个报错实在是让我受不了了，每次不管是‘命令行’ 还是 idea 提交都会出现这样让人心态爆炸的问题。然而每次出现又重复的查找解决办法，这次实在受不了了，便有了这篇文章，希望它也能帮助到心态爆炸的你。</p><h3 id="1、命令行出现这种情况"><a href="#1、命令行出现这种情况" class="headerlink" title="1、命令行出现这种情况"></a>1、命令行出现这种情况</h3><p>命令行执行会出现这样的问题是因为错误的提交过程：</p><pre class="line-numbers language-apl" data-language="apl"><code class="language-apl">git init //初始化仓库git add .(文件name)                  //添加文件到本地暂存git commit -m “first commit”        //添加文件描述信息git remote add origin    远程仓库地址 //链接远程仓库git push -u origin master          //把本地仓库的文件推送到远程仓master                                      分支<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就出现了标题提示的错误信息，如下图：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210604105941769.png" alt="image-20210604105941769"></p><p>经过多次出现同样的问题，我已经对这个问题的原因了如指掌了，这是因为在本地新建库后，与远程仓库的内容不一致导致的（远程仓库有一些内容本地没有）。问题了如指掌，但是解决方法每次都记错，所以还是记录一下吧。</p><p>正确的提交过程如下：</p><pre class="line-numbers language-apl" data-language="apl"><code class="language-apl">git init                           //初始化仓库git add .(文件name)                //添加文件到本地 git commit -m “first commit”      //添加文件描述信息git remote add origin  远程仓库地址 //链接远程仓库 git pull origin master           // 把本地仓库的变化连接到远程仓库master                                     分支git push -u origin master        //把本地仓库的文件推送到远程仓库master                                    分支<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在执行上面第五步的时候可能会出现新的错误，也是常见的错误了，错误信息如下：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210604110514047.png" alt="image-20210604110514047"></p><p>不要慌，这是因为文件版本没有及时更新，两个分支是两个不同的版本，具有不同的提交历史，决绝方式就是在原本的命令之后加上一句命令即可：</p><pre class="line-numbers language-apl" data-language="apl"><code class="language-apl">git pull origin master --allow-unrelated-histories<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后有的情况下，输入上面的命令就能解决问题，有的情况下，他又会报新的错误，如下：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210604110855717.png" alt="image-20210604110855717"></p><p>网上查了解决办法是真的麻烦，但是原因知道了，就是有文件冲突，没有更新，那就好办了，重新输入以下命令问题解决：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210604111243288.png" alt="image-20210604111243288"></p><h3 id="2、idea出现同样的报错，解决方式同上"><a href="#2、idea出现同样的报错，解决方式同上" class="headerlink" title="2、idea出现同样的报错，解决方式同上"></a>2、idea出现同样的报错，解决方式同上</h3><p>输入命令的地方在 idea 的下方，有一个 terminal ，点击之后，即可输入上面的命令。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitee </tag>
            
            <tag> idea </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git分布式版本控制工具</title>
      <link href="2021/060263789.html"/>
      <url>2021/060263789.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Git分布式版本控制工具"><a href="#Git分布式版本控制工具" class="headerlink" title="Git分布式版本控制工具"></a>Git分布式版本控制工具</h2><h2 id="1-Git概述"><a href="#1-Git概述" class="headerlink" title="1. Git概述"></a>1. Git概述</h2><h3 id="1-1-Git简介"><a href="#1-1-Git简介" class="headerlink" title="1.1 Git简介"></a>1.1 Git简介</h3><p>Git是分布式版本控制系统（Distributed Version Control System，简称 DVCS） ，分为两种类型的仓库：<strong>本地仓库和远程仓库</strong></p><p>本地仓库：是在开发人员自己电脑上的Git仓库        </p><p>远程仓库：是在远程服务器上的Git仓库</p><ol><li>Clone：克隆，就是将远程仓库复制到本地</li><li>Push：推送，就是将本地仓库代码上传到远程仓库</li><li>Pull：拉取，就是将远程仓库代码下载到本地仓库</li></ol><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602132455811.png" alt="image-20210602132455811"></p><h3 id="1-2-Git工作流程"><a href="#1-2-Git工作流程" class="headerlink" title="1.2 Git工作流程"></a>1.2 Git工作流程</h3><p>工作流程如下：</p><p>1．从远程仓库中克隆代码到本地仓库</p><p>2．从本地仓库中checkout代码然后进行代码修改</p><p>3．在提交前先将代码提交到暂存区</p><p>4．提交到本地仓库。本地仓库中保存修改的各个历史版本</p><p>5．修改完成后，需要和团队成员共享代码时，将代码push到远程仓库</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602132538184.png" alt="image-20210602132538184"></p><h3 id="1-3-Git下载与安装"><a href="#1-3-Git下载与安装" class="headerlink" title="1.3 Git下载与安装"></a>1.3 Git下载与安装</h3><p>下载地址： <a href="https://git-scm.com/download">https://git-scm.com/download</a>，本地文件已经让学习委员上传到了钉钉云盘，可自取。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602132724557.png" alt="image-20210602132724557"></p><p>下载完成后可以得到如下安装文件：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602132745558.png" alt="image-20210602132745558"></p><h2 id="2-Git代码托管服务"><a href="#2-Git代码托管服务" class="headerlink" title="2. Git代码托管服务"></a>2. Git代码托管服务</h2><h3 id="2-1-常用的Git代码托管服务"><a href="#2-1-常用的Git代码托管服务" class="headerlink" title="2.1 常用的Git代码托管服务"></a>2.1 常用的Git代码托管服务</h3><p>前面我们已经知道了Git中存在两种类型的仓库，即本地仓库和远程仓库。那么我们如何搭建Git远程仓库呢？我们可以借助互联网上提供的一些代码托管服务来实现，其中比较常用的有GitHub、码云（gitee）、GitLab等。</p><p>gitHub（ 地址：<a href="https://github.com/">https://github.com/</a> ）是一个面向开源及私有软件项目的托管平台，因为只支持Git 作为唯一的版本库格式进行托管，故名gitHub</p><p>码云（地址： <a href="https://gitee.com/">https://gitee.com/</a> ）是国内的一个代码托管平台，由于服务器在国内，所以相比于GitHub，码云速度会更快</p><p>GitLab （地址： <a href="https://about.gitlab.com/">https://about.gitlab.com/</a> ）是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务</p><h3 id="2-2-在码云注册账号"><a href="#2-2-在码云注册账号" class="headerlink" title="2.2 在码云注册账号"></a>2.2 在码云注册账号</h3><p>要想使用码云的相关服务，需要注册账号（地址： <a href="https://gitee.com/signup">https://gitee.com/signup</a> ）</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602132901965.png" alt="image-20210602132901965"></p><h3 id="2-3-登录码云并创建Git远程仓库"><a href="#2-3-登录码云并创建Git远程仓库" class="headerlink" title="2.3 登录码云并创建Git远程仓库"></a>2.3 登录码云并创建Git远程仓库</h3><p>注册完成后就可以使用刚刚注册的邮箱进行登录（地址： <a href="https://gitee.com/login">https://gitee.com/login</a> ）</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602140414109.png" alt="image-20210602140414109"></p><p>登录成功后就可以创建Git远程仓库</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602142928493.png" alt="image-20210602142928493"></p><p>创建完成后可以查看仓库信息</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602142942075.png" alt="image-20210602142942075"></p><p>每个Git远程仓库都会对应一个网络地址，可以点击克隆/下载按钮弹出窗口并点击复制按钮获得这个网络地址</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602145357459.png" alt="image-20210602145357459"></p><p>我们当前创建的Git远程仓库对应的地址为：<a href="https://gitee.com/ChuanZhiBoKe/myGitRepo.git">https://gitee.com/ChuanZhiBoKe/myGitRepo.git</a></p><h3 id="2-4-邀请其他用户成为仓库成员"><a href="#2-4-邀请其他用户成为仓库成员" class="headerlink" title="2.4 邀请其他用户成为仓库成员"></a>2.4 邀请其他用户成为仓库成员</h3><p>前面已经在码云上创建了自己的远程仓库，目前仓库成员只有自己一个人（身份为管理员）。在企业实际开发中，一个项目往往是由多个人共同开发完成的，为了使多个参与者都有权限操作远程仓库，就需要邀请其他项目参与者成为当前仓库的成员。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602145420696.png" alt="image-20210602145420696"></p><h2 id="3-Git常用命令"><a href="#3-Git常用命令" class="headerlink" title="3. Git常用命令"></a>3. Git常用命令</h2><h3 id="3-1-环境配置"><a href="#3-1-环境配置" class="headerlink" title="3.1 环境配置"></a>3.1 环境配置</h3><p>当安装Git后首先要做的事情是设置用户名称和email地址。这是非常重要的，因为每次Git提交都会使用该用户信息</p><p>**设置用户信息 **</p><p>   git config –global user.name “itcast”</p><p>   git config –global user.email “<a href="mailto:hello@itcast.cn">hello@itcast.cn</a>”</p><p><strong>查看配置信息</strong></p><p>   git config –list</p><p>   git config user.name</p><p>通过上面的命令设置的信息会保存在~/.gitconfig文件中</p><h3 id="3-2-获取Git仓库"><a href="#3-2-获取Git仓库" class="headerlink" title="3.2 获取Git仓库"></a>3.2 获取Git仓库</h3><p>要使用Git对我们的代码进行版本控制，首先需要获得Git仓库</p><p>获取Git仓库通常有两种方式：</p><ol><li>在本地初始化一个Git仓库</li><li>从远程仓库克隆</li></ol><h4 id="3-2-1在本地初始化一个Git仓库"><a href="#3-2-1在本地初始化一个Git仓库" class="headerlink" title="3.2.1在本地初始化一个Git仓库"></a>3.2.1在本地初始化一个Git仓库</h4><p>执行步骤如下：</p><ol><li><p>在电脑的任意位置创建一个空目录（例如repo1）作为我们的本地Git仓库</p></li><li><p>进入这个目录中，点击右键打开Git bash窗口</p></li><li><p>执行命令git init</p></li></ol><p>如果在当前目录中看到.git文件夹（此文件夹为隐藏文件夹）则说明Git仓库创建成功</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602145729100.png" alt="image-20210602145729100"></p><h4 id="3-2-2从远程仓库克隆"><a href="#3-2-2从远程仓库克隆" class="headerlink" title="3.2.2从远程仓库克隆"></a>3.2.2从远程仓库克隆</h4><p>可以通过Git提供的命令从远程仓库进行克隆，将远程仓库克隆到本地</p><p>命令形式为：git clone 远程Git仓库地址 </p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602145756203.png" alt="image-20210602145756203"></p><h3 id="3-3工作目录、暂存区以及版本库概念"><a href="#3-3工作目录、暂存区以及版本库概念" class="headerlink" title="3.3工作目录、暂存区以及版本库概念"></a>3.3工作目录、暂存区以及版本库概念</h3><p>为了更好的学习Git，我们需要了解Git相关的一些概念，这些概念在后面的学习中会经常提到。</p><p>版本库：前面看到的.git隐藏文件夹就是版本库，版本库中存储了很多配置信息、日志信息和文件版本信息等。</p><p>工作目录（工作区）：包含.git文件夹的目录就是工作目录，主要用于存放开发的代码。</p><p>暂存区：.git文件夹中有很多文件，其中有一个index文件就是暂存区，也可以叫做stage。暂存区是一个临时保存修改文件的地方。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602145840311.png" alt="image-20210602145840311"></p><h3 id="3-4-Git工作目录下文件的两种状态"><a href="#3-4-Git工作目录下文件的两种状态" class="headerlink" title="3.4 Git工作目录下文件的两种状态"></a>3.4 Git工作目录下文件的两种状态</h3><p>Git工作目录下的文件存在两种状态：</p><ul><li>untracked 未跟踪（未被纳入版本控制）</li><li>tracked 已跟踪（被纳入版本控制）</li></ul><p>​        Unmodified 未修改状态</p><p>​        Modified 已修改状态</p><p>​        Staged 已暂存状态</p><p>这些文件的状态会随着我们执行Git的命令发生变化</p><h3 id="3-5-本地仓库操作"><a href="#3-5-本地仓库操作" class="headerlink" title="3.5 本地仓库操作"></a>3.5 本地仓库操作</h3><p>git status 查看文件状态</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602150156028.png" alt="image-20210602150156028"></p><p>也可以使用git status –s 使输出信息更加简洁</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602150222710.png" alt="image-20210602150222710"></p><p>git add 将未跟踪的文件加入暂存区</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602150244991.png" alt="image-20210602150244991"></p><p>将新创建的文件加入暂存区后查看文件状态</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602150308646.png" alt="image-20210602150308646"></p><p>git reset 将暂存区的文件取消暂存</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602151348505.png" alt="image-20210602151348505"></p><p>将文件取消暂存后查看文件状态</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602151436267.png" alt="image-20210602151436267"></p><p>git commit 将暂存区的文件修改提交到本地仓库</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602151454335.png" alt="image-20210602151454335"></p><p>git rm 删除文件</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602151509692.png" alt="image-20210602151509692"></p><p>删除文件后查看文件状态</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602151526671.png" alt="image-20210602151526671"></p><p>上面删除的只是工作区的文件，需要提交到本地仓库</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602151540181.png" alt="image-20210602151540181"></p><p>将文件添加至忽略列表：</p><p>一般我们总会有些文件无需纳入Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以在工作目录中创建一个名为 .gitignore 的文件（文件名称固定），列出要忽略的文件模式。下面是一个示例：</p><pre class="line-numbers language-apl" data-language="apl"><code class="language-apl"># no .a files*.a# but do track lib.a, even though you're ignoring .a files above!lib.a# only ignore the TODO file in the current directory, not subdir/TODO/TODO# ignore all files in the build/ directorybuild/# ignore doc/notes.txt, but not doc/server/arch.txtdoc/*.txt# ignore all .pdf files in the doc/ directorydoc/**/*.pdf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>git log 查看日志记录</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602151629429.png" alt="image-20210602151629429"></p><h3 id="3-6-远程仓库操作"><a href="#3-6-远程仓库操作" class="headerlink" title="3.6 远程仓库操作"></a>3.6 远程仓库操作</h3><p>前面执行的命令操作都是针对的本地仓库，下面我们会学习关于远程仓库的一些操作，具体包括：</p><h4 id="3-6-1查看远程仓库"><a href="#3-6-1查看远程仓库" class="headerlink" title="3.6.1查看远程仓库"></a>3.6.1查看远程仓库</h4><p>如果想查看已经配置的远程仓库服务器，可以运行 git remote 命令。 它会列出指定的每一个远程服务器的简写。 如果已经克隆了远程仓库，那么至少应该能看到 origin ，这是 Git 克隆的仓库服务器的默认名字</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602151802034.png" alt="image-20210602151802034"></p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602151827194.png" alt="image-20210602151827194"></p><h4 id="3-6-2-添加远程仓库"><a href="#3-6-2-添加远程仓库" class="headerlink" title="3.6.2 添加远程仓库"></a>3.6.2 添加远程仓库</h4><p>运行 git remote add <shortname> <url> 添加一个新的远程 Git 仓库，同时指定一个可以引用的简写</url></shortname></p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602151900853.png" alt="image-20210602151900853"></p><h4 id="3-6-3-从远程仓库克隆"><a href="#3-6-3-从远程仓库克隆" class="headerlink" title="3.6.3 从远程仓库克隆"></a>3.6.3 从远程仓库克隆</h4><p>如果你想获得一份已经存在了的 Git 仓库的拷贝，这时就要用到 git clone 命令。 Git 克隆的是该 Git 仓库服务器上的几乎所有数据（包括日志信息、历史记录等），而不仅仅是复制工作所需要的文件。 当你执行 git clone 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。</p><p>克隆仓库的命令格式是 git clone [url] </p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602151928993.png" alt="image-20210602151928993"></p><h4 id="3-6-4-移除无效的远程仓库"><a href="#3-6-4-移除无效的远程仓库" class="headerlink" title="3.6.4 移除无效的远程仓库"></a>3.6.4 移除无效的远程仓库</h4><p>如果因为一些原因想要移除一个远程仓库 ，可以使用 git remote rm</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602151953344.png" alt="image-20210602151953344"></p><p>注意：此命令只是从本地移除远程仓库的记录，并不会真正影响到远程仓库</p><h4 id="3-6-5-从远程仓库中抓取与拉取"><a href="#3-6-5-从远程仓库中抓取与拉取" class="headerlink" title="3.6.5 从远程仓库中抓取与拉取"></a>3.6.5 从远程仓库中抓取与拉取</h4><p>git fetch 是从远程仓库获取最新版本到本地仓库，不会自动merge</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602152012221.png" alt="image-20210602152012221"></p><p>git pull 是从远程仓库获取最新版本并merge到本地仓库</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602152027971.png" alt="image-20210602152027971"></p><p>注意：如果当前本地仓库不是从远程仓库克隆，而是本地创建的仓库，并且仓库中存在文件，此时再从远程仓库拉取文件的时候会报错（fatal: refusing to merge unrelated histories ），解决此问题可以在git pull命令后加入参数–allow-unrelated-histories</p><h4 id="3-6-6-推送到远程仓库"><a href="#3-6-6-推送到远程仓库" class="headerlink" title="3.6.6 推送到远程仓库"></a>3.6.6 推送到远程仓库</h4><p>当你想分享你的代码时，可以将其推送到远程仓库。 命令形式：git push [remote-name][branch-name]</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602152250006.png" alt="image-20210602152250006"></p><h3 id="3-7-Git分支"><a href="#3-7-Git分支" class="headerlink" title="3.7 Git分支"></a>3.7 Git分支</h3><p>几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。Git 的master分支并不是一个特殊分支。 它跟其它分支没有区别。 之所以几乎每一个仓库都有 master 分支，是因为git init 命令默认创建它，并且大多数人都懒得去改动它。</p><p>在本章节我们会学习到关于分支的相关命令，具体如下：</p><h4 id="3-7-1-查看分支"><a href="#3-7-1-查看分支" class="headerlink" title="3.7.1 查看分支"></a>3.7.1 查看分支</h4><p># 列出所有本地分支</p><p>$ git branch</p><p># 列出所有远程分支</p><p>$ git branch -r</p><p># 列出所有本地分支和远程分支</p><p>$ git branch -a</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602152319472.png" alt="image-20210602152319472"></p><h4 id="3-7-2-创建分支"><a href="#3-7-2-创建分支" class="headerlink" title="3.7.2 创建分支"></a>3.7.2 创建分支</h4><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602152334081.png" alt="image-20210602152334081"></p><h4 id="3-7-3-切换分支"><a href="#3-7-3-切换分支" class="headerlink" title="3.7.3 切换分支"></a>3.7.3 切换分支</h4><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602152346874.png" alt="image-20210602152346874"></p><h4 id="3-7-4-推送至远程仓库分支"><a href="#3-7-4-推送至远程仓库分支" class="headerlink" title="3.7.4 推送至远程仓库分支"></a>3.7.4 推送至远程仓库分支</h4><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602152405121.png" alt="image-20210602152405121"></p><h4 id="3-7-5-合并分支"><a href="#3-7-5-合并分支" class="headerlink" title="3.7.5 合并分支"></a>3.7.5 合并分支</h4><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602152454035.png" alt="image-20210602152454035"></p><p>有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没办法合并它们，同时会提示文件冲突。此时需要我们打开冲突的文件并修复冲突内容，最后执行git add命令来标识冲突已解决</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602152507616.png" alt="image-20210602152507616"></p><h4 id="3-7-5-删除分支"><a href="#3-7-5-删除分支" class="headerlink" title="3.7.5 删除分支"></a>3.7.5 删除分支</h4><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602152518749.png" alt="image-20210602152518749"></p><p>如果要删除的分支中进行了一些开发动作，此时执行上面的删除命令并不会删除分支，如果坚持要删除此分支，可以将命令中的-d参数改为-D</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602152530318.png" alt="image-20210602152530318"></p><p>注：如果要删除远程仓库中的分支，可以使用命令git push<br>origin –d branchName</p><h2 id="4-在IDEA中使用Git"><a href="#4-在IDEA中使用Git" class="headerlink" title="4. 在IDEA中使用Git"></a>4. 在IDEA中使用Git</h2><h3 id="4-1-在IDEA中配置Git"><a href="#4-1-在IDEA中配置Git" class="headerlink" title="4.1 在IDEA中配置Git"></a>4.1 在IDEA中配置Git</h3><p>安装好IntelliJ IDEA后，如果Git安装在默认路径下，那么idea会自动找到git的位置，如果更改了Git的安装位置则需要手动配置下Git的路径。</p><p>选择File→Settings打开设置窗口，找到Version Control下的git选项：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602152601504.png" alt="image-20210602152601504"></p><p>选择git的安装目录后可以点击“Test”按钮测试是否正确配置</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602152617270.png" alt="image-20210602152617270"></p><h3 id="4-2-在IDEA中使用Git"><a href="#4-2-在IDEA中使用Git" class="headerlink" title="4.2 在IDEA中使用Git"></a>4.2 在IDEA中使用Git</h3><h4 id="4-2-1在IDEA中创建工程并将工程添加至Git"><a href="#4-2-1在IDEA中创建工程并将工程添加至Git" class="headerlink" title="4.2.1在IDEA中创建工程并将工程添加至Git"></a>4.2.1在IDEA中创建工程并将工程添加至Git</h4><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602152750805.png" alt="image-20210602152750805"></p><p>将项目添加至Git管理后，可以从IDEA的工具栏上看到Git操作的按钮</p><h4 id="4-2-2-将文件添加到暂存区"><a href="#4-2-2-将文件添加到暂存区" class="headerlink" title="4.2.2 将文件添加到暂存区"></a>4.2.2 将文件添加到暂存区</h4><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602152815724.png" alt="image-20210602152815724"></p><h4 id="4-2-3-提交文件"><a href="#4-2-3-提交文件" class="headerlink" title="4.2.3 提交文件"></a>4.2.3 提交文件</h4><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602152831082.png" alt="image-20210602152831082"></p><h4 id="4-2-4-将代码推送到远程仓库"><a href="#4-2-4-将代码推送到远程仓库" class="headerlink" title="4.2.4 将代码推送到远程仓库"></a>4.2.4 将代码推送到远程仓库</h4><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602152842683.png" alt="image-20210602152842683"></p><h4 id="4-2-5-从远程仓库克隆工程到本地"><a href="#4-2-5-从远程仓库克隆工程到本地" class="headerlink" title="4.2.5 从远程仓库克隆工程到本地"></a>4.2.5 从远程仓库克隆工程到本地</h4><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602152858283.png" alt="image-20210602152858283"></p><h4 id="4-2-6-从远程拉取代码"><a href="#4-2-6-从远程拉取代码" class="headerlink" title="4.2.6 从远程拉取代码"></a>4.2.6 从远程拉取代码</h4><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602152908671.png" alt="image-20210602152908671"></p><h4 id="4-2-7-版本对比"><a href="#4-2-7-版本对比" class="headerlink" title="4.2.7 版本对比"></a>4.2.7 版本对比</h4><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602152923441.png" alt="image-20210602152923441"></p><h4 id="4-2-8-创建分支"><a href="#4-2-8-创建分支" class="headerlink" title="4.2.8 创建分支"></a>4.2.8 创建分支</h4><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602152935109.png" alt="image-20210602152935109"></p><h4 id="4-2-9-切换分支"><a href="#4-2-9-切换分支" class="headerlink" title="4.2.9 切换分支"></a>4.2.9 切换分支</h4><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602152945261.png" alt="image-20210602152945261"></p><h4 id="4-2-10-分支合并"><a href="#4-2-10-分支合并" class="headerlink" title="4.2.10 分支合并"></a>4.2.10 分支合并</h4><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210602153003095.png" alt="image-20210602153003095"></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitee </tag>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java进阶 MySQL三大范式正确理解</title>
      <link href="2021/050732636.html"/>
      <url>2021/050732636.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Java进阶-MySQL三范式正确理解"><a href="#Java进阶-MySQL三范式正确理解" class="headerlink" title="Java进阶 MySQL三范式正确理解"></a>Java进阶 MySQL三范式正确理解</h2><h4 id="1、什么是三范式？"><a href="#1、什么是三范式？" class="headerlink" title="1、什么是三范式？"></a>1、什么是三范式？</h4><p>首先我们要知道什么是三范式</p><p>为了建立冗余较小、结构合理的数据库，设计数据库时必须遵循一定的规则。在关系型数据库中这种规则就称为范式。范式是符合某一种设计要求的总结。要想设计一个结构合理的关系型数据库，必须满足一定的范式。</p><p>在实际开发中最为常见的设计范式有三个：</p><h4 id="2、第一范式-确保每列保持原子性"><a href="#2、第一范式-确保每列保持原子性" class="headerlink" title="2、第一范式(确保每列保持原子性)"></a>2、第一范式(确保每列保持原子性)</h4><p>第一范式是最基本的范式。如果数据库表中的**<em>所有字段值都是不可分解的原子值**</em>，就说明该数据库表满足了第一范式。<strong>1NF是所有关系型数据库的最基本要求</strong>。</p><p>第一范式的合理遵循需要根据系统的**<em>实际需求**</em>来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示。</p><p><strong>用户信息表：</strong></p><table><thead><tr><th>编号</th><th>姓名</th><th>性别</th><th>年龄</th><th>联系电话</th><th>省份</th><th>城市</th><th>详细地址</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>男</td><td>11</td><td>130x</td><td>四川</td><td>成都</td><td>青羊区</td></tr><tr><td>2</td><td>李四</td><td>男</td><td>22</td><td>140x</td><td>福建</td><td>福州</td><td>石狮市</td></tr><tr><td>3</td><td>王五</td><td>女</td><td>33</td><td>150x</td><td>江苏</td><td>扬州</td><td>生态科技新城</td></tr></tbody></table><p>上表所示的用户信息遵循了第一范式的要求，这样在对用户使用城市进行分类的时候就非常方便，也提高了数据库的性能。</p><h4 id="3、第二范式-确保表中的每列都和主键相关"><a href="#3、第二范式-确保表中的每列都和主键相关" class="headerlink" title="3、第二范式(确保表中的每列都和主键相关)"></a>3、第二范式(确保表中的每列都和主键相关)</h4><p>第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。**<em>也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中**</em>。(2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖)</p><p><strong>什么是“码”？</strong></p><p>设 K 为某表中的一个属性或属性组，若除 K 之外的所有属性都完全函数依赖于 K（这个“完全”不要漏了），那么我们称 K 为候选码，简称为码。在实际中我们通常可以理解为：假如当 K 确定的情况下，该表除 K 之外的所有属性的值也就随之确定，那么 K 就是码。一张表中可以有超过一个码。（实际应用中为了方便，通常选择其中的一个码作为主码） 例如：对于表3，（学号、课名）这个属性组就是码。该表中有且仅有这一个码。（假设所有课没有重名的情况）</p><p>现在要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键，如下表所示。</p><p> <strong>订单信息表：</strong></p><table><thead><tr><th>订单编号</th><th>商品编号</th><th>商品名称</th><th>数量</th><th>单位</th><th>价格</th><th>客户</th><th>所属单位</th><th>联系方式</th></tr></thead><tbody><tr><td>001</td><td>1</td><td>机票</td><td>10</td><td>张</td><td>1000</td><td>张三</td><td>百度</td><td>130x</td></tr><tr><td>002</td><td>2</td><td>动车票</td><td>20</td><td>张</td><td>500</td><td>李四</td><td>华为</td><td>140x</td></tr><tr><td>003</td><td>3</td><td>客车票</td><td>30</td><td>张</td><td>200</td><td>王五</td><td>腾讯</td><td>150x</td></tr></tbody></table><p>这样就产生一个问题：这个表中是以订单编号和商品编号作为联合主键。这样在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关。所以在这里违反了第二范式的设计原则。</p><p>而如果把这个订单信息表进行拆分，把商品信息分离到另一个表中，把订单项目表也分离到另一个表中，就非常完美了。如下所示。</p><p><strong>订单所属表：</strong></p><table><thead><tr><th>订单编号</th><th>客户</th><th>所属单位</th><th>联系方式</th></tr></thead><tbody><tr><td>001</td><td>张三</td><td>百度</td><td>130x</td></tr><tr><td>002</td><td>李四</td><td>华为</td><td>140x</td></tr><tr><td>003</td><td>王五</td><td>腾讯</td><td>150x</td></tr></tbody></table><p><strong>商品数量表：</strong></p><table><thead><tr><th>订单编号</th><th>商品编号</th><th>数量</th></tr></thead><tbody><tr><td>001</td><td>1</td><td>10</td></tr><tr><td>002</td><td>2</td><td>20</td></tr><tr><td>003</td><td>3</td><td>30</td></tr></tbody></table><p><strong>商品信息表：</strong></p><table><thead><tr><th>商品编号</th><th>商品名称</th><th>单位</th><th>商品价格</th></tr></thead><tbody><tr><td>1</td><td>机票</td><td>张</td><td>1000</td></tr><tr><td>2</td><td>动车票</td><td>张</td><td>500</td></tr><tr><td>3</td><td>客车票</td><td>张</td><td>200</td></tr></tbody></table><p>这样设计，在很大程度上减小了数据库的冗余。如果要获取订单的商品信息，使用商品编号到商品信息表中查询即可。</p><h4 id="4、第三范式-确保每列都和主键列直接相关-而不是间接相关"><a href="#4、第三范式-确保每列都和主键列直接相关-而不是间接相关" class="headerlink" title="4、第三范式(确保每列都和主键列直接相关,而不是间接相关)"></a>4、第三范式(确保每列都和主键列直接相关,而不是间接相关)</h4><p>第三范式需要确保数据表中的**<em>每一列数据都和主键直接相关，而不能间接相关**</em>。3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖。也就是说， 如果存在非主属性对于码的传递函数依赖，则不符合3NF的要求。</p><p>比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。如下面这两个表所示的设计就是一个满足第三范式的数据库表。</p><p><strong>订单信息表：</strong></p><table><thead><tr><th>订单编号</th><th>订单项目</th><th>负责人</th><th>业务员</th><th>订单数量</th><th>客户编号</th></tr></thead><tbody><tr><td>001</td><td>机票</td><td>张三</td><td>赵六</td><td>10</td><td>1</td></tr><tr><td>002</td><td>动车票</td><td>李四</td><td>田七</td><td>20</td><td>2</td></tr><tr><td>003</td><td>客车票</td><td>王五</td><td>牛八</td><td>30</td><td>1</td></tr></tbody></table><p><strong>客户信息表：</strong></p><table><thead><tr><th>客户编号</th><th>客户名称</th><th>所属公司</th><th>联系方式</th></tr></thead><tbody><tr><td>1</td><td>刘某</td><td>百度</td><td>130X</td></tr><tr><td>2</td><td>赵某</td><td>华为</td><td>140X</td></tr></tbody></table><p>这样在查询订单信息的时候，就可以使用客户编号来引用客户信息表中的记录，也不必在订单信息表中多次输入客户信息的内容，减小了数据冗余。</p><h4 id="提前预热：五大约束"><a href="#提前预热：五大约束" class="headerlink" title="提前预热：五大约束"></a>提前预热：五大约束</h4><ol><li>primary KEY: 设置主键约束；</li><li>UNIQUE：设置唯一性约束，不能有重复值；</li><li>DEFAULT:  默认值约束，height DOUBLE(3,2)DEFAULT 1.2 height不输入是默认为1.2；</li><li>NOT NULL：设置非空约束，该字段不能为空；</li><li>FOREIGN key : 设置外键约束。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java进阶 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
            <tag> 三大范式 </tag>
            
            <tag> 第一范式 </tag>
            
            <tag> 第二范式 </tag>
            
            <tag> 第三范式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java进阶 主键和外键的使用区别</title>
      <link href="2021/042730242.html"/>
      <url>2021/042730242.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Java进阶-主键和外键的使用区别"><a href="#Java进阶-主键和外键的使用区别" class="headerlink" title="Java进阶 主键和外键的使用区别"></a>Java进阶 主键和外键的使用区别</h2><h4 id="一、主外键定义"><a href="#一、主外键定义" class="headerlink" title="一、主外键定义"></a>一、主外键定义</h4><p>==主键，primary key==：是被挑选出来，作表的惟一标识的候选关键字，一个表只有一个主键。比如，一条记录包括身份正号，姓名，年龄。身份证号是唯一能确定你这个人的，其他都可能有重复，所以，身份证号是主键。<strong>注意，主键可以是一个字段，也可以是多个字段组合成的多字段联合主键</strong>，看下面这个例子：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#将name和deptId字段组合成为表temp的多字段组合主键CREATE TABLE temp(    name VARCHAR(32),    deptId INT,    salary FLOAT,    PRIMARY KEY(name,deptId))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>==外键==：外键用于与另一张表的关联。是能确定另一张表记录的字段，用于保持数据的一致性。比如，A表中的一个字段，是B表的主键，那他就可以是A表的外键。</p><h4 id="二、主外键用法-amp-意义"><a href="#二、主外键用法-amp-意义" class="headerlink" title="二、主外键用法&amp;意义"></a>二、主外键用法&amp;意义</h4><p>在以后我们统一将外部关键字叫做<strong>外键</strong>，外键就是<strong>另一张表中的主键</strong>。</p><p><strong>问：外键有啥用啊？</strong><br>答：外键的主要作用就是保持数据的一致性，完整性。</p><p><strong>再问：怎么保证的呢？</strong><br>答：看下图。</p><p>$\textcolor{RedOrange}{表Student:} $</p><table><thead><tr><th>stuId</th><th>name</th><th>classId</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>1</td></tr><tr><td>2</td><td>李四</td><td>2</td></tr></tbody></table><p>$\textcolor{RedOrange}{表Class:} $</p><table><thead><tr><th>calssId</th><th>className</th></tr></thead><tbody><tr><td>1</td><td>计算机1班</td></tr><tr><td>2</td><td>计算机2班</td></tr></tbody></table><p>看上图有两张表，<code>classId</code>是<code>Student</code>的外键，是<code>Class</code> 表的主键， 如果我们要删除<code>Class</code> 表中<code>classId</code>为<code>1</code>的字段，程序是会<strong>报错的</strong>，因为<code>Student</code>表中有数据和<code>classId</code>为<code>1</code>的字段关联了，是不能删除的，这样子就保证了数据的<strong>一致性和完整性</strong>。</p><p><strong>继续问： 那怎么才能删除呢？</strong><br>答： 需要先删除<code>Student</code>表中<code>classId</code>为1的两个字段。</p><h4 id="三、如何创建外键"><a href="#三、如何创建外键" class="headerlink" title="三、如何创建外键"></a>三、如何创建外键</h4><p>在MySQL中给表中字段添加外键约束的语法规则如下：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CONSTRAINT 外键名 FOREIGN KEY 字段名 REFERENCES 主表名(主键名)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>举个例子，现在有两张表，一张学生表，一张班级表，内容看上面的表：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE student(    stuId INT PRIMARY KEY,    name VARCHAR(22),    classId INT,    CONSTRAINT student_class_id FOREIGN KEY(classId) REFERENCES class(classId));CREATE TABLE class(    classId INT PRIMARY KEY,    className VARCHAR(22));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java进阶 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
            <tag> 主键 </tag>
            
            <tag> 外键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础语法 IO流核心(读进来，写出去)</title>
      <link href="2021/042646111.html"/>
      <url>2021/042646111.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Java基础语法-IO流核心-读进来，写出去"><a href="#Java基础语法-IO流核心-读进来，写出去" class="headerlink" title="Java基础语法 IO流核心(读进来，写出去)"></a>Java基础语法 IO流核心(读进来，写出去)</h2><h4 id="一、IO流存在的意义"><a href="#一、IO流存在的意义" class="headerlink" title="一、IO流存在的意义"></a>一、IO流存在的意义</h4><ul><li><p>解决设备与设备之间的数据传输问题，比如：硬盘——-&gt;内存   内存——–&gt;硬盘。</p></li><li><p>计算机进行网络数据传输，文件读写，用户输入和打印的时候都需要用到IO流。</p></li></ul><h4 id="二、IO流分类"><a href="#二、IO流分类" class="headerlink" title="二、IO流分类"></a>二、IO流分类</h4><p>Java IO流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系，Java IO流的40多个类都是从如下4个抽象类基类中派生出来的。<br><strong>InputStream/Reader</strong>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。<br><strong>OutputStream/Writer</strong>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。<br><strong>注：它们都是一些抽象基类，无法直接创建实例。</strong></p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210426143905196.png" alt="image-20210426143905196"></p><h4 id="三、字符流和字节流"><a href="#三、字符流和字节流" class="headerlink" title="三、字符流和字节流"></a>三、字符流和字节流</h4><p>字符流的由来： 因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。 字节流和字符流的区别：</p><ul><li>读写单位不同：字节流以字节（8 bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。</li><li>处理对象不同：字节流能处理所有类型的数据（如图片、avi 等），而字符流只能处理字符类型的数据。</li></ul><p>结论：只要是处理纯文本数据，就优先考虑使用字符流。 除此之外都使用字节流。</p><h4 id="四、输入流和输出流"><a href="#四、输入流和输出流" class="headerlink" title="四、输入流和输出流"></a>四、输入流和输出流</h4><p>对输入流只能进行读操作，对输出流只能进行写操作，程序中需要根据待传输数据的不同特性而使用不同的流。  </p><h4 id="五、IO流常用读写操作"><a href="#五、IO流常用读写操作" class="headerlink" title="五、IO流常用读写操作"></a>五、IO流常用读写操作</h4><ol><li><p>==使用字符流复制文件==</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//使用字符流复制文件public class Test{public static void main(String[] args) throws IOException  {    try(BufferedReader br = new BufferedReader(new FileReader("E:\\Test1.txt")); //通过文件缓冲流读文件        BufferedWriter bw   = new BufferedWriter(new FileWriter("E:\\Test2.txt"))) {        char[] ch = new char[100];        int len;        while((len = br.read(ch))!=-1) {//以一个字符数组为中介存储或者读写东西，也有防止数组浪费的好处            bw.write(ch);        }    } catch (FileNotFoundException e) {        // TODO Auto-generated catch block        e.printStackTrace();    }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>==字节流复制数据==</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test{public static void main(String[] args) throws IOException {    BufferedInputStream bis = new BufferedInputStream(new FileInputStream("E:\\Test3.jpg"));    BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("E:\\Test4.jpg"));    byte[] b = new byte[1024];    int len;    while((len = bis.read(b))!=-1) {//字符流通过字符数组，字节流当然通过字节数组        bos.write(b);        bos.flush();    }    bos.close();    bis.close();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>==字符和字节的转换==</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test{    public static void main(String[] args) {        //字符串   a  c  v         String str1 = 12 + "";        //String str2 = 'a' + "";        //将字符串转换成字节数组，可以输出一下更好理解流的本质        byte[] bytes = "abc".getBytes();        for (int j = 0; j &lt; bytes.length; j++) {            System.out.println(bytes[j]);        }        //有参构造  将字节数组 编程 字符串        String str = new String(bytes);        //重写了toString  打印字符串的内容        System.out.println(str.toString());  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>==查找后缀名是 .txt 的文件==</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test{public static void main(String[] args) {    getDir("F:\\", ".txt");}public static void getDir(String path,String latter) {File f = new File(path);if(f.isFile()) { //如果是文件的话就可以输出路径    if(f.getName().endsWith(latter)) {        System.out.println(f.getAbsolutePath());    }}else {    File[] list = f.listFiles();//不是文件的话必须得深入文件夹去查看    if(f.length()&gt;0&amp;&amp;list!=null) {        for (File file : list) {//遍历文件夹中的东西            getDir(file.getAbsolutePath(), latter);        }    }}  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>==删除某一个文件 (和查找相似)==</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test{public static void main(String[] args) throws IOException {    removeDir("F:\\practice");}public static void removeDir(String path) throws IOException {    File file = new File(path);    if(file.isFile()) {    file.delete();    }    else {        File[] listFiles = file.listFiles();        for (File file2 : listFiles) {            removeDir(file2.getAbsolutePath());        }        file.delete();    }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>==一个项目中的实例某一块运用==</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) {    List&lt;ShoppingBean&gt; list = new ArrayList&lt;&gt;();    try(BufferedReader br = new BufferedReader(new FileReader("D:\\a.txt"));) {        String str;        while((str=br.readLine())!=null) { //可以一行一行读取            String[] split = str.split(",");             int id = Integer.parseInt(split[0]);             String name = split[1];             double price = Double.parseDouble(split[2]);             int number = Integer.parseInt(split[3]);             ShoppingBean bean = new ShoppingBean();             bean.set(id, name, price, number);             list.add(bean);}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>==解决乱码问题，看源代码是什么编码，使用包装类解决==</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void downLoad() throws IllegalArgumentException, IOException {        FSDataInputStream input = fs.open(new Path("/upload.txt"));        BufferedReader  br = new BufferedReader(new InputStreamReader(input,"utf-8")); //使用包装类修改编码         BufferedWriter bw = new BufferedWriter(new FileWriter("e:/upload.txt"));         String str = null;         while((str = br.readLine())!= null) {             bw.write(str);         }         bw.close();         br.close();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础语法 </tag>
            
            <tag> IO流 </tag>
            
            <tag> 字节流 </tag>
            
            <tag> 字符流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java进阶 三层架构</title>
      <link href="2021/042251719.html"/>
      <url>2021/042251719.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Java进阶-三层架构"><a href="#Java进阶-三层架构" class="headerlink" title="Java进阶 三层架构"></a>Java进阶 三层架构</h2><p>三层架构是我们没有接触过的新知识，那么我们在学习它的时候，就应该和之前学习其他内容一样，从以下四个方面去了解学习它：</p><ol><li>三层架构是什么？</li><li>为什么要用三层架构？</li><li>三层架构怎么用？</li><li>实例测试</li></ol><h4 id="1、三层架构是什么？"><a href="#1、三层架构是什么？" class="headerlink" title="1、三层架构是什么？"></a>1、三层架构是什么？</h4><p>首先我们要明白三层架构的内容有哪些。官方的解释是三层架构就是为了符合“高内聚，低耦合”思想，把各个功能模块划分为表示层（UI）、业务逻辑层（BLL）和数据访问层（DAL）三层架构，各层之间采用接口相互访问，并通过对象模型的实体类（Model）作为数据传递的载体，不同的对象模型的实体类一般对应于数据库的不同表，实体类的属性与数据库表的字段名一致。</p><p>官方给的解释其实也并不难理解，我们在开发一个完整的功能模块的时候，肯定会有用户界面，根据用户的选择实现不同的代码逻辑，而逻辑处理往往大部分都是在和数据库打交道，需要对数据进行增删改查。那么为了让代码的实现更加的有条理、有逻辑，我们就把用户界面、逻辑处理、与数据库的交互分开实现，至于为什么各层之间采用接口相互访问，下面说第三点的时候着重说明。</p><h4 id="2、为什么要用三层架构？"><a href="#2、为什么要用三层架构？" class="headerlink" title="2、为什么要用三层架构？"></a>2、为什么要用三层架构？</h4><p>在真实的业务开发中，往往是需要团队合作开发的，毕竟一个完整的实际项目，它的开发周期会很长，这就意味着里面会有非常多的功能模块，比如一个简单的图书管理系统，就有管理员对图书的增删改查、对用户的增删查改，用户对图书的增删查改等等。这样的一个简单项目由一个团队来开发只需要一到两天即可，而我们却用了整整两周不止。</p><p>那么既然需要团队协同开发，自然离不开功能模块的划分了，这时候就需要使用三层架构的思想了，在三层架构中，各层互相独立，完成自己该完成的任务，项目可以多人同时开发，开发人员可以只关注整个结构中的其中某一层（自己负责的那一层即可）。举一个简单的例子，我们要在数据库查找一个人，那么首先需要一个方法去数据库查找，需要查找的条件，比如id，那么我们就初步建立了一个方法 findById(int id)，找到之后我们需要打印这个人的信息，那方法就进一个完善，有了返回值 User findById(int id)。这个方法是用来在数据库进行查询的，那万一没有这个人呢，或者找到这个人我需要把这个人进行一些列的包装处理呢？这一些列的操作我们可以把它放在逻辑处理层来，在逻辑处理层创建一个方法，处理完了之后，返回给用户界面。</p><p>从另一个方面来说，三层架构有利于各层逻辑的复用，比如上面说到的图书管理系统中管理员可以对图书进行增删查改，我们将这些方法放在一个类中，再出现对用户的增删查改时，我们就可以复用这些代码，修改参数和返回值类型即可。</p><p>这样分层处理，也更有利于代码的移植、维护，比如数据库SQLServer 转 Oracle数据库时，我们只需要修改一个层即可，因为与数据库的交互都在数据访问层中。</p><h4 id="3、三层架构怎么用？"><a href="#3、三层架构怎么用？" class="headerlink" title="3、三层架构怎么用？"></a>3、三层架构怎么用？</h4><p>使用三层架构时，我们首先要先创建好不同的包，每一个包对应三层架构的一个层。下面我通过一个学生登录功能的案例给大家讲解三层架构的用法。</p><ol><li><p>首先我们在数据库中==创建了 student表==，结构如下：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210422102615511.png" alt="image-20210422102615511"></p></li><li><p>创建数据传递的载体==实体类==，一般我们将实体类放在domain/pojo/entity 这三者其中一个的包下，实体类的属性需要与数据库中的表一一对应。</p><p>我在 src 目录下创建了存放实体类的包：entity，然后在包下创建了Student类，它的属性和数据表student的属性一一对应，然后在实体类中给各个属性创建了对应的get/set方法，创建了有参/无参构造方法以及toString()方法。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210422103234603.png" alt="image-20210422103234603"></p></li><li><p>创建==工具包util==，用于存放一些常用且不变的方法，比如IO流的读写，反反复复都是那些代码，我们就将这些重复的代码抽取出来将它封装成一个工具类，在我们需要用到这个方法的时候，直接调用即可。在验证登录这个案例里面，我们将连接数据库需要的代码抽取出来，这是因为每一次对数据库表进行增删改查访问的时候都需要连接数据库，所以将它抽取成工具类方便使用。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210422110700621.png" alt="image-20210422110700621"></p></li><li><p>创建==数据访问层dao==，在数据访问层中将对数据库表进行操作的方法写在接口 StudentDao 中，然后通过实现类 StudentImpl 写具体操作数据库表的逻辑代码。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210422104819850.png" alt="image-20210422104819850"></p><p>先将需要用到的方法都封装好，不写方法的实现，用到某一个方法，写这个方法的具体实现。这里我们要做的是登录验证，所以我们封装了登录方法 login ，接下来我们分析：验证登录肯定需要学生先输入用户名和密码，有了用户名和密码之后去数据库表中查对应的数据，查到了就将这个学生的信息打印出来。经过分析我们知道方法的参数就是 name 和 password ，返回值就是这个学生 Student。</p><p>方法的具体实现，就是通过sql语句对数据库表进行操作，都是固定的模板，通过 JDBCTemplate模板 调用实现的方法即可。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210422105032099.png" alt="image-20210422105032099"></p></li><li><p>创建==业务逻辑层service==，业务逻辑层主要是对具体问题进行逻辑判断与执行操作，接收到表现层 UI 的用户指令后（用户某一步操作），会连接数据访问层 DAL进行业务处理。访问层在三层构架中位于表示层与数据层中间位置，同时也是表示层与数据层的桥梁，实现三层之间的数据连接和指令传达，可以对接收数据进行逻辑处理，实现数据的修改、获取、删除等功能，并将处理结果反馈到表示层 UI 中，实现软件功能。</p><p>在登录案例里面，我们通过学生输入的名字和密码在数据库表里进行查找，如果没有，我们就告诉学生输入的姓名或者密码错误；如果学生输入的信息为空，那么我们就根本不用访问数据访问层的方法，直接提示用户输入错误。这一系列的逻辑判断我们都写在逻辑层service里面。<img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210422112359515.png" alt="image-20210422112359515"></p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210422112422703.png" alt="image-20210422112422703"></p></li><li><p>创建==用户表示层view==，表示层又称表现层 UI，位于三层构架的最上层，与用户直接接触，主要是 B/S 信息系统中的 Web浏览页面，由于我们还没有使用Web页面，所以我们的用户表示层，就是现在大家写的主函数里用户输入的信息。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210422113025351.png" alt="image-20210422113025351"></p><p>可以看到，我们的用户界面只有一句核心代码，就是调用业务逻辑层的 loginStu() 方法，其他的处理全都通过三层架构的方式分开存放，代码的逻辑变得非常的清晰。</p><h3 id="注意："><a href="#注意：" class="headerlink" title="==注意：=="></a>==注意：==</h3><p>这里解释为什么我们要先写接口再写实现类：<strong>使用接口是为了调用与实现解耦，带来的好处是可以各干各的</strong>。</p><p>先从工序上说，你在写上一层的时候，会用到下一层提供的逻辑，具体表现形式就是各种各样的service类和里面的方法。上一层开搞的时候，一定会知道的一个事是下一层会干什么事，比如“将传入编号对应的人员信息设置为离职”，但下一层的代码不一定已经一行一行写出来了。所以这会儿需要有个接口，让写上层代码的人先能把代码写下去。有各种理由可以支持这种工序的合理性，比如一般来说，上一层的一行代码会对应下一层的好多行代码，那先让写上层代码的人写一遍，解决高端层面的bug，会提高很多效率。</p><p>再从抽象角度说，不同业务模块之间的共用，不一定是共用某段代码，也可能是共用某段逻辑框架，这时候就需要抽象一个接口层出来，再通过不同的注入逻辑实现。比如模块1是登记学生信息，模块2是新闻发布，看上去风马牛不相及。但分析下来如果两个模块都有共同点，顺序都是1、验证是否有权限 2、验证输入参数是否合法 3、将输入参数转化为业务数据 4、数据库存取 5、写log，那就可以写一个service接口，里面有上述5个函数，再分别写两个service实现。具体执行的时候，通过各种注入方法，直接new也好，用spring注入也好，实现不同的效果。</p><p>这样做的另一个目的是为了后期的维护。当软件全部编好了，测试好了，然后给用户装好了，但是过一段时间，用户用着不爽，他又让做软件的人改变一些功能，这样软件开发人员只需要改实现类里面的代码，也就是只用改一个包下代码，不用这个包改一下，那个包里的代码还要改。因为项目大了，代码就是成万上亿行，用了接口的话，就起了这个作用。</p><p>另外，<strong>不用接口的话，假如修改了dao中的代码，因为service引用了dao中的类，那么也要改变service里面的代码，改完之后要重新编译运行，当项目比较大的时候，编译和运行很浪费时间的，而且会产生一些意外，本来只要编译dao中的代码，现在不光要编译dao中的代码，还要编译service。因为你不用接口，间接着action里的代码也要改，因为action中引用了service中的类</strong>，到最后，就变成了，牵一发而动全身本来在各个层之间用了接口只需要改一处代码的，这下可好，全要改，举个不太恰当的例子：好比，我摔了一跤，小腿摔断了，小腿断了，因为没用接口，间接着，大腿也断了，接着，屁股开花了，接着，上身也感染了。最后gg了。可能不太恰当，但是有助于你理解。</p><p>==实在理解不了，你就记住这句真理：使用接口是为了调用与实现解耦，带来的好处是可以各干各的。==</p></li></ol><h4 id="4、-实例测试"><a href="#4、-实例测试" class="headerlink" title="4、 实例测试"></a>4、 实例测试</h4><p>通过对上述三层架构的学习，下面大家在上面这个案例的基础之上完成 学生的注册功能，分析：</p><ol><li>注册相当于往数据库表中添加一条数据。</li><li>注意用代码判断输入的信息是否有误。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java进阶 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 三层架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java进阶 谈谈MySQL数据库的学习思路</title>
      <link href="2021/041325912.html"/>
      <url>2021/041325912.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Java进阶-谈谈MySQL数据库的学习思路"><a href="#Java进阶-谈谈MySQL数据库的学习思路" class="headerlink" title="Java进阶 谈谈MySQL数据库的学习思路"></a>Java进阶 谈谈MySQL数据库的学习思路</h2><h4 id="1-能够理解数据库的概念"><a href="#1-能够理解数据库的概念" class="headerlink" title="1. 能够理解数据库的概念"></a>1. 能够理解数据库的概念</h4><p>网上一找就能找到一大片关于概念的知识，这里就不多作介绍了，今天主要给大家说说常见的数据库种类和MySQL数据库的优势以及使用数据库的原因。</p><p>在前面的学习过程中，我们主要使用创建对象和IO流的方式储存对象，那么既然已经有两种方式用来存储数据了，还学数据库干什么呢？通过下表的对比就能明白：</p><table><thead><tr><th>存储位置</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>内存</td><td>速度快</td><td>不能永久保存，数据是临时状态</td></tr><tr><td>文件</td><td>数据可以永远保存</td><td>操作数据不方便，查询，某个数据</td></tr><tr><td>数据库</td><td>数据可以永久保存<br>查询速度快<br>对数据的管理方便</td><td>占用资源，需要购买</td></tr></tbody></table><p>常见的数据库有以下这些：Oracle、MySQL、SQL server、PostgreSQL、MongoDB、DB2、Redis、SQLite。</p><p>这么多数据库为什么我们学习的是却是MySQL呢？很简单，因为它不光有强大的功能，还==开源免费==。</p><h4 id="2-能够安装与卸载-MySQL-数据库"><a href="#2-能够安装与卸载-MySQL-数据库" class="headerlink" title="2. 能够安装与卸载 MySQL 数据库"></a>2. 能够安装与卸载 MySQL 数据库</h4><p>关于MySQL的安装与卸载，这些操作是我们学习数据库的前提，所以我专门写了一篇文章介绍，这里就把文章地址给到大家，如果还没有安装好MySQL的小伙伴，可以参照这篇文章进行安装。</p><p>博客名称：<a href="https://blog.csdn.net/liulei952413829/article/details/115657897">Java进阶 MySQL的安装与卸载流程</a></p><p>博客地址：<a href="https://blog.csdn.net/liulei952413829/article/details/115657897">https://blog.csdn.net/liulei952413829/article/details/115657897</a></p><h4 id="3-能够启动-关闭及登录-MySQL"><a href="#3-能够启动-关闭及登录-MySQL" class="headerlink" title="3. 能够启动,关闭及登录 MySQL"></a>3. 能够启动,关闭及登录 MySQL</h4><ol><li><p>MySQL服务器的启动方式有两种：</p><p>①通过服务的方式自动启动</p><p>鼠标右键“我的电脑”——&gt;点击管理(G)——&gt;进入以下界面：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210413172249482.png" alt="image-20210413172249482"></p><p>②手动启动的方式（DOS命令方式启动）</p><p>==注意：这里打开DOS需要以管理员的身份==，搜索栏搜索“命令提示符”，然后右键管理员身份运行。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210413184624449.png" alt="image-20210413184624449"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//打开后执行以下命令开启MySQL服务net start mysql//执行以下命令停止MySQL服务net stop mysql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>控制台连接数据库</p><p>MySQL 是一个需要账户名密码登录的数据库，登陆后使用，它提供了一个默认的 root 账号，使用安装时设置的密码即可登录。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//登录命令,方式一：mysql -uroot -proot//方式二mysql -uroot -p    然后提示输入密码：//方式三mysql -hip地址 -uroot -proot//方式四mysql --host=ip地址 --user=root --password=root//退出MySQLquit或exit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>SQLyog 图形化工具——客户端控制数据库</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210413190841860.png" alt="image-20210413190841860"></p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210413191009340.png" alt="image-20210413191009340"></p></li></ol><h4 id="4-能够使用-SQL-语句操作数据库"><a href="#4-能够使用-SQL-语句操作数据库" class="headerlink" title="4. 能够使用 SQL 语句操作数据库"></a>4. 能够使用 SQL 语句操作数据库</h4><p>学会使用以下四类sql语句即可：</p><ol><li>Data Definition Language (DDL 数据定义语言) 如：建库，建表</li><li>Data Manipulation Language(DML 数据操纵语言)，如：对表中的记录操作增删改</li><li>Data Query Language(DQL 数据查询语言)，如：对表中的查询操作</li><li>Data Control Language(DCL 数据控制语言)，如：对用户权限的设置</li></ol><h4 id="5-能够使用-SQL-语句操作表结构"><a href="#5-能够使用-SQL-语句操作表结构" class="headerlink" title="5. 能够使用 SQL 语句操作表结构"></a>5. 能够使用 SQL 语句操作表结构</h4><h4 id="6-能够使用-SQL-语句进行数据的添加修改和删除的操作"><a href="#6-能够使用-SQL-语句进行数据的添加修改和删除的操作" class="headerlink" title="6. 能够使用 SQL 语句进行数据的添加修改和删除的操作"></a>6. 能够使用 SQL 语句进行数据的添加修改和删除的操作</h4><h4 id="7-能够使用-SQL-语句进行数据的简单查询操作"><a href="#7-能够使用-SQL-语句进行数据的简单查询操作" class="headerlink" title="7. 能够使用 SQL 语句进行数据的简单查询操作"></a>7. 能够使用 SQL 语句进行数据的简单查询操作</h4>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java进阶 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java进阶 MySQL的安装与卸载流程</title>
      <link href="2021/041329010.html"/>
      <url>2021/041329010.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Java进阶-MySQL的安装与卸载流程"><a href="#Java进阶-MySQL的安装与卸载流程" class="headerlink" title="Java进阶 MySQL的安装与卸载流程"></a>Java进阶 MySQL的安装与卸载流程</h2><p>$\textcolor{Red}{安装过程注意两点：} $</p><ul><li>MySQL默认的安装目录：C:\Program Files\MySQL Server x.x\</li><li>在 mysql 中管理员的名字设置为：root</li></ul><h4 id="一、数据库的安装"><a href="#一、数据库的安装" class="headerlink" title="一、数据库的安装"></a>一、数据库的安装</h4><ol><li><p>打开下载的 mysql 安装文件双击解压缩，我下载的是“mysql-5.5.40-win32.msi”。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210413095949753.png"></p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210413100107484.png" alt="image-20210413100107484"></p></li><li><p>选择安装类型，有“Typical（默认）”、“Complete（完全）”、“Custom（用户自定义）”三个选项，选择“Custom”， 按“next”键继续。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210413100149274.png" alt="image-20210413100149274"></p></li><li><p>点选“Browse”，手动指定安装目录。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210413100227048.png" alt="image-20210413100227048"></p></li><li><p>填上安装目录，我的是“d:\Program Files (x86)\MySQL\MySQL Server 5.0”，按“OK”继续。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210413100303088.png" alt="image-20210413100303088"></p></li><li><p>确认一下先前的设置，如果有误，按“Back”返回重做。按“Install”开始安装。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210413100330784.png" alt="image-20210413100330784"></p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210413100357537.png" alt="image-20210413100357537"></p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210413100423454.png" alt="image-20210413100423454"></p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210413100441586.png" alt="image-20210413100441586"></p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210413100500278.png" alt="image-20210413100500278"></p></li><li><p>正在安装中，请稍候，直到出现下面的界面, 则完成 MYSQL 的安装。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210413100632407.png" alt="image-20210413100632407"></p><p>==数据库安装好了还需要对数据库进行配置才能使用 MYSQL 的配置==</p></li><li><p>安装完成了，出现如下界面将进入 mysql 配置向导。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210413100829627.png" alt="image-20210413100829627"></p></li><li><p>选择配置方式，“Detailed Configuration（手动精确配置）”、“Standard Configuration（标准配置）”，我们选择“Detailed Configuration”，方便熟悉配置过程。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210413100925445.png" alt="image-20210413100925445"></p></li><li><p>选择服务器类型，“Developer Machine（开发测试类，mysql 占用很少资源）”、“Server Machine（服务器类型，mysql 占用较多资源）”、“Dedicated MySQL Server Machine（专门的数据库服务器，mysql 占用所有可用资源）”</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210413101036834.png" alt="image-20210413101036834"></p></li><li><p>选择mysql数据库的大致用途，“Multifunctional Database（通用多功能型，好）”、“Transactional Database Only（服务器类型，专注于事务处理，一般）”、“Non-Transactional Database Only（非事务处理型，较简单，主要做一些监控、记数用，对 MyISAM 数据类型的支持仅限于 non-transactional），按“Next”继续。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210413101302877.png" alt="image-20210413101302877"></p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210413101321943.png" alt="image-20210413101321943"></p></li><li><p>选择网站并发连接数，同时连接的数目，“Decision Support(DSS)/OLAP（20个左右）”、“Online Transaction Processing(OLTP)（500 个左右）”、“Manual Setting（手动设置，自己输一个数）”。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210413101438447.png" alt="image-20210413101438447"></p></li><li><p>是否启用 TCP/IP 连接，设定端口，如果不启用，就只能在自己的机器上访问 mysql 数据库了，在这个页面上，您还可以选择“启用标准模式”（Enable Strict Mode），这样 MySQL 就不会允许细小的语法错误。如果是新手，建议您取消标准模式以减少麻烦。但熟悉 MySQL 以后，尽量使用标准模式，因为它可以降低有害数据进入数据库的可能性。按“Next”继续。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210413101514501.png" alt="image-20210413101514501"></p></li><li><p>就是对 mysql 默认数据库语言编码进行设置（重要），一般选 UTF-8，按 “Next”继续。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210413101552068.png" alt="image-20210413101552068"></p></li><li><p>选择是否将 mysql 安装为 windows 服务，还可以指定 Service Name（服务标识名称），是否将 mysql 的 bin目录加入到 Windows PATH（加入后，就可以直接使用 bin 下的文件，而不用指出目录名，比如连接，“mysql.exe -uusername -ppassword;”就可以了，不用指出 mysql.exe 的完整地址，很方便），我这里全部打上了勾，Service Name 不变。按“Next”继续。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210413101632573.png" alt="image-20210413101632573"></p></li><li><p>询问是否要修改默认 root 用户（超级管理）的密码。“Enable root access from remote machines（是否允许 root 用户在其它的机器上登陆，如果要安全，就不要勾上，如果要方便，就勾上它）”。最后“Create An Anonymous Account（新建一个匿名用户，匿名用户可以连接数据库，不能操作数据，包括查询）”，一般就不用勾了，设置完毕，按“Next”继续。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210413101719034.png" alt="image-20210413101719034"></p></li><li><p>确认设置无误，按“Execute”使设置生效，即完成 MYSQL 的安装和配置。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210413101747240.png" alt="image-20210413101747240"></p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210413101834873.png" alt="image-20210413101834873"></p><p>$\textcolor{Red}{注意：设置完毕，按“Finish”后有一个比较常见的错误，就是不能“Start service”} $</p><p>一般出现这个错误，就说明电脑上之前安装过数据库没有卸载或着是没有卸载干净。解决的办法当然只有先保证以前安装的 mysql 服务器彻底卸载掉了；不行的话，检查是否按上面一步所说，之前的密码是否有修改，照上面的操作；如果依然不行，将 mysql 安装目录下的 data 文件夹备份，然后删除，在安装完成后，将安装生成的 data 文件夹删除，备份的 data 文件夹移回来，再重启 mysql 服务就可以了，这种情况下，可能需要将数据库检查一下，然后修复一次，防止数据出错。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210413101922069.png" alt="image-20210413101922069"></p><p>==解决方法：卸载 MySQL,重装 MySQL==</p></li></ol><h4 id="二、数据库的卸载（数据库的卸载严格按照下面的步骤执行，不然下次安装很容易报错）"><a href="#二、数据库的卸载（数据库的卸载严格按照下面的步骤执行，不然下次安装很容易报错）" class="headerlink" title="二、数据库的卸载（数据库的卸载严格按照下面的步骤执行，不然下次安装很容易报错）"></a>二、数据库的卸载（数据库的卸载严格按照下面的步骤执行，不然下次安装很容易报错）</h4><ol><li><p>停止 window 的 MySQL 服务。 找到“控制面板”-&gt; “管理工具”-&gt; “服务”，停止 MySQL 后台服务。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210413102731236.png" alt="image-20210413102731236"></p></li><li><p>卸载 MySQL 安装程序。找到“控制面板”-&gt; “程序和功能”，卸载 MySQL 程序。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210413102917160.png" alt="image-20210413102917160"></p></li><li><p>删除 MySQL 安装目录下的所有文件。</p></li><li><p>删除 C 盘 ProgramDate 目录中关于 MySQL 的目录。路径为：C:\ProgramData\MySQL(是隐藏文件,需要显示出来）。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210413103023257.png" alt="image-20210413103023257"></p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/image-20210413103041416.png" alt="image-20210413103041416"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java进阶 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础语法 说说集合框架的简单学习思路</title>
      <link href="2021/033149591.html"/>
      <url>2021/033149591.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java基础语法-说说集合框架的简单学习思路"><a href="#Java基础语法-说说集合框架的简单学习思路" class="headerlink" title="Java基础语法 说说集合框架的简单学习思路"></a>Java基础语法 说说集合框架的简单学习思路</h2><h4 id="1-自学集合的思路是什么？从哪几个方面快速学完集合框架知识？"><a href="#1-自学集合的思路是什么？从哪几个方面快速学完集合框架知识？" class="headerlink" title="1. 自学集合的思路是什么？从哪几个方面快速学完集合框架知识？"></a>1. 自学集合的思路是什么？从哪几个方面快速学完集合框架知识？</h4><p>在学习集合之前，我们先通过下面这段代码回忆一下数组的使用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Array {//根据下标查询元素public static int queryElementByIndex(int[] arr, int index) {return arr[index];}//根据元素查找下标public static int queryIndexByElement(int[] arr, int ele) {int index = -1; // 用来记录下标的变量// 1：遍历所有的元素for (int i = 0; i &lt; arr.length; i++) {// 2 用你要查找的元素和所有的元素做==比较if (arr[i] == ele) {// 3 相等判断成立，记录当前元素的下标index = i;// 记录当前元素的下标break; // 后面元素就不用判断了}}return index;}//求数组的最大值public static int maxValue(int[] arr) {// 1 假设第一个元素是最大值int max = arr[0];// 2:遍历数组for (int i = 1; i &lt; arr.length; i++) {// 3 用这个个最大值和后面的元素做大于比较if (arr[i] &gt; max) {// 4如果后面的元素比这个最大值还大，那么后面的元素就是最大值max = arr[i];}}return max;}//求数组的最小值public static int minValue(int[] arr) {// 1 假设第一个元素是最小值int min = arr[0];// 2:遍历数组for (int i = 1; i &lt; arr.length; i++) {// 3 用后面的元素这个最小值和做小于比较if (arr[i] &lt; min) {// 4如果后面的元素比这个最小值还小，那么后面的元素就是最小值min = arr[i];}}return min;}/** *  给数组添加元素 * @param arr * @param ele * @param index * @return  返回新的数组 */public static int[] addElement(int[] arr, int ele, int index) {// 1：新建一个数组，长度是原数组长度+1 数组扩容int[] newArr = new int[arr.length + 1];if(index&gt;=0 &amp;&amp; index&lt;newArr.length){// 2 拿到下标为3的前面的元素，放到新数组按照0 1 2 顺序依次存放for (int i = 0; i &lt; index; i++) {newArr[i] = arr[i];}// 3 把要添加的元素100放入新数组下标为3的位置newArr[index] = 100;// 4 拿到下标为3的后面的元素，放到新数组按照 4 5 顺序依次存放for (int i = index; i &lt; arr.length; i++) {newArr[i + 1] = arr[i];}}else{System.out.println("索引超出范围");//超出范围，返回旧数组return arr;}// 5:返回新数组return newArr;}/** * 根据下标删除元素 * @param arr * @param index * @return  原数组 */public static int[] delEleByIndex(int[] arr,int index){if(index&gt;=0 &amp;&amp; index&lt;arr.length){//1：找到下标为2的元素，后面的元素依次覆盖前面的元素for(int i = index;i&lt;arr.length-1;i++){arr[i] = arr[i+1];}//2：把最后一位赋值为0arr[arr.length-1] = 0;}else{System.out.println("没有此下标");}//3 返回删除后的数组return arr;}/** * 根据元素删除元素 * @param arr * @param ele * @return  下标 */public static int delEleByEle(int[] arr,int ele){   //1 :定义删除元素的下标int index = -1;//2：用你要删除的元素和数组里面的每一个元素做==比较for(int i = 0;i&lt;arr.length;i++){if(ele==arr[i]){  //3：找到要删除的元素后，记录下当前元素的下标index = i;break; //后面就不要比较了}}//如果index是-1，直接返回，不需要移位if(index==-1){return index;} //4：然后后面的下标依次向前移位for(int i = index;i&lt;arr.length-1;i++){arr[i] = arr[i+1];}//5：把最后一位置为0arr[arr.length-1] = 0;//6  返回数组的下标即可return index;}//主函数public static void main(String[] args) {int[] arr = { 10, 20, 300, 40, 50 };int index = delEleByEle(arr,300);if(index!=-1){for (int i : arr) {System.out.println(i);}}else{System.out.println("没有此元素");}/*arr = delEleByIndex(arr,2);for (int i : arr) {System.out.println(i);}*/     /*int[] newArr = addElement(arr,100,-12);for (int i : newArr) {System.out.println(i);}*//*int max = maxValue(arr);int min = minValue(arr);System.out.println("最大值是:" + max);System.out.println("最小值是:" + min);/* int index = 0; int ele = queryElementByIndex(arr,index);* System.out.println(“下标为”+index+“的元素是:”+ele);*//* * Scanner sc= new Scanner(System.in); * System.out.println("请输入你要查询的元素值"); int ele = sc.nextInt(); //你要查找的元素 * int index = queryIndexByElement(arr,ele); // 4:没有匹配成功,没有此元素 * if(index!=-1){ System.out.println("元素"+ele+"的下标是:"+index); }else{ * System.out.println("没有此元素"); } */}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一系列的操作有没有很熟悉，不管是在刚开始学习的过程中还是平时在使用的过程中，你会发现基本上使用到数组也就这些操作了，总结一下其实就四个字：增删改查。反思片刻之后是否恍然大悟？其实java语言大部分的操作就是在对数据进行处理，而处理数据最简单且用的最多的方式其实就是增删改查了。</p><p>说到这里，相信大家就能明白我们接下来学习集合的切入点是什么了吧。没错，就是学习集合框架中每一种集合它对数据的处理方法有哪些，说白了就是集合如何对数据进行增删改查。OK，有了思路之后，我们开始进入集合框架的学习。</p><h4 id="2-简单了解集合框架的层次结构"><a href="#2-简单了解集合框架的层次结构" class="headerlink" title="2. 简单了解集合框架的层次结构"></a>2. 简单了解集合框架的层次结构</h4><p>Java的容器类主要由两个接口派生而出：Collection和Map，Collection和Map是Java集合框架的根接口，这两个接口又包含了一些子接口或实现类。通过Collection与Map接口导出其他子接口及实现类的框架示意图如下图所示：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/CollectionFrame.png"></p><p>其中Collection/List/Queue/Set/Map/Entry都是接口，只有最下面一层为以上接口的实现类。OK，现阶段我们知道它们之间有这样的关系就行了。那么要使用接口的方法，或者使用实现类的方法，相信大家都知道怎么调用了吧？如果到这还不知道怎么调用集合的方法，可以从新学习一下多态和面向对象的知识了。</p><h4 id="3-集合框架的增删改查"><a href="#3-集合框架的增删改查" class="headerlink" title="3. 集合框架的增删改查"></a>3. 集合框架的增删改查</h4><p>开始之前，我们先举个例子，就拿ArrayList开刀吧。在我们完全不知道一个集合拥有的任何方法的情况下，我们先想一想，这个时候我们要添加一个数据到里面去，首先思考他有没有对应的方法让我们直接放进去呢？如果有我们就直接调用，那么哪一个方法才是用来增加的呢？先用对象点一下看看：</p><p>​    <strong>List:</strong></p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/ArrayListMethods.png"></p><p>我们通过父类引用指向之类对象的方式创建了一个arrayList对象，一目了然，通过“对象点”的方式我们能看到ArrayList现在有这么多的方法，通过方法的名字，我们大概就能分析出很多方法的用处。比如add()方法，很显然是添加数据的意思，remove()是删除的意思，size()是大小的意思等等。</p><p>那么接下来的学习就很简单了，无非是一个一个的调用下面的方法，看看使用方法得到的结果是什么，然后一个一个的打印出来，就差不对掌握了集合的使用了。</p><p>我们再看看其他集合实现类的方法：</p><p>​        <strong>Set:</strong></p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/HashSetMethods.png"></p><p>​        <strong>Map:</strong></p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/HashMapMethods.png"></p><p>相信大家都发现了，其实几个集合的方法都大同小异，很多方法的名字都是一样的，也就是说，我们学会了一种集合，即学会了所有集合，当然是在基础的使用上。几种集合还是有一些本质上的区别的，比如他们存放数据的方式，存放数据的顺序，数据的遍历方式等。不过掌握了上面的学习方法和思路，已经给我们省出了很多的时间，这样我们就能花时间去研究他们的区别，了解每一种集合独特的方法了。</p><p>关于集合框架的一些特性，我将在下一篇文章为大家介绍。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础语法 </tag>
            
            <tag> 多态 </tag>
            
            <tag> 集合 </tag>
            
            <tag> Set </tag>
            
            <tag> Map </tag>
            
            <tag> List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提交内容到GitHub每次都需要验证账号密码的解决方案</title>
      <link href="2021/032425853.html"/>
      <url>2021/032425853.html</url>
      
        <content type="html"><![CDATA[<h2 id="提交内容到GitHub每次都需要验证账号密码的解决方案"><a href="#提交内容到GitHub每次都需要验证账号密码的解决方案" class="headerlink" title="提交内容到GitHub每次都需要验证账号密码的解决方案"></a>提交内容到GitHub每次都需要验证账号密码的解决方案</h2><p>自从搭建了静态博客之后我就发现了一个很麻烦的问题，每一次用Typora 写好文章之后 hexo d 上传到GitHub上就会重复验证GitHub的用户名和密码，这样的操作非常的麻烦，还容易输错造成提交报错。</p><p>我在网上找解决方法的时候发现，发现这个问题还挺普遍的，<strong>不管是hexo还是其他编程软件或者与GitHub相关联的应用都会出现这样的问题</strong>，网络上有各种各样的解决方案，基本上都试过一次之后，发现有些方案很麻烦，需要重新克隆整个博客主题，有的需要修改协议为SSH，最后终于找到了一个最方便实用的解决方法，只需要7步即可轻松解决。</p><p><strong>步骤如下：</strong></p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/TyporaQuestionHexoD1.png" alt="img"></p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/TyporaQuestionHexoD2.png" alt="img"></p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/TyporaQuestionHexoD3.png" alt="img"></p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/TyporaQuestionHexoD4.png" alt="1"></p><p>完成以后，只需要重新打开相关应用，提交即可，实用的话，记得收藏加关注欧。</p>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
            <tag> Typora </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础语法 接口(interface)的定义和实现</title>
      <link href="2021/032351883.html"/>
      <url>2021/032351883.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java基础语法-接口-interface-的定义和实现"><a href="#Java基础语法-接口-interface-的定义和实现" class="headerlink" title="Java基础语法 接口(interface)的定义和实现"></a>Java基础语法 接口(interface)的定义和实现</h2><p>在学习接口之前，建议大家先熟悉一下前一篇文章对抽象的解释：<a href="https://blog.csdn.net/liulei952413829/article/details/115110912">Java基础语法 到底什么是抽象？</a>，因为接口通俗的讲就是比抽象类更抽象的类，深入理解了抽象的概念之后，对学习接口会更有帮助。</p><h3 id="1-接口的定义"><a href="#1-接口的定义" class="headerlink" title="1. 接口的定义"></a>1. 接口的定义</h3><ul><li><p><strong>第一种解释</strong>：接口是功能的集合，同样可看做是一种数据类型，是比抽象类更为抽象的类 。</p><p>接口只描述应该具备的方法，并没有具体实现，具体的实现由接口的实现类(相当于接口的子类)来完成。这样<strong>将功能的定义与实现分离</strong>，优化了程序设计。</p></li><li><p><strong>第二种解释</strong>：Java接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。</p></li><li><p><strong>第三种解释</strong>：有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。有了接口，就可以得到多重继承的效果。接口(interface)是抽象方法和常量值的定义的集合。</p></li><li><p><strong>第四种解释</strong>：接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p><ol><li><p>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。</p></li><li><p>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</p></li><li><p>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象上，这就是通过接口实现多态的关键。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//这里解释的有些生硬，我们通过下面这个案例来解释一下“接口类型可用来声明一个变量”//抽象类 Fu类public interface Fu {     void function();}//子类实现父类public class Zi implements Fu {//子类实现父类需要实现父类的抽象方法    @Override    public void function() {        System.out.println("重写父类方法");    }}//孙子类public class Sun {    //孙子类定义方法需要传入Fu对象    public void Fun(Fu fu){        System.out.println("测试");    }}//测试类public class Test {    public static void main(String[] args) {        //多态的实现：父类的引用指向子类的对象        Fu fu = new Zi();        fu.function();        Sun sun = new Sun();        //传入的参数是父类的引用，实际传入的是子类的对象        sun.Fun(fu);        System.out.println(fu);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打印结果：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">重写父类方法测试com.test.Zi@15aeb7ab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-接口的声明与实现"><a href="#2-接口的声明与实现" class="headerlink" title="2. 接口的声明与实现"></a>2. 接口的声明与实现</h3></li></ol></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">//声明接口[public/缺省] interface 接口名称 [extends 其他的接口名] {        // 声明变量(默认为常量)        // 抽象方法}//示例代码如下：public interface Fu {    int a = 0;//定义的变量默认被static和final修饰，必须赋初值。     void function();}//实现接口...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...//示例代码如下：public class Zi implements Fu {    @Override    public void function() {        System.out.println("重写父类方法");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-接口的特点"><a href="#3-接口的特点" class="headerlink" title="3. 接口的特点"></a>3. 接口的特点</h3><ul><li><p>接口可以理解成统一的<strong>协议</strong>, 而接口中的属性也属于协议中的内容。但是接口的属性都是公共的，静态的，最终的。接口的成员特点：</p><p>1、<strong>成员变量</strong>只能是常量，默认修饰符 <strong>public static final</strong>，使用变量的时候，变量必须被赋值。</p><p>2、<strong>成员方法</strong>只能是抽象方法。默认修饰符 <strong>public abstract</strong></p></li><li><p>接口不可以创建对象。</p></li><li><p>多个无关的类可以实现同一个接口。</p></li><li><p>一个类可以实现多个无关的接口（多实现），例如：public class Hockey implements Sports, Event。</p></li><li><p>接口之间可以多继承，例如：public interface Hockey extends Sports, Event。</p></li><li><p>与继承关系类似，接口与实现类之间存在多态性。</p></li><li><p>接口也可以继承另一个接口，使用extends关键字。</p></li><li><p>接口没有构造方法，不能被实例化。</p></li><li><p>子类必须覆盖掉接口中所有的抽象方法后，子类才可以实例化。否则子类是一个抽象类。</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">/* * 接口的成员特点： *         只能有抽象方法 *         只能有常量 *         默认使用public&amp;abstract修饰方法 *         只能使用public&amp;abstract修饰方法 *         默认使用public static final来修饰成员变量 *  * 建议：建议大家手动的给上默认修饰符 *  * 注意： *         接口不能创建对象（不能实例化） *         类与接口的关系是实现关系，一个类实现一个接口必须实现它所有的方法,否则子类也无法实例化。  *///测试类public class InterfaceDemo {    public static void main(String[] args) {        //Animal a = new Animal();//创建对象报错        //Animal.num;//调用常量        //Cat cat = new Cat();//创建子类对象    }}  //接口类interface Animal {    //定义变量    public static final int num = 10;    //定义抽象方法    public abstract void eat();}//子类实现接口类class Cat implements Animal {    //重写父类方法    public void eat() {            }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>注意（无关紧要，知道就行）：</strong></p><p>①在 JDK8，允许我们给接口添加两种非抽象的方法实现：</p><p>  1、默认方法，添加 <strong>default</strong> 修饰即可；</p><p>  2、静态方法，使用 <strong>static</strong> 修饰即可；</p><p>  示例如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">interface Test{    //这个是默认方法    default String get(String aa){        System.out.println("我是jdk1.8默认实现方法...");        return aa;    }       //这个是静态方法        static void staticmethod(){        System.out.println("我是静态方法");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  调用得话，静态方法只能通过接口名调用，不可以通过实现类的类名或者实现类的对象调用，default 方法只    能通过接口实现类的对象来调用。</p><p>②在 JDK9之后，允许我们给接口添加私有方法。</p></li></ul><h3 id="4-接口与类的关系"><a href="#4-接口与类的关系" class="headerlink" title="4. 接口与类的关系"></a>4. 接口与类的关系</h3><ul><li><strong>类与类之间</strong>: 继承关系，一个类只能直接继承一个父类，但是支持多重继承</li><li><strong>类与接口之间</strong>: 只有实现关系，一个类可以实现多个接口</li><li><strong>接口与接口之间</strong>: 只有继承关系，一个接口可以继承多个接口</li></ul><h3 id="5-接口和抽象类的区别"><a href="#5-接口和抽象类的区别" class="headerlink" title="5. 接口和抽象类的区别"></a>5. 接口和抽象类的区别</h3><ul><li><p><strong>共性</strong>：不断的进行抽取，抽取出抽象的没有具体实现的方法，都不能实例化（不能创建对象）</p></li><li><p><strong>区别</strong></p><ol><li><p>与类的关系</p><p>类与接口是实现关系，而且是多实现，一个类可以实现多个接口；</p><p>类与抽象类是继承关系，Java中的继承是单一继承，多层继承，一个类只能继承一个父类，但是可以有爷爷类。</p></li><li><p>成员的区别</p><p>a.成员变量</p><pre><code>抽象类可以有成员变量，也可以有常量接口只能有常量，默认修饰符public static final</code></pre><p>b.成员方法</p><pre><code>抽象类可以有抽象方法，也可以有非抽象方法接口只能有抽象方法，默认修饰符 public abstract</code></pre><p>c.构造方法</p><pre><code>抽象类有构造方法，为子类提供接口没有构造方法</code></pre></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础语法 </tag>
            
            <tag> 多态 </tag>
            
            <tag> 抽象 </tag>
            
            <tag> 接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础语法 到底什么是抽象？</title>
      <link href="2021/032365135.html"/>
      <url>2021/032365135.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java基础语法-到底什么是抽象？"><a href="#Java基础语法-到底什么是抽象？" class="headerlink" title="Java基础语法 到底什么是抽象？"></a>Java基础语法 到底什么是抽象？</h2><p>在<a href="https://blog.csdn.net/liulei952413829/article/details/114928864">上一篇文章</a>：<a href="https://blog.csdn.net/liulei952413829/article/details/114928864">Java基础语法 三大特性之一——多态</a>中，我们介绍了多态的概念以及用法，文章的最后介绍到多态的实现方式之一就是通过抽象类和抽象方法。那么我们怎么理解Java中抽象这个概念呢？</p><p>对于抽象的解释在前面的文章里其实已经做过介绍了，《<a href="https://blog.csdn.net/liulei952413829/article/details/114658714">Java基础语法 abstract关键字全方位总结</a>》，为什么会在介绍abstract关键字的文章里介绍抽象呢？因为这个关键字就是用来创建抽象类和抽象方法，也就是说<strong>abstract</strong> 修饰的类是抽象类，<strong>abstract</strong> 修饰的方法即抽象方法。在这篇文章里面，有详细介绍抽象的定义，通过抽象的例子详细介绍了抽象类以及抽象方法，大家可以点击链接详细学习：</p><p><a href="https://blog.csdn.net/liulei952413829/article/details/114658714">https://blog.csdn.net/liulei952413829/article/details/114658714</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础语法 </tag>
            
            <tag> 多态 </tag>
            
            <tag> 抽象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java设计模式  设计模式六大原则</title>
      <link href="2021/031835127.html"/>
      <url>2021/031835127.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Java设计模式-设计模式六大原则"><a href="#Java设计模式-设计模式六大原则" class="headerlink" title="Java设计模式  设计模式六大原则"></a>Java设计模式  设计模式六大原则</h2><p>设计模式的6大原则，单一职责原则，开放封闭原则，里式替换原则，依赖导致原则，迪米特原则和接口隔离原则。</p><h3 id="1-单一职责原则"><a href="#1-单一职责原则" class="headerlink" title="1. 单一职责原则"></a>1. 单一职责原则</h3><p><strong>就一个类而言，应该仅有一个引起它变化的原因</strong></p><p>通俗的讲就是我们不要让一个承担过多的职责，如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。</p><p>这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到破坏。</p><p>比如我们会看到一些 Android 开发者在写 Activity 中 写Bean 文件，网络数据处理，如果有列表的话，Adapter也写在 Activity中。至于这么做的原因，除了简单粗暴，好找也没什么理由了，那么把其拆分到其他类岂不是更好找？如果Activity过于臃肿，行数过多，显然不是什么好事。</p><p>如果我们要修改Bean 文件，网络处理和 Adapter 都需要上这个Activity 来修改，就会导致引起该 Activity 变化的原因太多，我们在版本维护时也比较头痛。这也就严重违背了定义： 就一个类而言，应该仅有一个引起它变化的原因。</p><p>单一职责的划分界限不是很清晰，很多时候就要靠个人经验来界定，因此它是一个饱受争议却又极其重要的原则。</p><h3 id="2-开放封闭原则"><a href="#2-开放封闭原则" class="headerlink" title="2. 开放封闭原则"></a>2. 开放封闭原则</h3><p><strong>类，模块，函数等应该是可以扩展的，但是不可以修改</strong></p><p>开放封闭有两个含义：一个是对于扩展是开放，另一个是对于修改是封闭的。</p><p>对于开发者莱索，需求肯定是变化的，但是有新需求，我们就要把类重新改一遍，这显然是令人头痛的，所以我们设计程序时，面对需求的改变要尽可能得保证相对稳定，尽量通过扩展的方式来实现变化，而不是通过修改原有的代码来实现。</p><p>假设我们要实现一个列表，一开始只有查询的功能，后来产品又要新增 添加 功能，过几天又要增加 删除 功能。大多数人的做法是写一个方法，然后通过传入不同的值控制方法实现不同的功能。但是如果又要新增功能，我们还得修改方法。用开发封闭原则解决就是增加一个抽象的功能类，让添加，删除和查询作为这个抽象功能类的子类。这样如果我们再新增功能，你就会发现自己无须修改原有的类，只需要添加一个功能类的子类实现功能类的方法就可以了。</p><p><strong>案例解析：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//定义了一个抽象动物类，有一个方法public abstract class AniMal {    abstract void ObjectX();}//子类猫实现抽象方法class Cat extends AniMal {@Overridevoid ObjectX() {    System.out.println();}}//子类狗实现抽象方法class Dog extends AniMal {    @Override    void ObjectX() {        System.out.println();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-里式替换原则"><a href="#3-里式替换原则" class="headerlink" title="3. 里式替换原则"></a>3. 里式替换原则</h3><p><strong>所有引用基类(父类)的地方必须能透明的使用其子类的对象</strong>，详细解释<a href="https://blog.csdn.net/liulei952413829/article/details/114947495">前一篇文章</a>有做解释，大家可以参考：<a href="https://blog.csdn.net/liulei952413829/article/details/114947495">Java设计模式 里氏替换原则</a>，下面只做简单的介绍。</p><p>在软件中将一个基类对象替换成其子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用子类对象。里式替换原则是实现开放封闭原则的重要方式之一。由于使用基类对象的地方都可以使用子类对象， 因此在程序中尽量使用基类类型来对对象进行定义，而在运行时在确定其子类类型，用子类对象来替换父类对象。在使用里式替换原则是需要注意以下几个问题：</p><p>子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里式替换原则，为了保证系统的扩展性，在程序中通常使用父类来定义。如果一个方法只存于子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。</p><p>我们运用里式替换原则时，尽量把父类设计为抽象类或接口，让子类继承父类或实现父接口，并实现在父类中声明的方法、运行时，子类实例替换父类实例，我们可以很方便的扩展系统功能，同时无序修改原有子类的代码；增加新的功能可以通过增加一个新的子类来实现。里式替换原则是开放封闭原则的具体实现手段之一。</p><p>在java语言中，在编译阶段，java编译器会检查一个程序是否符合里式替换原则。这是一个与实现无关，纯语法意义上的检查，但Java编译器的检查是有局限性的。</p><p><strong>案例解析：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// color 颜色// flavour 气味// 苹果类class Apple{    void Color(){        System.out.println("红色");    }    void Flavour(){        System.out.println("香");    }}//Pack -水果包装类//describe -水果描述//getMessage -返回具体信息class Pack{    private Apple apple;    void setApple(Apple apple) {    this.apple = apple;}  void getMessage(){    apple.Color();    apple.Flavour();}}//buyer 买家-/具体场景 class Buyer{    public static void main(String[] args) {        Pack pack=new Pack();        pack.setApple(new Apple());        pack.getMessage();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果我们此时要再加入一个水果类，那么是不是要更改 Pack包装类，再添加一个类对象，然后调用的时候将其传入进来。</p><p>如果我有5、6个类呢，那我这个包装类岂不是要很麻烦？</p><p><strong>现在我们对这个Demo进行修改：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//水果抽象类abstract class Frits {    abstract void Color();    abstract void Flavour();}// color 颜色// flavour 气味// 苹果类class Apple extends Frits {    public void Color() {    System.out.println("红色");    }        public void Flavour() {    System.out.println("甜");}}//Banana 香蕉类//Stroe 特有储藏方法class Banana extends Frits {    //特有的方法    public void Store(){        System.out.println("储藏须知");    }    @Override    public void Color() {        System.out.println("黄色");    }         @Override    public void Flavour() {        System.out.println("香甜");        Store();    }}//Pack -水果包装类//describe -水果描述//getMessage -返回具体信息class Pack {    private Frits frits;    public void setFrits(Frits frits) {        this.frits = frits;    }         void getMessage() {        frits.Color();        frits.Flavour();    }}//buyer 买家-/具体场景class Buyer {    public static void main(String[] args) {        Pack pack = new Pack();        pack.setFrits(new Apple());        pack.getMessage();        pack.setFrits(new Banana());        pack.getMessage();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>里式替换原则通俗来说，子类可以扩展父类的功能，但不能改变父类原有的功能：</p><ul><li>子类可以实现父类的抽象，但是不能覆盖父类的非抽象方法</li><li>子类中可以增加自己特有的方法。</li><li>当子类的方法重载父类的方法时，方法的前置条件要比父类方法的输入更宽松。</li><li>当子类的方法实现父类的抽象方法时，方法的后置条件要比父类更严格。</li></ul><h3 id="4-依赖倒置原则"><a href="#4-依赖倒置原则" class="headerlink" title="4. 依赖倒置原则"></a>4. 依赖倒置原则</h3><p><strong>高层模块(调用端)不应该依赖底层模块，两者都应该依赖于抽象。抽象不应该依赖于细节(实现类),细节应该依赖于抽象。</strong></p><p>在Java中，抽象指接口或者抽象类，两者都是不能直接被实例化；细节就是实现类，实现接口或者继承抽象类而产生的就是细节，也就是可以加上一个关键字 new 产生的对象。高层模块就是调用端，低层模块就是具体实现类。 依赖倒置原则在 java 中的表现就是，模块间的依赖通过抽象发生，实现类之间不发生直接依赖关系，其依赖关系就是通过接口或者抽象类产生的。如果类与类直接依赖细节，那么就会直接耦合。如此一来，就会同时修改依赖者代码，这样限制了可扩展性。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Cat {    void Cry() {        System.out.println("喵喵");    }}class Dog {    void Cry() {        System.out.println("旺旺");    }}class Animal {    void Cry(Cat cat, Dog dog) {        cat.Cry();        dog.Cry();    }}class Test{    public static void main(String[] args) {        new Animal().Cry(new Cat(),new Dog());    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面这个代码看起来没什么问题，可是如果我们还有别的动物子类时，就又要去更改 Animal类，将其对象作为参数传入Cry方法。而依赖倒置原则 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系。</p><p>而我们上面这个Demo已经违背了这个原则，下面我们对它进行修改：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">interface Dongwu{    void Cry();}class Cat implements Dongwu{    public void Cry() {        System.out.println("喵喵");    }}class Dog implements Dongwu{    public void Cry() {        System.out.println("旺旺");    }}class Animal {    Dongwu dongwu;    public void setDongwu(Dongwu dongwu) {    this.dongwu = dongwu;} void Cry() {   dongwu.Cry();}}class Test{    public static void main(String[] args) {        Animal animal=new Animal();                animal.setDongwu(new Dog());        animal.Cry();        animal.setDongwu(new Cat());        animal.Cry();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们增加了一个接口，里面有一个动物的叫声方法，然后让动物类们实现这个接口，然后通过set方法传递依赖对象，这样，如果我们再新增别的动物类，只需要实现相应的接口，而无需再更改我们的管理类 Animal。</p><h3 id="5-迪米特原则"><a href="#5-迪米特原则" class="headerlink" title="5. 迪米特原则"></a>5. 迪米特原则</h3><p><strong>一个软件实体应当少的与其他实体发生相互作用。</strong></p><p>这也被称最好知识原则。如果一个系统符合迪米特原则，那么当其中某一个模块发生修改时，就会尽量少的影响其他模块。迪米特原则要求我们在设计系统是，应该尽量减少对象之间的交互。如果两个对象之间不必彼此直接通向，那么这两个对象就不应当发生任何直接的相互作用。如果其中的一个对象需要调用另一个对象的某一个方法，则可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。在将迪米特原则运用到系统设计中时，要注意以下几点：</p><ul><li>在类的划分上，应当尽量创建松耦合的类。类之间的耦合越低，就越有利于复用。一个处在松耦合中的类一旦被修改，则不会对关联的类造成太大波及。</li><li>在类的结构上，每一个类都应当尽量降低其成员变量和成员函数的访问权限。</li><li>在对其他类的引用上，一个对象对其他对象的引用应当降到最低。</li></ul><p> <strong>举个例子:</strong></p><p>就像租房子一样，我叫老王，准备租房子，然后找中介，中介和房东谈价格，我们和中介谈价格，如果我们想自己和房东联系，这种事情肯定是要通过中介介绍了，或者别的途径。</p><p><strong>代码实现如下：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//租房者：老王类//inform 通知方法class LaoWang {    private Zhongjie zhongjie;    public Zhongjie getZhongjie(){    return zhongjie;}public void setZhongjie(Zhongjie zhongjie) {    this.zhongjie = zhongjie;}    public void inform(){        zhongjie.inform();    }}//中介类//inform 通知方法//setLandlord 接收房东消息class Zhongjie{    public void inform(){        System.out.println("通知房东");    }    public   void getLanged(){        new Landlord().inform();    }}//房东类//inform 通知方法class Landlord{    public void inform(){        System.out.println("收到，可以租");    }}class Renting{    public static void main(String[] args) {        LaoWang laoWang=new LaoWang();        //老王通知中介        laoWang.inform();        //传入房东对象        laoWang.setZhongjie(new Zhongjie());        //由中介去通知房东        laoWang.getZhongjie().inform();        //接收房东消息        laoWang.getZhongjie().getLanged();    }} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，老王和房东之间就没有任何联系，避免了耦合度过高。</p><p>我们还可以将上面的Demo再次更改，相当和依赖倒转原则结合。因为一般租房会看好多房子，所以房东也各不相同，这时候就可以将房东抽成一个抽象类，具体的房东实现房东抽象方法即可，这样的方式，和老王通信的就是房东的抽象父类，和具体房东没有关系。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract class Lease {    abstract void inform();}//租房者：老王类//inform 通知方法class LaoWang {    private Zhongjie zhongjie;    private Lease lease;    public void setLease(Lease lease) {    this.lease = lease;} public void setZhongjie(Zhongjie zhongjie) {    this.zhongjie = zhongjie;} public void inform() {    zhongjie.inform();    lease.inform();}}//中介类//inform 通知方法class Zhongjie {    public void inform() {        System.out.println("通知房东");    }}//Landlord_X 房东X//inform 通知方法class Landlord_X extends Lease {    public void inform() {        System.out.println("收到，可以租");    }}class Renting{    public static void main(String[] args) {        LaoWang laoWang=new LaoWang();        laoWang.setLease(new Landlord_X());        laoWang.setZhongjie(new Zhongjie());        laoWang.inform();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-接口隔离原则"><a href="#6-接口隔离原则" class="headerlink" title="6. 接口隔离原则"></a>6. 接口隔离原则</h3><p><strong>一个类对另一个类的依赖应该建立在最小的接口上</strong></p><p>建立单一接口，不要建立庞大臃肿的接口：尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图建立一个一个很庞大的接口供所有依赖他的类调用。采取接口隔离原则对接口进行约束时，要注意以下几点：</p><ul><li>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计的灵活性；但是如果过小，则会造成接口数量过多，使设计复杂化。所以，一定要适度。</li><li>为依赖接口的类定制服务，只暴露给调用的类他需要的方法，他不需要的方法则隐藏起来，只有专注的为一个模块提供定制服务，才能建立最小的依赖关系。</li><li>为提高内聚，减少对外交互。接口方法尽量少用public 修饰。接口是对外的承诺，承诺越少对系统的开发越有利，变更的风险也越少。</li></ul><p><strong>案例分析：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//color 颜色//taste 口感//hardness 硬度// small气味interface Frits {    void color();    void taste();    void hardness();    void small();}class apple implements Frits{ @Override public void color() {  }  @Override public void taste() {  }  @Override public void hardness() { }  @Override public void small() {  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义了一个水果接口，里面有水果的各项方法，如果我们还有别的方法，那么这个接口必然会受到多次修改。所以我们可以对其进行分隔，比如外观为一类，内在为一类，结果如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//Facade 外观interface Facade {     void color();     void hardness();}//Inherent 内在interface Inherent {    void taste();    void small();}class banana implements Facade,Inherent{    @Override    public void taste() {        } @Overridepublic void small() { } @Overridepublic void color() { } @Overridepublic void hardness() { }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接口是我们设计时对外提供的契约，通过分散定义多个 接口，可以预防未来变更的扩散，提高系统的灵活性和可维护性。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java设计模式  里氏替换原则</title>
      <link href="2021/031741346.html"/>
      <url>2021/031741346.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Java设计模式-里氏替换原则"><a href="#Java设计模式-里氏替换原则" class="headerlink" title="Java设计模式  里氏替换原则"></a>Java设计模式  里氏替换原则</h2><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h4><p>里氏替换原则通俗地讲就是：子类可以扩展父类的功能，但是不能修改父类原有的功能。也就是说子类继承父类的时候，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p><p>如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方可能会出现错误。例如继承类重写了基类的某个方法，在程序中通过基类访问继承类的方法，但是继承类重写的方法与基类中该方法的行为不一致。解决方法就是解除原来的继承关系，重新设计他们的关系。</p><h4 id="2-主要思想"><a href="#2-主要思想" class="headerlink" title="2. 主要思想"></a>2. 主要思想</h4><p>里氏替换原则的<strong>主要思想</strong>是：继承必须确保超类所拥有的性质在子类中仍然成立。</p><h4 id="3-原则"><a href="#3-原则" class="headerlink" title="3. 原则"></a>3. 原则</h4><p>里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，里氏替换原则是继承复用的基础，它反映了基类和子类的关系。</p><h4 id="4-作用"><a href="#4-作用" class="headerlink" title="4. 作用"></a>4. 作用</h4><p>里氏替换原则的<strong>作用</strong>：</p><ul><li>克服了继承中重写父类造成的可复用性变差的缺点。</li><li>保证了动作的正确性。即类的扩展不会给已有的系统引入新的错误。</li></ul><h4 id="5-案例分析"><a href="#5-案例分析" class="headerlink" title="5. 案例分析"></a>5. 案例分析</h4><h5 id="5-1-错误示范"><a href="#5-1-错误示范" class="headerlink" title="5.1 错误示范"></a>5.1 错误示范</h5><p>下面通过“鸵鸟不会飞”的例子来具体理解里氏替换原则。鸵鸟虽然属于鸟类，但是不能飞，只能跑。</p><p><strong>图示：</strong></p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/JavaDesignPatternsLSP.png"></p><p><strong>代码如下：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//鸟类class Bird {    private double flySpeed;    public void setFlySpeed(double speed) {        flySpeed = speed;    }    public double getFlyTime(double distance) {        return distance / flySpeed;    }}//燕子类class Swallow extends Bird {   }//鸵鸟类class Ostrich extends Bird{    //由于鸵鸟不能飞行，因此我们需要重写setSpeed方法，将飞行速度设置为0。    public void setSpeed(double speed)    {           flySpeed=0;    }}//测试类public class Test {    public static void main(String[] args) {        Bird swallow = new Swallow();        Bird ostrich = new Ostrich();        swallow.setFlySpeed(120);        ostrich.setFlySpeed(120);        System.out.println(swallow.getFlyTime(300));        System.out.println(ostrich.getFlyTime(300));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">2.5编译报错<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>程序运行不符合预期的原因是违背了里氏替换原则，正确的做法应该是取消几维鸟原来的继承关系，定义鸟和几维鸟更一般的父类，如动物类。</p><h5 id="5-2-修改为正确方式"><a href="#5-2-修改为正确方式" class="headerlink" title="5.2 修改为正确方式"></a>5.2 修改为正确方式</h5><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/JavaDesignPatternsLSP2.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 继承 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础语法  三大特性之一——多态</title>
      <link href="2021/03151649.html"/>
      <url>2021/03151649.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java基础语法-三大特性之一——多态"><a href="#Java基础语法-三大特性之一——多态" class="headerlink" title="Java基础语法  三大特性之一——多态"></a>Java基础语法  三大特性之一——多态</h2><h4 id="1-多态的概念"><a href="#1-多态的概念" class="headerlink" title="1. 多态的概念"></a>1. 多态的概念</h4><p>多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</p><p>很多初学者往往在理解多态上会比较吃力，甚至误解成重载，多态不是方法的重载，不是方法名一样方法的参数不一样，不是一个参数有多种形式就称之为多态，那是不正确的，如果这就是多态的话那么何必有方法的重载？直接改名多态就行了。父类 a = 子类对象 就是子类对象可以披上父类的衣服，只要穿上了父类的衣服就装扮成了父类 可以做父类的一些事情灵活性强。多态最重要的目的就是为了让子类转换成父类。</p><p>举个例子：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/JavaPolymorphism.png"></p><h4 id="2-多态存在的三个必要条件"><a href="#2-多态存在的三个必要条件" class="headerlink" title="2. 多态存在的三个必要条件"></a>2. 多态存在的三个必要条件</h4><ul><li>继承</li><li>重写</li><li>父类的引用指向子类的对象：<strong>Parent p = new Child();</strong></li></ul><h4 id="3-案例分析"><a href="#3-案例分析" class="headerlink" title="3. 案例分析"></a>3. 案例分析</h4><p>下面通过一个例子，让我们更好地理解多态这个概念。</p><p>假如你是一个女人，对化妆品情有独钟。某日去商场发现有几个店铺里面都有你想要的一款口红，从外面看我们是不可能知道这些点分别卖的价格是多少，只有进去问了之后才能得到口红的价格。于是你开始逐一进店，第一个店卖100、第二个店卖150、第三个店卖200….在这里我们可以描述成如下：</p><p>​                                店1 = 100  –&gt;  Store1 = 100；</p><p>​                                店2 = 150  –&gt;  Store2 = 150；</p><p>​                                店3 = 200  –&gt;  Store3 = 200；</p><p>​                                ……</p><p> 这里所表现的的就是多态。店铺1、店铺2、店铺3都是商场的子类，我们只是通过商场这一个父类就能够引用不同的子类，这就是多态——我们只有在运行的时候才会知道引用变量所指向的具体实例对象，也就是我们只有实际购买了才知道我们选的哪家店。</p><p>下面还需要大家理解一下“向上转型”，要理解多态我们就必须要明白什么是“向上转型”。什么是“向上转型”呢？它是JAVA中的一种调用方式。假如存在  <strong>B继承A</strong>，向上转型是对A的对象的方法的扩充，即A的对象可访问B从A中继承来的和B“重写”A的方法。</p><p>在上面的商铺例子中，商场（Market）是父类，店铺1（Store1）、店铺2（Store2）、店铺3（Store3）是子类。我们定义如下代码：</p><p>​                                Store1 store1 = new Store1();</p><p>对于这个代码我们非常容易理解无非就是实例化了一个商铺1的对象嘛！但是这样呢？</p><p>​                                Market market = new Store1();</p><p>在这里我们这样理解，这里定义了一个商场类型的market，它指向商铺1对象实例。由于商铺1是继承的商场，所以商铺1可以自动向上转型为商场，所以market是可以指向商铺1实例对象的。这样做存在一个非常大的好处，在继承中我们知道子类是父类的扩展，它可以提供比父类更加强大的功能，如果我们定义了一个指向子类的父类引用类型，那么它除了能够引用父类的共性外，还可以使用子类强大的功能。</p><p>但是向上转型存在一些缺憾，那就是它必定会导致一些方法和属性的丢失，而导致我们不能够获取它们。所以父类类型的引用可以调用父类中定义的所有属性和方法，对于只存在与子类中的方法和属性它就望尘莫及了。</p><p>下面我们用代码来实现一下上面的例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.wedu;//商场类class Market {    public void fun1(){        System.out.println("Market 的Fun1.....");        fun2();    }    public void fun2(){        System.out.println("Market 的Fun2...");    }}//商铺1继承商场class Store1 extends Market{        /**         * @desc 子类重载父类方法         *        父类中不存在该方法，向上转型后，父类是不能引用该方法的         * @param a         * @return void         */        public void fun1(String a){            System.out.println("Store1 的 Fun1...");            fun2();        }        /**         * 子类重写父类方法         * 指向子类的父类引用调用fun2时，必定是调用该方法         */        public void fun2(){            System.out.println("Store1 的Fun2...");        }    }//测试类class Test1 {    public static void main(String[] args) {        Market market = new Store1();        market.fun1();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">Market 的Fun.....Store1 的Fun2...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从程序的<strong>运行结果</strong>中我们发现，market.fun1()首先是运行父类Market中的fun1().然后再运行子类Store1中的fun2()。</p><p><strong>分析</strong>：在这个程序中子类Store1重载了父类Market的方法fun1()，重写fun2()，而且重载后的fun1(String a)与 fun1()不是同一个方法，由于父类中没有该方法，向上转型后会丢失该方法，所以执行Store1的Market类型引用是不能引用fun1(String a)方法的。而子类Store1重写了fun2() ，那么指向Store1的Market引用会调用Store1中fun2()方法。</p><p> <strong><em>所以对于多态我们可以总结如下：</em></strong></p><p>指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。</p><p>对于面向对象而已，多态分为编译时多态和运行时多态。其中编译时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编译之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。</p><h4 id="4-多态的实现方式"><a href="#4-多态的实现方式" class="headerlink" title="4. 多态的实现方式"></a>4. 多态的实现方式</h4><ul><li><p><strong>方式一：重写</strong></p></li><li><p><strong>方式二：接口</strong>（学习接口之后会详细解释）</p><ol><li>生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。</li><li>java中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。</li></ol></li><li><p><strong>方式三：抽象类和抽象方法</strong>（学习抽象之后会详细解释）</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础语法 </tag>
            
            <tag> 多态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础语法  三大特性之一——继承</title>
      <link href="2021/03122671.html"/>
      <url>2021/03122671.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Java基础语法-三大特性之一——继承"><a href="#Java基础语法-三大特性之一——继承" class="headerlink" title="Java基础语法  三大特性之一——继承"></a>Java基础语法  三大特性之一——继承</h2><h4 id="1、继承的概念"><a href="#1、继承的概念" class="headerlink" title="1、继承的概念"></a>1、继承的概念</h4><p>继承是Java面向对象编程的三大特征之一，也是Java编程技术的一块基石，因为它允许创建分等级层次的类，也就是说继承是子类和父类的关系。</p><p>子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例和方法，或者这样理解，子类从父类继承方法，使得子类具有父类相同的行为。往简单了说就是继承是为了重用父类代码，两个类若存在is-a的关系就可以使用继承，这样明白了吧。</p><p><strong>生活中虽处可见继承关系：</strong></p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/JavaExtends.png"></p><p>图中兔子和羊属于食草动物类，狮子和豹属于食肉动物类。食草动物和食肉动物又是属于动物类。</p><p>它们都符合：is-a，所以这就是继承的关系。</p><p>虽然食草动物和食肉动物都是属于动物，但是两者的属性和行为上有差别，所以子类会具有父类的一般特性也会具有自身的特性，这也是继承的特点之一。</p><p>下面说说继承的特点：</p><h4 id="2、继承的关键字：extends"><a href="#2、继承的关键字：extends" class="headerlink" title="2、继承的关键字：extends"></a>2、继承的关键字：extends</h4><p>　　被继承的类称为父类，又叫基类、超类；继承的类称为子类，派生类</p><h4 id="3、Java中继承的特点"><a href="#3、Java中继承的特点" class="headerlink" title="3、Java中继承的特点"></a>3、Java中继承的特点</h4><p>在java中只存在单继承，无法实现多继承，但是可以实现逐级继承。</p><p>举个例子，父亲可以继承爷爷的姓氏，我也可以继承爷爷的姓氏。代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class GrandeFather {    public String lastName="zhang";    public void printName(){        System.out.println("我姓"+this.lastName);    }}class Father extends GrandeFather{    public void printName1(){        System.out.println("我也姓"+this.lastName);    }}class Son extends Father{    public void printName2(){        System.out.println("我还姓"+this.lastName);    }}class Test{    public static void main(String[] args) {        Son son = new Son();        son.printName2();        Father father = new Father();        father.printName1();        GrandeFather grandeFather = new GrandeFather();        grandeFather.printName();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">我还姓zhang我也姓zhang我姓zhang<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="4、继承的具体表现："><a href="#4、继承的具体表现：" class="headerlink" title="4、继承的具体表现："></a>4、继承的具体表现：</h4><p>1)父类有的，子类一定有（除了私有的）；</p><p>2)父类没有的，子类可以有；</p><p>3)当父类有的，此时子类可以改（即可以重写父类的属性和方法）。</p><p>举个例子，父亲姓王，我也姓王，父亲吃饭，我也可以吃饭，父亲不抽烟，我可以抽烟，父亲喝酒，我可以喝饮料。代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Father {    public String lastName = "zhang";    public void printName(){        System.out.println("Father姓"+this.lastName);    }    public void eat(){        System.out.println("eating");    }    public void drink(){        System.out.println("Father likes to drink");    }}class Son extends Father {    public void printNameSon(){        System.out.println("我也姓"+this.lastName);    }    public void smoke(){        System.out.println("Father不抽烟，我抽");    }    public void drink() {        System.out.println("我不让他喝！");    }}class Test{    public static void main(String[] args) {        Father father = new Father();        Son son = new Son();        father.printName();//父类的方法        son.printNameSon();//子类的方法，继承父类的属性        father.eat();//父类的方法        son.eat();//子类继承父类的方法        son.smoke();//子类独有的方法        father.drink();//父类的方法        son.drink();//子类重写父类的方法    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5、为什么要用继承？"><a href="#5、为什么要用继承？" class="headerlink" title="5、为什么要用继承？"></a>5、为什么要用继承？</h4><p>学到这里，我们反思一下，为什么我们要学习继承呢？不用继承不行吗？回答是不用继承也可以。看下面的例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//父亲类class Father {    public String lastName = "zhang";    public void printName(){        System.out.println("姓"+this.lastName);    }    public void eat(){        System.out.println("吃饭");    }    public void drink(){        System.out.println("喝酒");    }}//儿子类class Son{    public String lastName = "zhang";    public void printName(){        System.out.println("姓"+this.lastName);    }    public void eat(){        System.out.println("吃饭");    }    public void drink(){        System.out.println("喝酒");    }}//测试类class Test{    public static void main(String[] args) {        Father father = new Father();        Son son = new Son();        father.printName();        son.printName();        father.eat();        son.eat();        father.drink();        son.drink();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的代码可以看出来，代码存在重复了，导致后果就是代码量大量臃肿，而且维护性不高(维护性主要是后期需要修改的时候，就需要修改很多的代码，容易出错)，所以要从根本上解决这两段代码的问题，就需要继承，将两段代码中相同的部分提取出来组成 一个父类，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//公共父类class Person {    private String name;    private int id;    public Person(String myName, int myid) {        name = myName;        id = myid;    }    public void eat(){        System.out.println(name+"正在吃");    }    public void sleep(){        System.out.println(name+"正在睡");    }    public void introduction() {        System.out.println("大家好！我是"  + id + "号" + name + ".");    }}//子类张三class ZhangSan extends Person{    public ZhangSan(String myName, int myid) {        super(myName, myid);    }}//子类李四class LiSi extends Person{    public LiSi(String myName, int myid) {        super(myName, myid);    }}//测试类class Demo{    public static void main(String[] args) {        ZhangSan zhangSan = new ZhangSan("zhangsan",1);        zhangSan.introduction();        zhangSan.eat();        zhangSan.sleep();        LiSi liSi = new LiSi("lisi",2);        liSi.introduction();        liSi.eat();        liSi.sleep();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-none"><code class="language-none">大家好！我是1号zhangsan.zhangsan正在吃zhangsan正在睡大家好！我是2号lisi.lisi正在吃lisi正在睡<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6、继承的优缺点"><a href="#6、继承的优缺点" class="headerlink" title="6、继承的优缺点"></a>6、继承的优缺点</h4><ul><li><p><strong>继承的优点：</strong></p><p>从上面的代码我们可以看得出继承的最大优点就是提高了代码的复用性，减少了代码的冗余。</p></li><li><p><strong>继承的缺点：</strong></p><p>耦合性太大；</p><p>打破封装，向子类暴露了实现细节。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础语法 </tag>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础语法  三大特性之一——封装</title>
      <link href="2021/031253566.html"/>
      <url>2021/031253566.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java基础语法-三大特性之一——封装"><a href="#Java基础语法-三大特性之一——封装" class="headerlink" title="Java基础语法  三大特性之一——封装"></a>Java基础语法  三大特性之一——封装</h2><p>学习Java最重要的一点就是理解Java的面向对象思想，面向对象的三大特征包括了：</p><ul><li><p><strong>封装</strong>：封装是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。</p></li><li><p><strong>继承</strong>：继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p></li><li><p><strong>多态</strong>：多态是同一个行为具有多个不同表现形式或形态的能力。</p></li></ul><p>上面的表述是官方的解释，看起来非常的生硬，对于没有基础的同学来说理解会比较吃力，下面我将用举例的方式为大家介绍这三大特性，今天先说说三大特征之一的封装。</p><p>封装是一个面向对象的术语，其含义其实很简单，就是把东西包装起来。其实成员变量和成员方法的定义都是包装于类定义之中的，类的定义可以看成是将构成类的成员变量和方法封装起来，这就是最宏观的封装。</p><p>首先我们需要知道为什么在Java开发的过程中需要<strong>封装</strong>？举个例子，人类的正常年龄不会超过200岁，但是我们在定义类的时候，如果可以直接修改类中的字段那么就可能会出现以下的情况，age可以设置成1000，这合理吗？这不合理，于是就引出了封装这个概念。</p><p>讨论到封装性，我们需要先回忆一下之前说到的访问权限修饰符，正是因为它们的存在才有了封装性：其中，private是只允许自己这个类访问，其他的类都是不可见的；public就是都可见的意思。详细的解释可以参考之前的文章<a href="https://blog.csdn.net/liulei952413829/article/details/114641913">Java基础语法  四种访问权限修饰符详细通俗的解释</a>。</p><p>在使用private修饰成员变量的时候，这个变量就相当于被封装了，因为private是私有的，不能被外界（其他类）访问。就好比我们把一个类比作是一个箱子，里面包括了很多成员变量和方法；private修饰的成员变量就只能自己这个箱子里面可见，并且可以访问修改，但是对于其他的类（箱子）就是不可见的，这就相当于完成了封装性。</p><p>下面我用代码的实际例子给大家说明一下：</p><ol><li><p>修改属性的可见性来限制对属性的访问（一般限制为private）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Person {    private String name;//私有属性    private int age;//私有属性}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码中，我把 <strong>name</strong> 和 <strong>age</strong> 属性设置为私有的，只能本类才能访问，其他类都访问不了，这样就对信息进行了隐藏。</p></li><li><p>对每个值属性提供对外的公共方法访问，也就是创建一对读写方法，用于对私有属性的访问</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Person{    private String name;//私有属性    private int age;//私有属性//给私有成员创建可读属性    public int getAge(){      return age;    }//给私有成员创建可读属性    public String getName(){      return name;    }//给私有成员创建可写属性    public void setAge(int age){      this.age = age;    }//给私有成员创建可写属性    public void setName(String name){      this.name = name;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>采用 <strong>this</strong> 关键字是为了解决<strong>实例变量</strong>和<strong>局部变量</strong>之间发生的同名冲突。以上代码中public方法是外部类访问该类成员变量的入口。</p><p>通常情况下，这些方法被称为getter和setter方法。</p></li><li><p>任何要访问类中私有成员变量的类都要通过这些getter和setter方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test{   public static void main(String args[]){      Person person = new Person();      person.setName("James");      person.setAge(20);       System.out.print("Name : " + person.getName()+ " Age : "+ person.getAge());    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果是：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Name : James Age : 20<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>除了setter方法可以对封装的属性进行赋值以外，还能通过构造方法对封装方法进行赋值</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//实体类public class Person {    private String name;//私有属性    private int age;//私有属性    //无参构造    public Test02() {    }//有参构造    public Test02(String name, int age) {        this.name = name;        this.age = age;    }//重写toString方法，方便调试    @Override    public String toString() {        return "Test02{" +                "name='" + name + '\'' +                ", age=" + age +                '}';    }}//测试类public class Test{   public static void main(String args[]){      Person person = new Person("zhangsan",20);       System.out.print(person.toString());    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">person{name='zhangsan', age=20}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过上面的例子，我们知道了封装有两个含义：<strong>把该隐藏的隐藏起来，把该暴露的暴露出来</strong>。</p></li></ol><ul><li>把字段（成员变量）和实现细节隐藏起来，不允许外部直接访问</li><li>把方法暴露出来，让方法控制这些成员变量进行安全的访问和操作</li></ul><p>封装的另外一个好处就是：<strong>避免错误提高代码的健壮性</strong>，怎么体现呢？还记得我上面说的例子吗，人类的年龄一般不会超过200岁，下面我用代码来实现这个例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Person{    private String name;//私有属性    private int age;//私有属性//给私有成员创建可写属性    public void setAge(int age) {        if (age&lt;200){            this.age = age;        }else{            System.out.println("你是忍者神龟吗？");        }    }//给私有成员创建可读属性    public int getAge() {        return age;    }}public class Test{   public static void main(String args[]){      Person person = new Person();      person.setAge(2000);       System.out.print(test02.getAge());    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">你是忍者神龟吗？0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们可以在实现封装的时候，为外界提供访问接口，然后在接口中加一些合理的条件，这样就可以保证代码的合理性和正确性。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础语法 </tag>
            
            <tag> 封装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora字体颜色设置的3种方案</title>
      <link href="2021/03115379.html"/>
      <url>2021/03115379.html</url>
      
        <content type="html"><![CDATA[<h2 id="Typora字体颜色设置的3种方案"><a href="#Typora字体颜色设置的3种方案" class="headerlink" title="Typora字体颜色设置的3种方案"></a>Typora字体颜色设置的3种方案</h2><p>Typora没有直接设置字体颜色的功能，不能像word一样，选中字体直接设置想要的颜色。</p><p>于是我在网上为大家找到了三种在Typora工具中设置字体颜色的方案。</p><p>下面第一种方法需安装软件AutoHotKey，操作起来比较简单，建议新手使用；后两种方法都是偏技术的，对于非技术的小白可能理解上或者使用时有点困难，不过问题也不大，不会的直接从下文复制到Typora使用即可，建议收藏使用！</p><h3 id="1、下载AutoHotKey（较简单）"><a href="#1、下载AutoHotKey（较简单）" class="headerlink" title="1、下载AutoHotKey（较简单）"></a>1、下载AutoHotKey（较简单）</h3><p>AutoHotKey是一款著名的windows系统快捷键设置的软件，轻便小巧。</p><p><a href="https://autohotkey.com/download/ahk-install.exe">官方下载地址</a>： <a href="https://autohotkey.com/download/ahk-install.exe">https://autohotkey.com/download/ahk-install.exe</a></p><p>使用步骤如下：</p><ul><li><p>先安装AutoHotKey</p></li><li><p>打开记事本，把下面的内容复制粘贴进去：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">;</span> Typora<span class="token punctuation">;</span> 快捷增加字体颜色<span class="token punctuation">;</span> SendInput <span class="token punctuation">{</span>Text<span class="token punctuation">}</span> 解决中文输入法问题 #IfWinActive ahk_exe Typora<span class="token punctuation">.</span>exe<span class="token punctuation">{</span>    <span class="token punctuation">;</span> Ctrl<span class="token operator">+</span>Alt<span class="token operator">+</span><span class="token constant">O</span> 橙色    <span class="token operator">^</span><span class="token operator">!</span>o<span class="token operator">:</span><span class="token operator">:</span><span class="token function">addFontColor</span><span class="token punctuation">(</span><span class="token string">"orange"</span><span class="token punctuation">)</span>     <span class="token punctuation">;</span> Ctrl<span class="token operator">+</span>Alt<span class="token operator">+</span><span class="token constant">R</span> 红色    <span class="token operator">^</span><span class="token operator">!</span>r<span class="token operator">:</span><span class="token operator">:</span><span class="token function">addFontColor</span><span class="token punctuation">(</span><span class="token string">"red"</span><span class="token punctuation">)</span>     <span class="token punctuation">;</span> Ctrl<span class="token operator">+</span>Alt<span class="token operator">+</span><span class="token constant">B</span> 浅蓝色    <span class="token operator">^</span><span class="token operator">!</span>b<span class="token operator">:</span><span class="token operator">:</span><span class="token function">addFontColor</span><span class="token punctuation">(</span><span class="token string">"cornflowerblue"</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token punctuation">;</span> 快捷增加字体颜色<span class="token function">addFontColor</span><span class="token punctuation">(</span><span class="token parameter">color</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    clipboard <span class="token operator">:</span><span class="token operator">=</span> <span class="token string">""</span> <span class="token punctuation">;</span> 清空剪切板    Send <span class="token punctuation">{</span>ctrl down<span class="token punctuation">}</span>c<span class="token punctuation">{</span>ctrl up<span class="token punctuation">}</span> <span class="token punctuation">;</span> 复制    SendInput <span class="token punctuation">{</span><span class="token constant">TEXT</span><span class="token punctuation">}</span><span class="token operator">&lt;</span>font color<span class="token operator">=</span><span class="token string">'%color%'</span><span class="token operator">&gt;</span>    SendInput <span class="token punctuation">{</span>ctrl down<span class="token punctuation">}</span>v<span class="token punctuation">{</span>ctrl up<span class="token punctuation">}</span> <span class="token punctuation">;</span> 粘贴    <span class="token function">If</span><span class="token punctuation">(</span>clipboard <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        SendInput <span class="token punctuation">{</span><span class="token constant">TEXT</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>font<span class="token operator">&gt;</span> <span class="token punctuation">;</span> Typora 在这不会自动补充    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        SendInput <span class="token punctuation">{</span><span class="token constant">TEXT</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span> <span class="token punctuation">;</span> Typora中自动补全标签    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>将文件保存为ahk后缀的文件，如AutoHotKey.ahk</p></li><li><p>双击运行</p></li><li><p>在Typora软件里就可以使用快捷键进行想要的修改操作了（想要更多的快捷键设置方式，可以在AutoHotKey.ahk文件中自行添加）：</p><p>如按 Ctrl+Alt+O 添加橙色， Ctrl+Alt+R 红色，按 Ctrl+\ 取消样式！</p></li><li><p> 也可以右键 AutoHotKey.ahk 脚本文件，点击Compile Script编译脚本成exe程序，就可以不用下载Autohotkey在其他电脑上运行了。</p></li></ul><p>提示：上面脚本只写了橙色、红色、浅蓝三种颜色，你可以按需照例增加其他颜色或快捷方式！</p><h3 id="2、进入开发者模式改html代码（懂前端技术超简单）"><a href="#2、进入开发者模式改html代码（懂前端技术超简单）" class="headerlink" title="2、进入开发者模式改html代码（懂前端技术超简单）"></a>2、进入开发者模式改html代码（懂前端技术超简单）</h3><ul><li>右键——&gt;检查元素</li><li>视图——&gt;开发者工具，打开html代码调试模式</li><li>按快捷键 Shift+F12</li></ul><p>下面给大家看一个修改案例：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>span style<span class="token operator">=</span><span class="token string">"color:文字颜色;background:背景颜色;font-size:文字大小;font-family:字体;"</span><span class="token operator">&gt;</span>你要改色的文字<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/TyporaDeveloperModeColor.png"></p><p>很明显，用这种方式进行代码的修改需要一定的前端基础，至少需要懂得一些简单的标签并记住。</p><p>不过我们也可以按照模板，修改字体的style属性即可，意思是我们想要使用这种方式的时候就查一查这篇文章，然后复制过去。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">示例：style<span class="token operator">=</span><span class="token string">"color:red"</span>style<span class="token operator">=</span><span class="token string">"color:maroon"</span>style<span class="token operator">=</span><span class="token string">"color:fuchsia"</span>style<span class="token operator">=</span><span class="token string">"color:brown"</span>style<span class="token operator">=</span><span class="token string">"color:blue"</span>style<span class="token operator">=</span><span class="token string">"color:aqua"</span>style<span class="token operator">=</span><span class="token string">"color:green"</span>style<span class="token operator">=</span><span class="token string">"color:orange"</span>style<span class="token operator">=</span><span class="token string">"color:purple"</span>style<span class="token operator">=</span><span class="token string">"color:white;background:black;"</span>style<span class="token operator">=</span><span class="token string">"background:yellow"</span>style<span class="token operator">=</span><span class="token string">"background:red"</span>style<span class="token operator">=</span><span class="token string">"background:orange"</span>style<span class="token operator">=</span><span class="token string">"color:white;background:green"</span>style<span class="token operator">=</span><span class="token string">"color:white;background:blue"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种方式还存在一个弊端，当我们用这种方式进行字体修改之后，再将文章用其他工具打开，或者发表到博客上，你就会发现你做的修改都消失了，这是因为Typora支持开发者模式用代码的方式进行元素审查，但是其他工具中并没有这个功能，那么既然没有这个载体，怎么会保留这种方式做的修改呢？</p><h3 id="3、方案三：使用内联公式（既复杂也简单）"><a href="#3、方案三：使用内联公式（既复杂也简单）" class="headerlink" title="3、方案三：使用内联公式（既复杂也简单）"></a>3、方案三：使用内联公式（既复杂也简单）</h3><p>使用步骤如下：</p><ul><li><p>开启使用内联公式</p><p>文件——&gt;偏好设置（Ctrl+逗号）——&gt;Markdown——&gt;勾选“内联公式”——&gt;重启Typora</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/TyporaInlineFormulaColor.png"></p></li><li><p>输入公式代码进行颜色修改</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">输入$，按Esc键会自动在后面加上一个$，然后在这两个$之间输入公式。     样式如下：——&gt;     $\textcolor{red}{这里输入你要改变颜色的文字}$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>颜色公式代码大全：</strong></p><pre class="line-numbers language-none"><code class="language-none">$\textcolor{GreenYellow}{GreenYellow} $$\textcolor{Yellow}{Yellow}$$\textcolor{Goldenrod}{Goldenrod} $$\textcolor{Dandelion}{Dandelion}$$\textcolor{Apricot}{Apricot} $$\textcolor{Peach}{Peach}$$\textcolor{Melon}{Melon} $$\textcolor{YellowOrange}{YellowOrange}$$\textcolor{Orange}{Orange} $$\textcolor{BurntOrange}{BurntOrange}$$\textcolor{Bittersweet}{Bittersweet}$$\textcolor{RedOrange}{RedOrange} $$\textcolor{Mahogany}{Mahogany}$$\textcolor{Maroon}{Maroon} $$\textcolor{BrickRed}{BrickRed}$$\textcolor{Red}{Red} $$\textcolor{OrangeRed}{OrangeRed}$$\textcolor{RubineRed}{RubineRed}$$\textcolor{WildStrawberry}{WildStrawberry}$$\textcolor{Salmon}{Salmon}$$\textcolor{CarnationPink}{CarnationPink}$$\textcolor{Magenta}{Magenta} $$\textcolor{VioletRed}{VioletRed}$$\textcolor{Rhodamine}{Rhodamine} $$\textcolor{Mulberry}{Mulberry}$$\textcolor{RedViolet}{RedViolet} $$\textcolor{Fuchsia}{Fuchsia}$$\textcolor{Lavender}{Lavender} $$\textcolor{Thistle}{Thistle}$$\textcolor{Orchid}{Orchid} $$\textcolor{DarkOrchid}{DarkOrchid}$$\textcolor{Purple}{Purple} $$\textcolor{Plum}{Plum}$$\textcolor{Violet}{Violet} $$\textcolor{RoyalPurple}{RoyalPurple}$$\textcolor{BlueViolet}{BlueViolet}$$\textcolor{Periwinkle}{Periwinkle}$$\textcolor{CadetBlue}{CadetBlue}$$\textcolor{CornflowerBlue}{CornflowerBlue}$$\textcolor{MidnightBlue}{MidnightBlue}$$\textcolor{NavyBlue}{NavyBlue} $$\textcolor{RoyalBlue}{RoyalBlue}$$\textcolor{Blue}{Blue} $$\textcolor{Cerulean}{Cerulean}$$\textcolor{Cyan}{Cyan} $$\textcolor{ProcessBlue}{ProcessBlue}$$\textcolor{SkyBlue}{SkyBlue} $$\textcolor{Turquoise}{Turquoise}$$\textcolor{TealBlue}{TealBlue} $$\textcolor{Aquamarine}{Aquamarine}$$\textcolor{BlueGreen}{BlueGreen} $$\textcolor{Emerald}{Emerald}$$\textcolor{JungleGreen}{JungleGreen}$$\textcolor{SeaGreen}{SeaGreen} $$\textcolor{Green}{Green}$$\textcolor{ForestGreen}{ForestGreen}$$\textcolor{PineGreen}{PineGreen} $$\textcolor{LimeGreen}{LimeGreen}$$\textcolor{YellowGreen}{YellowGreen}$$\textcolor{SpringGreen}{SpringGreen}$$\textcolor{OliveGreen}{OliveGreen}$$\textcolor{RawSienna}{RawSienna} $$\textcolor{Sepia}{Sepia}$$\textcolor{Brown}{Brown} $$\textcolor{Tan}{Tan}$$\textcolor{Gray}{Gray} $$\textcolor{Black}{Black}$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为什么说这个办法复杂呢？因为公式太多记不住，也没必要。说它简单是因为这种方式可以和上面的方式一样，复制粘贴即可使用。</p><p>有需要的小伙伴可以收藏使用，希望能帮助到大家！</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Typora </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术工具 </tag>
            
            <tag> 解决方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础语法  非访问修饰符的使用</title>
      <link href="2021/031156639.html"/>
      <url>2021/031156639.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java基础语法-非访问修饰符的使用"><a href="#Java基础语法-非访问修饰符的使用" class="headerlink" title="Java基础语法  非访问修饰符的使用"></a>Java基础语法  非访问修饰符的使用</h2><p>除了前面文章所说到的访问修饰符外，Java 还提供了许多非访问修饰符，具体如下：</p><ul><li><strong>static</strong> 修饰符，用来修饰类方法和类变量。</li><li><strong>final</strong> 修饰符，用来修饰类、方法和变量。final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量不可修改值。</li><li><strong>abstract</strong> 修饰符，用来创建抽象类和抽象方法。</li><li><strong>synchronized 和 volatile</strong> 修饰符，主要用于线程的编程。</li><li><strong>transient</strong> 修饰符，序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。</li></ul><p>根据现阶段大家的学习进度以及修饰符的使用频率，下面我将着重介绍static、final、abstract修饰符。至于线程相关修饰符，我将在大家学习到线程内容相关知识的时候为大家详细介绍。至于transient修饰符，大家知道即可，不用深入研究。</p><h4 id="1、static修饰符"><a href="#1、static修饰符" class="headerlink" title="1、static修饰符"></a>1、static修饰符</h4><ul><li><p><strong>静态变量</strong>：static修饰的类变量称为静态变量</p><p>static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</p><p>static成员变量的初始化顺序按照定义的顺序进行初始化。</p><p>静态变量也被称为类变量，在主方法里声明静态变量会报错。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/JavaStaticModifier3.png"></p><p>局部变量不能被声明为 static 变量，也就是说例如if语句、for循环里面定义的变量是不能用static修饰符修饰的。</p></li><li><p><strong>静态方法</strong>：static修饰的类方法称为静态方法</p><p>在《Java编程思想》里面有这样一段话：</p><p>$\textcolor{BlueViolet}{“static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。}$</p><p>$\textcolor{BlueViolet}{而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。”}$</p><p>这段话怎么去理解呢？这段话虽然只是说明了static方法的特殊之处，但是可以看出static关键字的基本作用，简而言之，一句话来描述就是：<strong>方便在没有创建对象的情况下来进行调用（方法/变量）</strong>。</p><p>也就是说被static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。举个简单的例子：</p></li></ul><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/JavaStaticModifier.png"></p><p>​    上面的代码中我并没有创建Demo对象，却可以直接使用Demo.age获取变量的值，通过Demo.printAge调用Demo的方法，这就是          static的特点之一。</p><p>​    static方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附    于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，    因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。</p><p>​    但是要注意的是，虽然在静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法/    变量的。举个简单的例子：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/JavaStaticModifier2.png"></p><p>​    从上面的代码可以看到，我在静态方法中打印非静态变量height，还未运行代码编译就直接报红了，再看下面，我在主函数里面通过Domo.printSex()来调用Demo的非静态方法，发现出现同样的问题，未运行代码编译就直接报红。这就说明了静态方法中不能访问非静    态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法/变量的。</p><ul><li><p><strong>static代码块</strong>：</p><p>static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。</p><p>为什么说static块可以用来优化程序性能，是因为它的特性：只会在类加载的时候执行一次。下面看个例子:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Person{    private Date birthDate;         public Person(Date birthDate) {        this.birthDate = birthDate;    }         boolean isLiulei() {        Date startDate = Date.valueOf("1946");        Date endDate = Date.valueOf("1964");        return birthDate.compareTo(startDate)&gt;=0 &amp;&amp; birthDate.compareTo(endDate) &lt; 0;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>isLiulei方法是用来说明这个人是否是1946-1964年出生的，而每次isLiulei被调用的时候，都会生成startDate和birthDate两个对象，造成了空间浪费，如果改成这样效率会更好：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Person{    private Date birthDate;    private static Date startDate,endDate;    //静态代码块    static{        startDate = Date.valueOf("1946");        endDate = Date.valueOf("1964");    }         public Person(Date birthDate) {        this.birthDate = birthDate;    }         boolean isLiulei() {        return birthDate.compareTo(startDate)&gt;=0 &amp;&amp; birthDate.compareTo(endDate) &lt; 0;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，我们在进行程序开发中，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</p></li><li><p><strong>static关键字注意点：</strong></p><ol><li>与C/C++中的static不同，Java中的static关键字不会影响到变量或者方法的作用域。在Java中能够影响到访问权限的只有private、public、protected、default这几个关键字。</li><li>静态成员变量虽然独立于对象，但是不代表不可以通过对象去访问，所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够）。</li></ol></li></ul><h4 id="2、final修饰符"><a href="#2、final修饰符" class="headerlink" title="2、final修饰符"></a>2、final修饰符</h4><p>final关键字可以用来修饰引用（变量）、方法和类。</p><ul><li><p><strong>final变量</strong></p><ol><li>final 表示”最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。</li><li>被 final 修饰的实例变量必须显式指定初始值。</li><li>final 修饰符通常和 static 修饰符一起使用来创建类常量。</li><li>如果引用为基本数据类型，则该引用为常量，该值无法修改；</li><li>如果引用为引用数据类型，比如对象、数组，则该对象、数组本身可以修改，但指向该对象或数组的地址的引用不能修改。</li><li>如果引用为类的成员变量，则必须当场赋值，否则编译会报错。</li></ol><p><strong>实例如下：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">final class Person {    String name ="zs";        //3. 此处不赋值会报错    //final int age;    final int age = 10;  }public class Demo {    public static void main(String[] args) {                //1. 基本数组类型为常量，无法修改        final int i = 9;        //i = 10;                               //2. 地址不能修改，但是对象本身的属性可以修改        Person p = new Person();        p.name = "lisi";                final int[] arr = {1,2,3,45};        arr[3] = 999;        //arr = new int[]{1,4,56,78};    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>final方法</strong></p><p> 当使用final修饰方法时，这个方法将成为最终方法，无法被子类重写。但是，该方法仍然可以被继承。</p><p>声明 final 方法的主要目的是防止该方法的内容被修改。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Person {    public final void say() {        System.out.println("说....");    }    public void eat() {        System.out.println("吃...");    }}class Teacher extends Person {    //1. final修饰的方法不能被重写，但此方法仍然被继承    /*@Override    public void say() {        System.out.println("老师在一本正经的说...");    }*/        public void eat() {        System.out.println("老师在大口大口的吃...");    }}public class Demo02 {    public static void main(String[] args) {        Teacher t = new Teacher();        t.say();    }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码，我在主方法里创建的是Teacher对象，调用的是Person中定义的say()方法，说明final修饰的方法被继承了。</p></li><li><p><strong>final类</strong></p><p>当用final修饰类时，该类成为最终类，无法被继承。简称为“断子绝孙类”。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/*** * final修饰类，则该类成为最终类，无法被继承 * @author Administrator */final class Person{    }class Teacher extends Person { }//编译报错class MyString extends String{ }//String类为最终类无法被继承，编译报错<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3、abstract修饰符"><a href="#3、abstract修饰符" class="headerlink" title="3、abstract修饰符"></a>3、abstract修饰符</h4></li></ul><p><strong>abstract</strong> 修饰符，用来创建抽象类和抽象方法，也就是说<strong>abstract</strong> 修饰的类似抽象类，<strong>abstract</strong> 修饰的方法即抽象方法。</p><p>说到抽象，想必大家第一个联想到的就是抽象画，基本上看不懂画的是啥，只能说它在表达某个概念。在Java中我们使用abstract关键字来表达抽象。</p><p>学习abstract修饰的抽象之前，先举个例子：</p><p>我们说车子都可以跑(run)。但有几个轮子，怎么跑，对于不同的车有不同的结果。自行车需要人踩着跑，汽车发动机推动跑等等，那么我们可以车表达为抽象类。代码实现如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * 抽象类：abstract修饰车子类 */public abstract class Car {    //抽象方法：abstract修饰run()方法public abstract void run();}/** * 自行车 */class Bicycle extends Car{    //重写run()方法@Overridepublic void run() {System.out.println("人踩着跑。。。");}}/*** * 汽车 */class Automobile extends Car{//重写run()方法@Overridepublic void run() {System.out.println("发动机驱动跑。。。");}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假如后面各种车，它们倒着跑、悬在空中跑，随它怎么跑，只需要继承抽象类实现自己的功能就行了。相信说到这里大家对抽象已有一个初步的印象了吧。</p><ul><li><p><strong>抽象方法：</strong></p><p>1、从上面的例子中我们可以看到抽象方法跟普通方法是有区别的，它没有自己的方法主体（没有{ }包起来的业务逻辑），跟接口中的方法有点类似。所以我们没法直接调用抽象方法。</p><p>2、抽象方法不能用private修饰，因为抽象方法必须被子类实现（覆写），而private权限对于子类来说是不能访问的，所以就会产生矛盾。</p><p>3、抽象方法也不能用static修饰，试想一下，如果用static修饰了，那么我们可以直接通过类名调用，而抽象方法压根就没有主体，没有任何业务逻辑，这样就毫无意义了。</p></li><li><p><strong>抽象类：</strong></p><p>1、用abstract关键字来表达的类，其表达形式为：（public）abstract class 类名{ }。</p><p>2、抽象类不能被实例化，也就是说我们没法直接new 一个抽象类。<strong>抽象类本身就代表了一个类型，无法确定为一个具体的对象</strong>，所以不能实例化就合乎情理了，只能用它的继承类实例化。</p><p>3、抽象类虽然不能被实例化，但有自己的构造方法（这个后面再讨论）。</p><p>4、抽象类与接口（interface）有很大的不同之处，接口中不能有实例方法去实现业务逻辑，而抽象类中可以有实例方法，并实现业务逻辑，比如我们可以在抽象类中创建和销毁一个线程池。</p><p>5、抽象类不能使用final关键字修饰，因为final修饰的类无法被继承，而对于抽象类来说就是需要通过继承去实现抽象方法，这又会产生矛盾。</p></li><li><p><strong>抽象类与抽象方法的关联：</strong></p><p>1、如果一个类中至少有一个抽象方法，那么这个类一定是抽象类，但反之则不然。也就是说一个抽象类中可以没有抽象方法。这样做的目的是为了此类不能被实例化。</p><p>2、如果一个类继承了一个抽象类，那么它必须全部覆写抽象类中的抽象方法，当然也可以不全部覆写，如果不覆写全部抽象方法则这个子类也必须是抽象类（这样做就无意义了）    </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract class Car {public void mothod1(){        }public abstract void mothod2();public abstract void method3();}class Bicycle extends Car{@Overridepublic void mothod2() {//需要覆写抽象方法mothod2}@Overridepublic void method3() {//需要覆写抽象方法mothod3}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>抽象类的构造器：</strong></p><p>先来看一个例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract class Car {Car(){System.out.println("抽象方法无参构造函数");}    Car(String a){System.out.println("抽象有参构造方法");}    public void mothod1(){System.out.println(this.getClass());System.out.println("抽象类的实例方法");}public abstract void mothod2();}/** * 自行车*/class Bicycle extends Car{Bicycle(){   System.out.println("子类无参构造函数");   }   @Override   public void mothod2() {//需要覆写抽象方法mothod2      }}   /**另一个包的测试类**/public class Test {public static void main(String[] args) {   Bicycle b = new Bicycle();        b.mothod1();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">运行结果：抽象方法无参构造函数子类无参构造函数class com.wedu.Bicycle抽象类的实例方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的例子中可以看出：</p><p>1、抽象类是有构造方法的（当然如果我们不写，编译器会自动默认一个无参构造方法）。而且从结果来看，和普通的继承类一样，在new 一个子类对象时会优先调用父类（这里指的是抽象类Car）的构造器初始化，然后再调用子类的构造器。至此相信大家都会有这样一个疑问，为什么抽象方法不能实例化却有构造器呢？ 对于这个问题网上也中说纷纭，没有确定答案。</p><p>我是这样想的：既然它也属于继承的范畴，那么当子类创建对象时必然要优先初始化父类的属性变量和实例方法，不然子类怎么继承和调用呢？而它本身不能实例化，因为它本身就是不确定的一个对象，如果它能被实例化，那么我们通过它的对象来调用它本身的抽象方法是不是有问题。所以不能实例化有在情理之中。如果实在理解不了就记住这个规定就行。</p><p>2、对于抽象类中的非statci(静态)和非abstract(抽象)方法中的this关键字（静态方法中不能有关键字this之前已经讨论过）代表的是它的继承类，而非抽象类本身，这个好理解，因为抽象类本身不能被实例化。如果有多个继承类，谁调用this就代表谁。</p></li></ul><p>抽象类有什么好处呢？<br>1、由于抽象类不能被实例化，最大的好处就是通过方法的覆盖来实现多态的属性。<br>2、抽象类将事物的共性的东西提取出来，由子类继承去实现，代码易扩展、易维护。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础语法 </tag>
            
            <tag> 变量 </tag>
            
            <tag> 修饰符 </tag>
            
            <tag> 类 </tag>
            
            <tag> 方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础语法  四种访问权限修饰符详细通俗的解释</title>
      <link href="2021/03101548.html"/>
      <url>2021/03101548.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java基础语法-四种访问权限修饰符详细通俗的解释"><a href="#Java基础语法-四种访问权限修饰符详细通俗的解释" class="headerlink" title="Java基础语法  四种访问权限修饰符详细通俗的解释"></a>Java基础语法  四种访问权限修饰符详细通俗的解释</h2><p>Java语言提供了很多类型的修饰符，主要分为以下两类：</p><ul><li>访问修饰符</li><li>非访问修饰符</li></ul><p>修饰符的作用主要是定义类、方法或者变量，通常会放在代码的最前端。例如下面的代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//定义类public class Test{//public    //定义变量    private int a;//private    public static final int BOX=40;//public static final    static final int weeks=7;//default static final    protected double b = 2.0;//protected    //定义方法    public void Method(){//public        ...    }    public static void main(String[] args){//public static        ...    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上面的Test类我们可以看到，使用修饰符可以让成员变量得到不同程度的访问控制。由此可得我们可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限，分别是：</p><ul><li><p><strong>public</strong> : 意为公开的，访问权限最高，可以跨包访问。</p><ol><li>使用对象：类、接口、变量、方法。</li><li>当public用来修饰类中的成员即变量和方法时，那么被public修饰的成员可以在不同包中、相同包中、子类中都能访问到。当前类可以直接访问，不同包的类则只要通过该类的对象进行访问便可以。就像空气，不管是人还是动物、植物都可以访问。</li><li>在类的继承上，被public修饰的成员能被所有的子类继承下来，就是你以后建的房子，花园，可以被你的子孙都继承下来。</li></ol></li><li><p><strong>protected</strong> : 意为受保护的，权限次之，可以在同包和子/父类中访问。</p><ol><li>使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong>。</li><li><strong>子类与基类在同一包中</strong>：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问；</li><li><strong>子类与基类不在同一包中</strong>：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。</li><li>protected修饰的变量和方法在同一个package（包）中的时候，则同一个包中的所有<br>类都可以访问到，<strong>包括该类的子类也可以访问，不管子类是否和父类在同一个包</strong>。就是说你<br>收藏的祖传宝贝，只要是你的子孙，不管他现在是和你住得近，还是住得比较远，他们都可以<br>访问你收藏的祖传宝贝。</li><li>同时呢，被protected修饰的成员是可以被该类的子类继承下去的，和上面那个例子意思<br>差不多。</li></ol><p>$ \textcolor{red}{注意：接口及接口的成员变量和成员方法不能声明为 protected。}$</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/JavaProtectedAuthority.png"></p></li><li><p><strong>default（缺省、friendly）</strong>: 意为默认的，<strong>一般不写</strong>，权限次之，可以在同包中访问。那么就是在相同的包里面，所有的类都能访问，但是在不同的包中，即使是子类中也不可以访问，也就是说只有在同一个包中的子类才能访问到父类中default修饰的成员。就像你收藏的宝贝，一个子孙孝顺，在你旁边一直照顾你，一个子孙不孝顺，很多年都不回来看望，那就不友好了，对吧，所以即使是你的子孙，也不能访问你收藏的宝贝。</p><ol><li>使用对象：类、接口、变量、方法。</li><li>接口里的变量都隐式声明为 <strong>public static final</strong>；</li><li>而接口里的方法默认情况下访问权限为 <strong>public</strong>。</li><li>在类的继承上呢，被<strong>default</strong>修饰的成员也<strong>只能被该类所在同一个包的子类继承下来</strong>，也<br>就是说只有孝顺的才可以继承宝贝。</li></ol></li><li><p><strong>private</strong> : 意为私有的，权限最低，只能在本类中访问。</p><p>使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong></p><ol><li>私有访问修饰符是最严格的访问级别，所以被声明为 <strong>private</strong> 的方法、变量和构造方法只能被所属类访问。</li><li>声明为私有访问类型的变量只能通过类中公共的 getter 方法被外部类访问，通过setter方法访问变量值。</li><li>Private 访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。</li><li>在类的继承上呢，子类是继承不了父类被private修饰的变量的，就像你的眼睛、鼻子、耳朵<br>是你私有的，你只能自己使用，是不可以继承给你子孙的。</li></ol><p>$\textcolor{Red}{注意：类和接口不能声明为 private。} $</p></li></ul><p>在上一篇文章中（<a href="https://blog.csdn.net/liulei952413829/article/details/114627652?spm=1001.2014.3001.5501">Java基础语法 属性与字段的区别</a>）我们介绍到，实体类中的字段和常量描述了类的数据（域），当这些数据的某些部分不允许外界访问时，根据 “对象封装” 的原则，应尽量避免将一个类型的字段以公有方式提供给外部。<strong>除了final修饰的常量</strong>，一般将其设置为private类型。<strong>所以，为了保证安全性，一般把实体类的成员变量访问权限降到最低。</strong></p><p>我们可以通过以下表来说明访问权限：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/JavaAccessPermission.png"></p><p>配合下图一起理解，就能轻松记住各个修饰符的访问权限了。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/JavaAccessModifier.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础语法 </tag>
            
            <tag> 多态 </tag>
            
            <tag> 封装 </tag>
            
            <tag> 继承 </tag>
            
            <tag> 修饰符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础语法  属性与字段的区别</title>
      <link href="2021/03106686.html"/>
      <url>2021/03106686.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java基础语法-属性与字段的区别"><a href="#Java基础语法-属性与字段的区别" class="headerlink" title="Java基础语法  属性与字段的区别"></a>Java基础语法  属性与字段的区别</h2><p>如果你遇到的是这样一道面试题：<strong>Java中的属性和字段有什么区别？</strong> </p><p>那么你可以这样回答：Java中的属性(property)，通常可以理解为get和set方法。</p><p>而字段(field)，通常叫做“类成员”，或 “类成员变量”，有时也叫“域”，理解为“数据成员”，用来承载数据的。这两个概念是完全不同的。</p><p>虽然答案有了，但是你理解了多少呢？</p><h4 id="1、什么是字段？"><a href="#1、什么是字段？" class="headerlink" title="1、什么是字段？"></a>1、什么是字段？</h4><p>类成员(字段)，通常是在类中定义的类成员变量，例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class A{  private String s = "123";}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>从上面的代码中我们可以看到，<strong>A类中有一个成员变量叫做s，也可以这样说：A类有一个字段s</strong>。</p><ul><li>字段一般用来承载数据，所以为了安全性，一般定义为私有的。</li><li>字段和常量描述了类的数据（域），当这些数据的某些部分不允许外界访问时，根据 “对象封装” 的原则，应尽量避免将一个类型的字段以公有方式提供给外部。<strong>除了final修饰的常量</strong>。一般将其设置为private类型。</li></ul><p>既然是私有，那外界怎么访问呢? 当然是通过Java的属性方法了！</p><h4 id="2、什么是属性？"><a href="#2、什么是属性？" class="headerlink" title="2、什么是属性？"></a>2、什么是属性？</h4><p>属性只局限于类中方法的声明，并不与类中其他成员相关，属于JavaBean的范畴。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">void setA(String s){}String getA(){}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当一个类中拥有这样一对方法时，我们可以说，**这个类中拥有一个可读写的a属性(注意是小写a)**。如果去掉了set的方法，则是可读属性，反之亦然。</p><p> 其规则是：去掉get或set后其剩余的字符串，如果第二个字母是小写的，则把第一个字母也变成小写，例如： </p><pre class="line-numbers language-text" data-language="text"><code class="language-text">getAge----&gt;age getCPU----&gt;CPU <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>比如有下面这个类: </p><p>注：下面的User类不是JavaBean。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class User {    private String id; //私有字段    private String name; //私有字段    private String identifier = "440282199008098076"; //私有字段    public String getId() { //id的可读属性        return id;    }    public void setId(String id) { //id的可写属性        this.id = id;    }    public String getName() { //name的可读属性        return name;    }    public void setName(String name) { //name的可写属性        this.name = name;    }    public String getIdentifier() { //identifier只有一个get方法，所以它是只读属性        return identifier;    }    public final static Integer SHOW_STATUS_YES = 1; //公共字段    public final static Integer SHOW_STATUS_No = 0; //公共字段}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>当我操作这个类时，比如调用getName()方法时，我们做的操作是获得name的属性，调用setName(String name)方法时做的操作是设置name的属性，因为对我们来说name字段是私有的，我们操作该Person类时根本看不到有这个name字段 。</p></li><li><p><strong><em>一个类主要包括字段、属性和方法。属性在此时指的就是get/set访问器</em></strong>。</p></li><li><p>同时我们可以看到，这个类有3个属性，5个字段。</p><ul><li>SHOW_STATUS_YES 为公用字段，一般修饰为 final  static类型，可以通过User类直接访问该字段。</li><li>getIdentifier为只读属性，只能读取私有的identifier字段，这样就起到了保护数据的安全性的作用。</li><li>id和name为私有字段，且有两个操作他们的public属性。可以通过 getId()、setId( String id)、getName()、setName( String name)来读取和设置他们的值。</li></ul></li><li><p>更形象的说就是：属性是对字段的封装，供外部访问。</p></li><li><p>通常属性将相应的私有字段通过封装成公共属性，以便于外界访问和修改。当然你在封装成属性时，也可以置该属性为只读，可读写等等权限。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test {    private int a = 5;//字段a，定义字段是直接赋值，没有属性set/get    private int b;//字段b，没有属性set/get    public Test(){        this.b=10;//通过构造器为字段b赋值    }    public void print(){//定义方法        System.out.println(a+"-----"+b);    }}class Test2{    public static void main(String[] args) {        Test test = new Test();//创建对象        test.print();//调用方法        test.a=10;//修改Test类中private修饰的字段a的值        System.out.println(test.a);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码由于Test类中 a 字段是private修饰的私有成员，没有为 a 变量创建set/get属性，所以Test类外，无法访问字段 a ，也就是说无法读写字段 a ，所以上诉代码运行报错。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/JavaPropertyAndField.png"></p></li></ul><h4 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h4><ul><li>区别开属性与字段是为了更好的实现数据安全，比如当我们想给一个类的属性赋值或者其他类用到了，就需要将这个字段设置为public，然而这样可以对字段进行任意的读写操作，非常不利于数据安全。于是就加上了属性，简单说属性实现了字段的封装，属性有get、set 方法来控制字段，该字段的属性只有set方法没有get方法，就只可以对该方法进行赋值操作，没有读操作，反之亦然。</li><li>可以创建属性，将字段和属性封装在一起。通过属性可以像访问字段一样访问数据成员，实现数据的封装，避免使用非法数据赋值，保证数据完整性，同时类内部发生修改时，避免整个程序的修改。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础语法 </tag>
            
            <tag> 属性 </tag>
            
            <tag> 字段 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础语法  重新认识类和对象</title>
      <link href="2021/031036289.html"/>
      <url>2021/031036289.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java基础语法-重新认识类和对象"><a href="#Java基础语法-重新认识类和对象" class="headerlink" title="Java基础语法  重新认识类和对象"></a>Java基础语法  重新认识类和对象</h2><p>一个 Java 程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同工作。下面简要介绍下类、对象、方法和实例变量的概念。</p><ul><li><p><strong>对象</strong>：对象是类的一个实例（<strong>对象不是找个女朋友</strong>），有状态和行为。例如：一条狗是一个对象</p><p>它的状态有：颜色、名字、品种；</p><p>它的行为有：摇尾巴、叫、吃等。</p></li><li><p><strong>类</strong>：类是一个模板，它描述一类对象的行为和状态。</p></li><li><p><strong>方法</strong>：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。</p></li><li><p><strong>实例变量</strong>：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。</p></li></ul><p>下图中<strong>鞋</strong>为一个<strong>类</strong>，具体的每种类型的鞋是<strong>鞋类</strong>的<strong>对象</strong>：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/JavaClassAndObject01.png"></p><h3 id="1、Java中的对象"><a href="#1、Java中的对象" class="headerlink" title="1、Java中的对象"></a>1、Java中的对象</h3><p>现在让我们深入了解什么是对象。看看周围真实的世界，会发现身边有很多对象，比如车子，房子，人等等。而这些<strong>所有的对象都有自己的状态和行为</strong>。</p><p>拿一条狗来举例，它的状态有：名字、品种、颜色；行为有：叫、摇尾巴和跑。</p><p>对比现实对象和软件对象，它们之间十分相似。</p><p><strong>软件对象</strong>也有状态和行为，软件对象的状态就是属性，行为通过方法体现。</p><p>在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。</p><h3 id="2、Java中的类"><a href="#2、Java中的类" class="headerlink" title="2、Java中的类"></a>2、Java中的类</h3><p>Java中的类可以看成是创建对象的模板。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/JavaClassAndObject02.png"></p><p>通过上图创建一个简单的类来理解下 Java 中类的定义，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Dog {    String breed;    int size;    String colour;    int age; //吃饭    void eat() {    } //跑    void run() {    } //睡觉    void sleep(){    } //命名    void name(){    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>①一个类可以包含以下类型变量（**<em>关于类型变量的介绍将会放在下一篇文章介绍**</em>）：</p><ul><li><strong>局部变量</strong>：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li><li><strong>成员变量</strong>：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li><li><strong>类变量</strong>：类变量也声明在类中，方法体之外，但必须声明为 static 类型。</li></ul><p>②一个类可以拥有多个方法，在上面的例子中：eat()、run()、sleep() 和 name() 都是 Dog 类的方法。</p><p>那么java中一个具体的方法有哪些重要的部分组成呢？下面链接的文章做出了详细的介绍！</p><p><a href="https://blog.csdn.net/liulei952413829/article/details/114627652?spm=1001.2014.3001.5501">Java基础语法 类、方法、函数的区别</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础语法 </tag>
            
            <tag> 类 </tag>
            
            <tag> 对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora换行继承上一行格式的解决方案</title>
      <link href="2021/031036659.html"/>
      <url>2021/031036659.html</url>
      
        <content type="html"><![CDATA[<h2 id="Typora换行继承上一行格式的解决方案"><a href="#Typora换行继承上一行格式的解决方案" class="headerlink" title="Typora换行继承上一行格式的解决方案"></a>Typora换行继承上一行格式的解决方案</h2><p>刚开始使用Typora的初级开发者都会遇到下面这样的简单问题：</p><p>就是换行会自动继承上面的格式，按删除键和回退键以及多次换行都无效。</p><p>情况如下图所示：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/TyporaNewlineFormat.png"></p><p>次问题的解决方案如下：</p><ul><li><p>Mac OS 按下<strong>command+[</strong> </p></li><li><p>windows 的按键是<strong>ctrl+[</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Typora </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术工具 </tag>
            
            <tag> 解决方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础语法  局部变量、成员变量、类变量三者的定义</title>
      <link href="2021/030930900.html"/>
      <url>2021/030930900.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java基础语法-局部变量、成员变量、类变量三者的定义"><a href="#Java基础语法-局部变量、成员变量、类变量三者的定义" class="headerlink" title="Java基础语法  局部变量、成员变量、类变量三者的定义"></a>Java基础语法  局部变量、成员变量、类变量三者的定义</h2><p>在Java语言中，所有的变量在使用前必须声明。以下列出了一些变量的声明实例。注意有些包含了初始化过程。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int a, b, c;     // 声明三个int型整数：a、 b、c int d = 3, e = 4, f = 5; // 声明三个整数并赋予初值 byte z = 22;     // 声明并初始化 z String s = "runoob";  // 声明并初始化字符串 s double pi = 3.14159; // 声明了双精度浮点型变量 pi char x = 'x';    // 声明变量 x 的值是字符 'x'。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Java语言支持的变量类型有：</p><ul><li><strong>类变量（静态变量）</strong>：类变量也声明在类中，方法体之外，但必须声明为 static 类型。</li><li><strong>实例变量（成员变量）</strong>：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li><li><strong>局部变量</strong>：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li></ul><p><strong><em>实例如下：</em></strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Variable{    static int allClicks=0;    // 类变量         String str="hello world";  // 变量         public void method(){                 int i =0;  // 局部变量         } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1、局部变量"><a href="#1、局部变量" class="headerlink" title="1、局部变量"></a>1、局部变量</h3><ul><li><p>局部变量声明在方法、构造方法或者语句块中；</p></li><li><p>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；</p></li><li><p>访问修饰符不能用于局部变量；</p></li><li><p>局部变量只在声明它的方法、构造方法或者语句块中可见；</p></li><li><p>局部变量是在栈上分配的；</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/JavaLocalVariable.png"></p></li><li><p>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用；</p></li><li><p><strong><em>注意：局部变量如果创建的时候没有初始化，则使用时会报“Initialize variable”的错误。</em></strong></p></li></ul><p><strong><em>实例 1 如下：</em></strong></p><p>在以下实例中age是一个局部变量。定义在pupAge()方法中，它的作用域就限制在这个方法中。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> public class Test{        public void pupAge(){              int age = 0;              age = age + 7;              System.out.println("小狗的年龄是: " + age);       }          public static void main(String[] args){              Test test = new Test();              test.pupAge();       } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上实例编译运行结果如下:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">小狗的年龄是: 7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong><em>实例 2 如下：</em></strong></p><p>在下面的例子中 age 变量没有初始化，所以在编译时会出错：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test{        public void pupAge(){              int age;              age = age + 7;              System.out.println("小狗的年龄是 : " + age);       }          public static void main(String[] args){              Test test = new Test();              test.pupAge();       } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上实例编译运行结果如下:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Test.java:4:variable number might not have been initializedage = age + 7;         ^1 error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、实例变量（成员变量）"><a href="#2、实例变量（成员变量）" class="headerlink" title="2、实例变量（成员变量）"></a>2、实例变量（成员变量）</h3><ul><li><p>变量声明在一个类中，但在方法、构造方法和语句块之外；</p></li><li><p>当一个对象被实例化之后，每个实例变量的值就跟着被确定了；</p></li><li><p>实例变量在对象创建的时候创建，在对象被销毁的时候销毁；</p></li><li><p>实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；</p></li><li><p>实例变量可以声明在使用前或者使用后；</p></li><li><p>访问修饰符可以修饰实例变量；</p></li><li><p>实例变量对于类中的方法、构造方法或者语句块是可见的。**<em>一般情况下应该把实例变量设为私有**</em>。</p><p>通过使用访问修饰符可以使实例变量对子类可见；</p></li><li><p>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。</p><p>变量的值可以在声明时指定，也可以在构造方法中指定；</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test{    //方式一：声明变量时指定值    private int a=5;    private int b;    //方式二：构造器中指定值    public Test(){        this.b = 10;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。</p></li></ul><p><strong><em>实例如下：</em></strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Employee{       // 这个实例变量对子类可见       public String name;       // 私有变量，仅在该类可见       private double salary;       //在构造器中对name赋值       public Employee (String empName){              name = empName;       }       //设定salary的值       public void setSalary(double empSal){              salary = empSal;       }         // 打印信息       public void printEmp(){              System.out.println("名字 : " + name );              System.out.println("薪水 : " + salary);       }        public static void main(String[] args){              //创建对象        Employee empOne = new Employee("RUNOOB");              //调用方法        empOne.setSalary(1000.0);              empOne.printEmp();       } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上实例编译运行结果如下:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">名字 : RUNOOB薪水 : 1000.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3、类变量（静态变量）"><a href="#3、类变量（静态变量）" class="headerlink" title="3、类变量（静态变量）"></a>3、类变量（静态变量）</h3><ul><li>类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。</li><li>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。</li><li>静态变量除了被声明为常量外很少使用，静态变量是指声明为 public/private，final 和 static 类型的变量。**<em>静态变量初始化后不可改变**</em>。</li><li>静态变量储存在静态存储区。**<em>经常被声明为常量**</em>，很少单独使用 static 声明变量。</li><li>静态变量在第一次被访问时创建，在程序结束时销毁。</li><li>与实例变量具有相似的可见性。但为了对类的使用者可见，**<em>大多数静态变量声明为 public 类型**</em>。</li><li>默认值和实例变量相似。数值型变量默认值是 0，布尔型默认值是 false，引用类型默认值是 null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</li><li>静态变量可以通过：<em>ClassName.VariableName</em>的方式访问。</li><li>类变量被声明为 public static final 类型时，类变量名称一般建议使用大写字母。如果静态变量不是 public 和 final 类型，其命名方式与实例变量以及局部变量的命名方式一致。</li></ul><p><strong><em>实例如下：</em></strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Employee {        //salary是静态的私有变量        private static double salary;        // DEPARTMENT是一个常量        public static final String DEPARTMENT = "开发人员";        public static void main(String[] args){            salary = 10000;                System.out.println(DEPARTMENT+"平均工资:"+salary);        } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上实例编译运行结果如下:</p><pre class="line-numbers language-none"><code class="language-none">开发人员平均工资:10000.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注意：如果其他类想要访问该变量，可以这样访问：Employee.DEPARTMENT</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础语法 </tag>
            
            <tag> 变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础语法  类、方法、函数的区别</title>
      <link href="2021/030953989.html"/>
      <url>2021/030953989.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java基础语法-类、方法、函数的区别"><a href="#Java基础语法-类、方法、函数的区别" class="headerlink" title="Java基础语法  类、方法、函数的区别"></a>Java基础语法  类、方法、函数的区别</h2><p>学习了<strong>C语言</strong>或者**C++**的程序员在转向Java语言的时候，或者初学Java的大众，往往会出现下面的疑问：</p><ul><li>java中 类, 方法, 函数 有什么区别？</li><li>含有 class 的就是类吗？ 含有 （）的就是函数吗? 那么怎么表示方法呢？</li><li>函数、方法和类都可以调用吗？ 三者具体有点什么区别呢？</li></ul><p>下面将通过对方法的定义和使用的介绍，逐步对这些问题作出解答：</p><h3 id="1、方法的概念"><a href="#1、方法的概念" class="headerlink" title="1、方法的概念"></a>1、方法的概念</h3><p>Java语言中的<strong>“方法”（Method）</strong>在其他语言当中也可能被称为<strong>“函数”（Function）</strong>。</p><p>对于一些复杂的代码逻辑，如果希望重复使用这些代码，并且做到“随时任意使用”，那么就可以将这些代码放在一个大括号“{}”当中，并且起一个名字。使用代码的时候，直接找到名字调用即可。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//外部的类public class Test{    /**    *被调用的方法Add    *@param x    *@param y    *@return    */    public int Add(int x,int y){        return x+y;    }}//调用public class HelloWord {    public static void main(String[] args) {        int a=5;        int b=a+1;        int result=0;        //Add方法调用：第一步，类的实例化        Test test=new Test();           //第二步，通过实例化的类进行Add方法调用        result=test.Add(a, b);           }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是一个方法的所有组成部分：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">访问修饰符  返回值类型  方法名（参数列表）{方法体}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li><strong>访问修饰符</strong>：方法允许被访问的权限范围， 可以是 public、protected、private 甚至可以省略 ，其中 public 表示该方法可以被其他任何代码调用，其他几种修饰符的使用在后面章节中会详细讲解滴。</li><li><strong>返回值类型</strong>：方法返回值的类型，如果方法不返回任何值，则返回值类型指定为 void ；如果方法具有返回值，则需要指定返回值的类型，并且在方法体中使用 return 语句返回具体的值。</li><li><strong>方法名</strong>：定义的方法的名字，必须使用合法的标识符。</li><li><strong>参数列表</strong>：传递给方法的参数列表，参数可以有多个，多个参数间以逗号隔开，每个参数由参数类型和参数名组成，以空格隔开。</li></ol><p>根据方法是否带参、是否带返回值，可将方法分为四类：</p><ul><li>无参无返回值方法</li><li>无参带返回值方法</li><li>带参无返回值方法</li><li>带参带返回值方法</li></ul><h3 id="2、Java中的类、方法、函数"><a href="#2、Java中的类、方法、函数" class="headerlink" title="2、Java中的类、方法、函数"></a>2、Java中的类、方法、函数</h3><ul><li><p><strong>类</strong>就是指一个种类，比如人，是一个类，动物也是一个类等等，但是如果特指是某个人，比如张三，那么这就是指定的实体。<br>在Java中，类的定义是 : &lt; class&gt; &lt;类名&gt; ,通常我们在 Java 中提到 class ，就是指类的意思，下面的代码就是一个类的简单定义。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test(){    ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>在 Java中，<strong>方法</strong>与<strong>函数</strong>其实是一样的，只是在C语言中我们习惯叫函数，而在Java中我们习惯叫方法，不管怎么叫，都是指同一个意思。**<em>方法（或函数，为了方便，下面我都说方法 ） 必须在类中**</em>。</p><p>方法的定义 ：&lt;修饰符&gt;&lt;返回值&gt;&lt;方法名&gt; (&lt;参数类型&gt; &lt;参数名&gt;){…..}，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test(){    public void Method(int x){        ...    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通常你看到一个带（）的代码，基本就是指代一个方法；例如: a.XXX()，是指调用实体 a的XXX()方法。</p></li><li><p><strong><em>类可以拥有属性和方法，方法需要定义在类中</em></strong>。在类或方法中创建某个类的实体，可以调用类的方法。</p></li><li><p>程序运行时，首先是从main()方法开始运行的，main()函数必须放在跟你文件名同名的类中，</p><p>注意：一个class文件中只能有一个mian()方法，否则在编译运行的时候会出错。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础语法 </tag>
            
            <tag> 类 </tag>
            
            <tag> 方法 </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021Java最新面试题独家整理</title>
      <link href="2021/020251304.html"/>
      <url>2021/020251304.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="2-JVM"><a href="#2-JVM" class="headerlink" title="2. JVM"></a><strong>2. JVM</strong></h2><p>(1) 基本概念：</p><p>JVM 是可运行 Java 代码的假想计算机 ，包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收，堆 和 一个存储方法域。JVM 是运行在操作系统之上的，它与硬件没有直接的交互。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/JVMconcept.png"></p><p>(2) 运行过程：</p><p>我们都知道 Java 源文件，通过编译器，能够生产相应的.Class 文件，也就是字节码文件，而字节码文件又通过 Java 虚拟机中的解释器，编译成特定机器上的机器码 。也就是如下：</p><p>① Java 源文件—-&gt;编译器—-&gt;字节码文件</p><p>② 字节码文件—-&gt;JVM—-&gt;机器码</p><p>每一种平台的解释器是不同的，但是实现的虚拟机是相同的，这也就是 Java 为什么能够跨平台的原因了 ，当一个程序从开始运行，这时虚拟机就开始实例化了，多个程序启动就会存在多个虚拟机实例。程序退出或者关闭，则虚拟机实例消亡，多个虚拟机实例之间数据不能共享。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/JVM.png"></p><h3 id="2-1-线程"><a href="#2-1-线程" class="headerlink" title="2.1 线程"></a>2.1 线程</h3><p>这里所说的线程指程序执行过程中的一个线程实体。JVM 允许一个应用并发执行多个线程。Hotspot JVM 中的 Java 线程与原生操作系统线程有直接的映射关系。当线程本地存储、缓冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统原生线程。</p><p>Java 线程结束，原生线程随之被回收。操作系统负责调度所有线程，并把它们分配到任何可用的 CPU 上。当原生线程初始化完毕，就会调用 Java 线程的 run() 方法。当线程结束时，会释放原生线程和 Java 线程的所有资源。</p><table><thead><tr><th></th><th>Hotspot JVM 后台运行的系统线程主要有下面几个：</th></tr></thead><tbody><tr><td>虚拟机线程（VM thread）</td><td>这个线程等待 JVM 到达安全点操作出现。这些操作必须要在独立的线程里执行，因为当堆修改无法进行时，线程都需要 JVM 位于安全点。这些操作的类型有：stop-the-world 垃圾回收、线程栈 dump、线程暂停、线程偏向锁（biased locking）解除。</td></tr><tr><td>周期性任务线程</td><td>这线程负责定时器事件（也就是中断），用来调度周期性操作的执行。</td></tr><tr><td>GC 线程</td><td>这些线程支持 JVM 中不同的垃圾回收活动。</td></tr><tr><td>编译器线程</td><td>这些线程在运行时将字节码动态编译成本地平台相关的机器码。</td></tr><tr><td>信号分发线程</td><td>这个线程接收发送到 JVM 的信号并调用适当的 JVM 方法处理。</td></tr></tbody></table><h3 id="2-2-JVM内存区域"><a href="#2-2-JVM内存区域" class="headerlink" title="2.2 JVM内存区域"></a>2.2 JVM内存区域</h3><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/JVMmemory.png"></p><p>JVM 内存区域主要分为线程私有区域【程序计数器、虚拟机栈、本地方法区】、线程共享区域【JAVA 堆、方法区】、直接内存。</p><p>线程私有数据区域生命周期与线程相同, 依赖用户线程的启动/结束 而 创建/销毁(在 HotspotVM 内, 每个线程都与操作系统的本地线程直接映射, 因此这部分内存区域的存/否跟随本地线程的生/死对应)。</p><p>线程共享区域随虚拟机的启动/关闭而创建/销毁。</p><p>直接内存并不是 JVM 运行时数据区的一部分, 但也会被频繁的使用: 在 JDK 1.4 引入的 NIO 提供了基于 Channel 与 Buffer 的 IO 方式, 它可以使用 Native 函数库直接分配堆外内存, 然后使用DirectByteBuffer 对象作为这块内存的引用进行操作(详见: Java I/O 扩展), 这样就避免了在 Java堆和 Native 堆中来回复制数据, 因此在一些场景中可以显著提高性能。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/JVMmemory2.png"></p><h4 id="2-2-1-程序计数器-线程私有"><a href="#2-2-1-程序计数器-线程私有" class="headerlink" title="2.2.1 程序计数器(线程私有)"></a>2.2.1 程序计数器(线程私有)</h4><p>一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有”的内存。</p><p>正在执行 java 方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址）。如果还是 Native 方法，则为空。</p><p>这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的区域。</p><h4 id="2-2-2-虚拟机栈-线程私有"><a href="#2-2-2-虚拟机栈-线程私有" class="headerlink" title="2.2.2 虚拟机栈(线程私有)"></a>2.2.2 虚拟机栈(线程私有)</h4><p>是描述java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><p>栈帧（ Frame）是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接(Dynamic Linking)、 方法返回值和异常分派（ Dispatch Exception）。栈帧随着方法调用而创建，随着方法结束而销毁——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/JVMmemory3.png"></p><h4 id="2-2-3-本地方法区-线程私有"><a href="#2-2-3-本地方法区-线程私有" class="headerlink" title="2.2.3 本地方法区(线程私有)"></a>2.2.3 本地方法区(线程私有)</h4><p>本地方法区和 Java Stack 作用类似, 区别是虚拟机栈为执行 Java 方法服务, 而本地方法栈则为Native 方法服务, 如果一个 VM 实现使用 C-linkage 模型来支持 Native 调用, 那么该栈将会是一个C 栈，但 HotSpot VM 直接就把本地方法栈和虚拟机栈合二为一。</p><h4 id="2-2-4-堆（Heap-线程共享）-运行时数据区"><a href="#2-2-4-堆（Heap-线程共享）-运行时数据区" class="headerlink" title="2.2.4 堆（Heap-线程共享）-运行时数据区"></a>2.2.4 堆（Heap-线程共享）-运行时数据区</h4><p>是被线程共享的一块内存区域，创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域。由于现代 VM 采用<strong>分代收集算法</strong>, 因此 Java 堆从 GC 的角度还可以细分为: <strong>新生代</strong>(<em>Eden 区</em>、<em>From Survivor 区</em>和 <em>To Survivor 区</em>)和<strong>老年代。</strong></p><h4 id="2-2-5-方法区-永久代（线程共享）"><a href="#2-2-5-方法区-永久代（线程共享）" class="headerlink" title="2.2.5 方法区/永久代（线程共享）"></a>2.2.5 方法区/永久代（线程共享）</h4><p>即我们常说的<strong>永久代(Permanent Generation)</strong>, 用于存储<strong>被 JVM 加载的类信息</strong>、<strong>常量</strong>、<strong>静态变量</strong>、<strong>即时编译器编译后的代码</strong>等数据. HotSpot VM把GC分代收集扩展至方法区, 即<strong>使用Java堆的永久代来实现方法区</strong>, 这样 HotSpot 的垃圾收集器就可以像管理 Java 堆一样管理这部分内存, 而不必为方法区开发专门的内存管理器(永久带的内存回收的主要目标是针对<strong>常量池的回收</strong>和<strong>类型的卸载</strong>, 因此收益一般很小)。</p><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 Java 虚拟机对 Class 文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。</p><h3 id="2-3-JVM运行时内存"><a href="#2-3-JVM运行时内存" class="headerlink" title="2.3 JVM运行时内存"></a>2.3 JVM运行时内存</h3><p>Java 堆从 GC 的角度还可以细分为: <strong>新生代</strong>(<em>Eden 区</em>、<em>From Survivor 区</em>和 <em>To Survivor 区</em>)和<strong>老年代。</strong></p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/JVMmemory4.png"></p><h4 id="2-3-1-新生代"><a href="#2-3-1-新生代" class="headerlink" title="2.3.1 新生代"></a>2.3.1 新生代</h4><p>是用来存放新生的对象。一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁触发MinorGC 进行垃圾回收。新生代又分为 Eden 区、ServivorFrom、ServivorTo 三个区。</p><h5 id="2-3-1-1-Eden-区"><a href="#2-3-1-1-Eden-区" class="headerlink" title="2.3.1.1 Eden 区"></a>2.3.1.1 Eden 区</h5><p>Java 新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当 Eden 区内存不够的时候就会触发 MinorGC，对新生代区进行一次垃圾回收。</p><h5 id="2-3-1-2-ServivorFrom"><a href="#2-3-1-2-ServivorFrom" class="headerlink" title="2.3.1.2 ServivorFrom"></a>2.3.1.2 ServivorFrom</h5><p>上一次 GC 的幸存者，作为这一次 GC 的被扫描者。</p><h5 id="2-3-1-3-ServivorTo"><a href="#2-3-1-3-ServivorTo" class="headerlink" title="2.3.1.3 ServivorTo"></a>2.3.1.3 ServivorTo</h5><p>保留了一次 MinorGC 过程中的幸存者。</p><h5 id="2-3-1-4-MinorGC-的过程（复制-gt-清空-gt-互换）"><a href="#2-3-1-4-MinorGC-的过程（复制-gt-清空-gt-互换）" class="headerlink" title="2.3.1.4 MinorGC 的过程（复制->清空->互换）"></a>2.3.1.4 MinorGC 的过程（复制-&gt;清空-&gt;互换）</h5><p>MinorGC 采用复制算法。</p><p><strong>1：eden、servicorFrom复制到ServicorTo，年龄+1</strong></p><p>首先，把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域（如果有对象的年龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果 ServicorTo 不够位置了就放到老年区）；</p><p><strong>2：清空 eden、servicorFrom</strong></p><p>然后，清空 Eden 和 ServicorFrom 中的对象；</p><p><strong>3：ServicorTo和ServicorFrom互换</strong></p><p>最后，ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 ServicorFrom区。</p><h4 id="2-3-2-老年代"><a href="#2-3-2-老年代" class="headerlink" title="2.3.2 老年代"></a>2.3.2 老年代</h4><p>主要存放应用程序中生命周期长的内存对象。</p><p> 老年代的对象比较稳定，所以 MajorGC 不会频繁执行。在进行 MajorGC 前一般都先进行了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。</p><p> MajorGC 采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC 的耗时比较长，因为要扫描再回收。MajorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出OOM（Out of Memory）异常。</p><h4 id="2-3-3-永久代"><a href="#2-3-3-永久代" class="headerlink" title="2.3.3 永久代"></a>2.3.3 永久代</h4><p>指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息,Class 在被加载的时候被放入永久区域，它和和存放实例的区域不同,GC 不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常。</p><h5 id="2-3-3-1-JAVA8-与元数据"><a href="#2-3-3-1-JAVA8-与元数据" class="headerlink" title="2.3.3.1 JAVA8 与元数据"></a>2.3.3.1 JAVA8 与元数据</h5><p>在 Java8 中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。元空间的本质和永久代类似，元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入 native memory, 字符串池和类的静态变量放入 java 堆中，这样可以加载多少类的元数据就不再由MaxPermSize 控制, 而由系统的实际可用空间来控制。</p><h3 id="2-4-垃圾回收与算法"><a href="#2-4-垃圾回收与算法" class="headerlink" title="2.4 垃圾回收与算法"></a>2.4 垃圾回收与算法</h3><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/JVMGC.png"></p><h4 id="2-4-1-如何确定垃圾"><a href="#2-4-1-如何确定垃圾" class="headerlink" title="2.4.1 如何确定垃圾"></a>2.4.1 如何确定垃圾</h4><h5 id="2-4-1-1-引用计数法"><a href="#2-4-1-1-引用计数法" class="headerlink" title="2.4.1.1 引用计数法"></a>2.4.1.1 引用计数法</h5><p>在 Java 中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收。简单说，即一个对象如果没有任何与之关联的引用，即他们的引用计数都不为 0，则说明对象不太可能再被用到，那么这个对象就是可回收对象。</p><h5 id="2-4-1-2-可达性分析"><a href="#2-4-1-2-可达性分析" class="headerlink" title="2.4.1.2 可达性分析"></a>2.4.1.2 可达性分析</h5><p>为了解决引用计数法的循环引用问题，Java 使用了可达性分析的方法。通过一系列的“GC roots”对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。要注意的是，不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。</p><h4 id="2-4-2-标记清除算法（Mark-Sweep）"><a href="#2-4-2-标记清除算法（Mark-Sweep）" class="headerlink" title="2.4.2 标记清除算法（Mark-Sweep）"></a>2.4.2 标记清除算法（Mark-Sweep）</h4><p>最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。如图</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/Mark-Sweep.png"></p><p>从图中我们就可以发现，该算法最大的问题是内存碎片化严重，后续可能发生大对象不能找到可利用空间的问题。</p><h4 id="2-4-3-复制算法（copying）"><a href="#2-4-3-复制算法（copying）" class="headerlink" title="2.4.3 复制算法（copying）"></a>2.4.3 复制算法（copying）</h4><p>为了解决 Mark-Sweep 算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉，如图：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/copying.png"></p><p>这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原本的一半。且存活对象增多的话，Copying 算法的效率会大大降低。</p><h4 id="2-4-4-标记整理算法-Mark-Compact"><a href="#2-4-4-标记整理算法-Mark-Compact" class="headerlink" title="2.4.4 标记整理算法(Mark-Compact)"></a>2.4.4 标记整理算法(Mark-Compact)</h4><p>结合了以上两个算法，为了避免缺陷而提出。标记阶段和 Mark-Sweep 算法相同，标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。如图：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/Mark-Compact.png"></p><h4 id="2-4-5-分代收集算法"><a href="#2-4-5-分代收集算法" class="headerlink" title="2.4.5 分代收集算法"></a>2.4.5 分代收集算法</h4><p>分代收集法是目前大部分 JVM 所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将 GC 堆划分为老生代(Tenured/Old Generation)和新生代(Young Generation)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。</p><h5 id="2-4-5-1-新生代与复制算法"><a href="#2-4-5-1-新生代与复制算法" class="headerlink" title="2.4.5.1 新生代与复制算法"></a>2.4.5.1 新生代与复制算法</h5><p>目前大部分 JVM 的 GC 对于新生代都采取 Copying 算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照 1：1 来划分新生代。一般将新生代划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/Survivor.png"></p><h5 id="2-4-5-2-老年代与标记复制算法"><a href="#2-4-5-2-老年代与标记复制算法" class="headerlink" title="2.4.5.2 老年代与标记复制算法"></a>2.4.5.2 老年代与标记复制算法</h5><p>而老年代因为每次只回收少量对象，因而采用 Mark-Compact 算法。</p><ol><li><p>JAVA 虚拟机提到过的处于方法区的永生代(Permanet Generation)，它用来存储 class 类，常量，方法描述等。对永生代的回收主要包括废弃常量和无用的类。</p></li><li><p>对象的内存分配主要在新生代的 Eden Space 和 Survivor Space 的 From Space(Survivor 目前存放对象的那一块)，少数情况会直接分配到老生代。</p></li><li><p>当新生代的 Eden Space 和 From Space 空间不足时就会发生一次 GC，进行 GC 后，Eden Space 和 From Space 区的存活对象会被挪到 To Space，然后将 Eden Space 和 From Space 进行清理。</p></li><li><p>如果 To Space 无法足够存储某个对象，则将这个对象存储到老生代。</p></li><li><p>在进行 GC 后，使用的便是 Eden Space 和 To Space 了，如此反复循环。</p></li><li><p>当对象在 Survivor 区躲过一次 GC 后，其年龄就会+1。默认情况下年龄到达 15 的对象会被移到老生代中。</p></li></ol><h3 id="2-5-JAVA四中引用类型"><a href="#2-5-JAVA四中引用类型" class="headerlink" title="2.5 JAVA四中引用类型"></a>2.5 JAVA四中引用类型</h3><h4 id="2-5-1-强引用"><a href="#2-5-1-强引用" class="headerlink" title="2.5.1 强引用"></a>2.5.1 强引用</h4><p>在 Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到 JVM 也不会回收。因此强引用是造成 Java 内存泄漏的主要原因之一。</p><h4 id="2-5-2-软引用"><a href="#2-5-2-软引用" class="headerlink" title="2.5.2 软引用"></a>2.5.2 软引用</h4><p>软引用需要用 SoftRefernce 类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。</p><h4 id="2-5-3-弱引用"><a href="#2-5-3-弱引用" class="headerlink" title="2.5.3 弱引用"></a>2.5.3 弱引用</h4><p>弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。</p><h4 id="2-5-4-虚引用"><a href="#2-5-4-虚引用" class="headerlink" title="2.5.4 虚引用"></a>2.5.4 虚引用</h4><p>虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态。</p><h3 id="2-6-GC-分代收集算法-VS-分区收集算法"><a href="#2-6-GC-分代收集算法-VS-分区收集算法" class="headerlink" title="2.6 GC 分代收集算法 VS 分区收集算法"></a>2.6 GC 分代收集算法 <strong>VS</strong> 分区收集算法</h3><h4 id="2-6-1-分代收集算法"><a href="#2-6-1-分代收集算法" class="headerlink" title="2.6.1 分代收集算法"></a>2.6.1 分代收集算法</h4><p>当前主流 VM 垃圾收集都采用”分代收集”(Generational Collection)算法, 这种算法会根据对象存活周期的不同将内存划分为几块, 如 JVM 中的 新生代、老年代、永久代，这样就可以根据各年代特点分别采用最适当的 GC 算法。</p><h5 id="2-6-1-1-在新生代-复制算法"><a href="#2-6-1-1-在新生代-复制算法" class="headerlink" title="2.6.1.1 在新生代-复制算法"></a>2.6.1.1 在新生代-复制算法</h5><p>每次垃圾收集都能发现大批对象已死, 只有少量存活. 因此选用复制算法, 只需要付出少量存活对象的复制成本就可以完成收集。</p><h5 id="2-6-1-2-在老年代-标记整理算法"><a href="#2-6-1-2-在老年代-标记整理算法" class="headerlink" title="2.6.1.2 在老年代-标记整理算法"></a>2.6.1.2 在老年代-标记整理算法</h5><p>因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记—清理”或“标记—整理”算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存。</p><h4 id="2-6-2-分区收集算法"><a href="#2-6-2-分区收集算法" class="headerlink" title="2.6.2 分区收集算法"></a>2.6.2 分区收集算法</h4><p>分区算法则将整个堆空间划分为连续的不同小区间, 每个小区间独立使用, 独立回收。这样做的好处是可以控制一次回收多少个小区间 , 根据目标停顿时间, 每次合理地回收若干个小区间(而不是整个堆), 从而减少一次 GC 所产生的停顿。</p><h3 id="2-7-GC垃圾收集器"><a href="#2-7-GC垃圾收集器" class="headerlink" title="2.7 GC垃圾收集器"></a>2.7 GC垃圾收集器</h3><p>Java 堆内存被划分为新生代和年老代两部分，新生代主要使用复制和标记-清除垃圾回收算法；年老代主要使用标记-整理垃圾回收算法，因此 java 虚拟中针对新生代和年老代分别提供了多种不同的垃圾收集器，JDK1.6 中 Sun HotSpot 虚拟机的垃圾收集器如下：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/GCGarbageCollection.png"></p><h4 id="2-7-1-Serial-垃圾收集器（单线程、复制算法）"><a href="#2-7-1-Serial-垃圾收集器（单线程、复制算法）" class="headerlink" title="2.7.1 Serial 垃圾收集器（单线程、复制算法）"></a>2.7.1 Serial 垃圾收集器（单线程、复制算法）</h4><p>Serial（英文连续）是最基本垃圾收集器，使用复制算法，曾经是JDK1.3.1 之前新生代唯一的垃圾收集器。Serial 是一个单线程的收集器，它不但只会使用一个 CPU 或一条线程去完成垃圾收集工作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。</p><p>Serial 垃圾收集器虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，对于限定单个 CPU 环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率，因此 Serial垃圾收集器依然是 java 虚拟机运行在 Client 模式下默认的新生代垃圾收集器。</p><h4 id="2-7-2-ParNew-垃圾收集器（Serial-多线程）"><a href="#2-7-2-ParNew-垃圾收集器（Serial-多线程）" class="headerlink" title="2.7.2 ParNew 垃圾收集器（Serial+多线程）"></a>2.7.2 ParNew 垃圾收集器（Serial+多线程）</h4><p>ParNew 垃圾收集器其实是 Serial 收集器的多线程版本，也使用复制算法，除了使用多线程进行垃圾收集之外，其余的行为和 Serial 收集器完全一样，ParNew 垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。</p><p>ParNew 收集器默认开启和 CPU 数目相同的线程数，可以通过-XX:ParallelGCThreads 参数来限制垃圾收集器的线程数。【Parallel：平行的】</p><p>ParNew虽然是除了多线程外和Serial 收集器几乎完全一样，但是ParNew垃圾收集器是很多 java虚拟机运行在 Server 模式下新生代的默认垃圾收集器。</p><h4 id="2-7-3-Parallel-Scavenge-收集器（多线程复制算法、高效）"><a href="#2-7-3-Parallel-Scavenge-收集器（多线程复制算法、高效）" class="headerlink" title="2.7.3 Parallel Scavenge 收集器（多线程复制算法、高效）"></a>2.7.3 Parallel Scavenge 收集器（多线程复制算法、高效）</h4><p>Parallel Scavenge 收集器也是一个新生代垃圾收集器，同样使用复制算法，也是一个多线程的垃圾收集器，它重点关注的是程序达到一个可控制的吞吐量（Thoughput，CPU 用于运行用户代码的时间/CPU 总消耗时间，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)），高吞吐量可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适用于在后台运算而不需要太多交互的任务。自适应调节策略也是 ParallelScavenge 收集器与 ParNew 收集器的一个重要区别。</p><h4 id="2-7-4-Serial-Old收集器（单线程标记整理算法-）"><a href="#2-7-4-Serial-Old收集器（单线程标记整理算法-）" class="headerlink" title="2.7.4 Serial Old收集器（单线程标记整理算法 ）"></a>2.7.4 Serial Old收集器（单线程标记整理算法 ）</h4><p>Serial Old 是 Serial 垃圾收集器年老代版本，它同样是个单线程的收集器，使用标记-整理算法，这个收集器也主要是运行在 Client 默认的 java 虚拟机默认的年老代垃圾收集器。 在 Server 模式下，主要有两个用途：</p><ol><li><p>在 JDK1.5 之前版本中与新生代的 Parallel Scavenge 收集器搭配使用。</p></li><li><p>作为年老代中使用 CMS 收集器的后备垃圾收集方案。</p><p>新生代 Serial 与年老代 Serial Old 搭配垃圾收集过程图：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/SerialOld.png"></p></li></ol><p>新生代 Parallel Scavenge 收集器与 ParNew 收集器工作原理类似，都是多线程的收集器，都使用的是复制算法，在垃圾收集过程中都需要暂停所有的工作线程。新生代 Parallel Scavenge/ParNew 与年老代 Serial Old 搭配垃圾收集过程图：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/SerialOld2.png"></p><h4 id="2-7-5-Parallel-Old-收集器（多线程标记整理算法）"><a href="#2-7-5-Parallel-Old-收集器（多线程标记整理算法）" class="headerlink" title="2.7.5 Parallel Old 收集器（多线程标记整理算法）"></a>2.7.5 Parallel Old 收集器（多线程标记整理算法）</h4><p>Parallel Old 收集器是Parallel Scavenge的年老代版本，使用多线程的标记-整理算法，在 JDK1.6才开始提供。</p><p>在 JDK1.6 之前，新生代使用 ParallelScavenge 收集器只能搭配年老代的 Serial Old 收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量，Parallel Old 正是为了在年老代同样提供吞吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，可以优先考虑新生代 Parallel Scavenge和年老代 Parallel Old 收集器的搭配策略。</p><p>新生代 Parallel Scavenge 和年老代 Parallel Old 收集器搭配运行过程图：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/ParallelOld.png"></p><h4 id="2-7-6-CMS收集器（多线程标记清除算法）"><a href="#2-7-6-CMS收集器（多线程标记清除算法）" class="headerlink" title="2.7.6 CMS收集器（多线程标记清除算法）"></a>2.7.6 CMS收集器（多线程标记清除算法）</h4><p>Concurrent mark sweep(CMS)收集器是一种年老代垃圾收集器，其最主要目标是获取最短垃圾回收停顿时间，和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。</p><p>最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。</p><p><strong>CMS 工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下 4 个阶段：</strong></p><h5 id="2-7-6-1-初始标记"><a href="#2-7-6-1-初始标记" class="headerlink" title="2.7.6.1 初始标记"></a>2.7.6.1 初始标记</h5><p>只是标记一下 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。</p><h5 id="2-7-6-2-并发标记"><a href="#2-7-6-2-并发标记" class="headerlink" title="2.7.6.2 并发标记"></a>2.7.6.2 并发标记</h5><p>进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程。</p><h5 id="2-7-6-3-重新标记"><a href="#2-7-6-3-重新标记" class="headerlink" title="2.7.6.3 重新标记"></a>2.7.6.3 重新标记</h5><p>为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。</p><h5 id="2-7-6-4-并发清除"><a href="#2-7-6-4-并发清除" class="headerlink" title="2.7.6.4 并发清除"></a>2.7.6.4 并发清除</h5><p>清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS 收集器的内存回收和用户线程是一起并发地执行。</p><p>CMS 收集器工作过程：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/CMSCollector.png"></p><h4 id="2-7-7-G1-收集器"><a href="#2-7-7-G1-收集器" class="headerlink" title="2.7.7 G1 收集器"></a>2.7.7 G1 收集器</h4><p>Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器，G1 收集器两个最突出的改进是：</p><ol><li><p>基于标记-整理算法，不产生内存碎片。</p></li><li><p>可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。</p><p>G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率。</p></li></ol><h3 id="2-8-JAVA-IO-NIO"><a href="#2-8-JAVA-IO-NIO" class="headerlink" title="2.8 JAVA IO/NIO"></a>2.8 JAVA IO/NIO</h3><h4 id="2-8-1-阻塞-IO-模型"><a href="#2-8-1-阻塞-IO-模型" class="headerlink" title="2.8.1 阻塞 IO 模型"></a>2.8.1 阻塞 IO 模型</h4><p>最传统的一种 IO 模型，即在读写数据过程中会发生阻塞现象。当用户线程发出 IO 请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出 CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除 block 状态。典型的阻塞 IO 模型的例子为：data = socket.read();如果数据没有就绪，就会一直阻塞在 read 方法。</p><h4 id="2-8-2-非阻塞-IO-模型"><a href="#2-8-2-非阻塞-IO-模型" class="headerlink" title="2.8.2 非阻塞 IO 模型"></a>2.8.2 非阻塞 IO 模型</h4><p>当用户线程发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。所以事实上，在非阻塞 IO 模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞 IO不会交出 CPU，而会一直占用 CPU。典型的非阻塞 IO 模型一般如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">while(true){data = socket.read();if(data!= error){处理数据break;  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是对于非阻塞 IO 就有一个非常严重的问题，在 while 循环中需要不断地去询问内核数据是否就绪，这样会导致 CPU 占用率非常高，因此一般情况下很少使用 while 循环这种方式来读取数据。</p><h4 id="2-8-3-多路复用-IO-模型"><a href="#2-8-3-多路复用-IO-模型" class="headerlink" title="2.8.3 多路复用 IO 模型"></a>2.8.3 多路复用 IO 模型</h4><p>多路复用 IO 模型是目前使用得比较多的模型。Java NIO 实际上就是多路复用 IO。在多路复用 IO模型中，会有一个线程不断去轮询多个 socket 的状态，只有当 socket 真正有读写事件时，才真正调用实际的 IO 读写操作。因为在多路复用 IO 模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket 读写事件进行时，才会使用 IO 资源，所以它大大减少了资源占用。在 Java NIO 中，是通过 selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。多路复用 IO 模式，通过一个线程就可以管理多个 socket，只有当socket 真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用 IO 比较适合连接数比较多的情况。</p><p>另外多路复用 IO 为何比非阻塞 IO 模型的效率高是因为在非阻塞 IO 中，不断地询问 socket 状态时通过用户线程去进行的，而在多路复用 IO 中，轮询每个 socket 状态是内核在进行的，这个效率要比用户线程要高的多。</p><p>不过要注意的是，多路复用 IO 模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用 IO 模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。</p><h4 id="2-8-4-信号驱动-IO-模型"><a href="#2-8-4-信号驱动-IO-模型" class="headerlink" title="2.8.4 信号驱动 IO 模型"></a>2.8.4 信号驱动 IO 模型</h4><p>在信号驱动 IO 模型中，当用户线程发起一个 IO 请求操作，会给对应的 socket 注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用 IO 读写操作来进行实际的 IO 请求操作。</p><h4 id="2-8-5-异步-IO-模型"><a href="#2-8-5-异步-IO-模型" class="headerlink" title="2.8.5 异步 IO 模型"></a>2.8.5 异步 IO 模型</h4><p>异步 IO 模型才是最理想的 IO 模型，在异步 IO 模型中，当用户线程发起 read 操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个 asynchronous read 之后，它会立刻返回，说明 read 请求已经成功发起了，因此不会对用户线程产生任何 block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它 read 操作完成了。也就说用户线程完全不需要实际的整个 IO 操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示 IO 操作已经完成，可以直接去使用数据了。</p><p>也就说在异步 IO 模型中，IO 操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用 IO 函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用 IO 函数进行实际的读写操作；而在异步 IO 模型中，收到信号表示 IO 操作已经完成，不需要再在用户线程中调用 IO 函数进行实际的读写操作。</p><p><strong>注意，异步 IO 是需要操作系统的底层支持，在 Java 7 中，提供了Asynchronous IO。</strong></p><p><strong>更多参考： <a href="http://www.importnew.com/19816.html">http://www.importnew.com/19816.html</a></strong></p><h3 id="2-9-JAVA-IO-包"><a href="#2-9-JAVA-IO-包" class="headerlink" title="2.9 JAVA IO 包"></a>2.9 JAVA IO 包</h3><h4 id="2-9-1-IO包"><a href="#2-9-1-IO包" class="headerlink" title="2.9.1 IO包"></a>2.9.1 IO包</h4><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/JavaIOPackage.png"></p><h4 id="2-9-2-JAVA-NIO"><a href="#2-9-2-JAVA-NIO" class="headerlink" title="2.9.2 JAVA NIO"></a>2.9.2 JAVA NIO</h4><p>NIO 主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector。传统 IO 基于字节流和字符流进行操作，而 NIO 基于 Channel 和 Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/NIOModel.png"></p><p>NIO 和传统 IO 之间第一个最大的区别是，IO 是面向流的，NIO 是面向缓冲区的。</p><h5 id="2-9-2-1-NIO-的缓冲区"><a href="#2-9-2-1-NIO-的缓冲区" class="headerlink" title="2.9.2.1 NIO 的缓冲区"></a>2.9.2.1 NIO 的缓冲区</h5><p>Java IO 面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。NIO 的缓冲导向方法不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p><h5 id="2-9-2-2-NIO-的非阻塞"><a href="#2-9-2-2-NIO-的非阻塞" class="headerlink" title="2.9.2.2 NIO 的非阻塞"></a>2.9.2.2 NIO 的非阻塞</h5><p>IO 的各种流是阻塞的。这意味着，当一个线程调用 read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 NIO 的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞 IO 的空闲时间用于在其它通道上执行 IO 操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/NIOPackage.png"></p><h4 id="2-9-3-Channel"><a href="#2-9-3-Channel" class="headerlink" title="2.9.3 Channel"></a>2.9.3 Channel</h4><p>首先说一下 Channel，国内大多翻译成“通道”。Channel 和 IO 中的 Stream(流)是差不多一个等级的。只不过 Stream 是单向的，譬如：InputStream, OutputStream，而 Channel 是双向的，既可以用来进行读操作，又可以用来进行写操作。</p><p>NIO 中的 Channel 的主要实现有：</p><ol><li><p>FileChannel</p></li><li><p>DatagramChannel</p></li><li><p>SocketChannel</p></li><li><p>ServerSocketChannel</p></li></ol><p>这里看名字就可以猜出个所以然来：分别可以对应文件 IO、UDP 和 TCP（Server 和 Client）。</p><p>下面演示的案例基本上就是围绕这 4 个类型的 Channel 进行陈述的。</p><h4 id="2-9-4-Buffer"><a href="#2-9-4-Buffer" class="headerlink" title="2.9.4 Buffer"></a>2.9.4 Buffer</h4><p>Buffer，故名思意，缓冲区，实际上是一个容器，是一个连续数组。Channel 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/Buffer.png"></p><p>上面的图描述了从一个客户端向服务端发送数据，然后服务端接收数据的过程。客户端发送数据时，必须先将数据存入 Buffer 中，然后将 Buffer 中的内容写入通道。服务端这边接收数据必须通过 Channel 将数据读入到 Buffer 中，然后再从 Buffer 中取出数据来处理。 </p><p>在 NIO 中，Buffer 是一个顶层父类，它是一个抽象类，常用的 Buffer 的子类有：ByteBuffer、IntBuffer、 CharBuffer、 LongBuffer、 DoubleBuffer、FloatBuffer、ShortBuffer</p><h4 id="2-9-5-Selector"><a href="#2-9-5-Selector" class="headerlink" title="2.9.5 Selector"></a>2.9.5 Selector</h4><p>Selector 类是 NIO 的核心类，Selector 能够检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然后针对每个事件进行相应的响应处理。这样一来，只是用一个单线程就可以管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程，并且避免了多线程之间的上下文切换导致的开销。</p><h3 id="2-10-JVM-类加载机制"><a href="#2-10-JVM-类加载机制" class="headerlink" title="2.10 JVM 类加载机制"></a>2.10 JVM 类加载机制</h3><h4 id="2-10-1-JVM类加载机制的五个部分"><a href="#2-10-1-JVM类加载机制的五个部分" class="headerlink" title="2.10.1 JVM类加载机制的五个部分"></a>2.10.1 JVM类加载机制的五个部分</h4><p>JVM 类加载机制分为五个部分：加载，验证，准备，解析，初始化，下面我们就分别来看一下这五个过程。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/JVMClassLoadingMechanism.png"></p><h5 id="2-10-1-1-加载"><a href="#2-10-1-1-加载" class="headerlink" title="2.10.1.1 加载"></a>2.10.1.1 加载</h5><p>加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对 象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个 Class 文件获取，这里既可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）。</p><h5 id="2-10-1-2-验证"><a href="#2-10-1-2-验证" class="headerlink" title="2.10.1.2 验证"></a>2.10.1.2 验证</h5><p>这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><h5 id="2-10-1-3-准备"><a href="#2-10-1-3-准备" class="headerlink" title="2.10.1.3 准备"></a>2.10.1.3 准备</h5><p>准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static int v = 8080;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080，将 v 赋值为 8080 的 put static 指令是程序被编译后，存放于类构造器<client>方法之中。</client></p><p>但是注意如果声明为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static final int v = 8080;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v 赋值为 8080。</p><h5 id="2-10-1-4-解析"><a href="#2-10-1-4-解析" class="headerlink" title="2.10.1.4 解析"></a>2.10.1.4 解析</h5><p>解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是 class 文件中的：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">1. CONSTANT_Class_info2. CONSTANT_Field_info3. CONSTANT_Method_info<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>等类型的常量。</p><h5 id="2-10-1-5-符号引用"><a href="#2-10-1-5-符号引用" class="headerlink" title="2.10.1.5 符号引用"></a>2.10.1.5 符号引用</h5><ul><li>符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。</li></ul><h5 id="2-10-1-6-直接引用"><a href="#2-10-1-6-直接引用" class="headerlink" title="2.10.1.6 直接引用"></a>2.10.1.6 直接引用</h5><ul><li>直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。</li></ul><h5 id="2-10-1-7-初始化"><a href="#2-10-1-7-初始化" class="headerlink" title="2.10.1.7 初始化"></a>2.10.1.7 初始化</h5><p>初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。</p><h5 id="2-10-1-8-类构造器"><a href="#2-10-1-8-类构造器" class="headerlink" title="2.10.1.8 类构造器"></a>2.10.1.8 类构造器<client></client></h5><p>初始化阶段是执行类构造器<client>方法的过程。<client>方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子<client>方法执行之前，父类的<client>方法已经执行完毕，如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成<client>()方法。</client></client></client></client></client></p><p>注意以下几种情况不会执行类初始化：</p><ol><li><p>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。</p></li><li><p>定义对象数组，不会触发该类的初始化。</p></li><li><p>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。</p></li><li><p>通过类名获取 Class 对象，不会触发类的初始化。</p></li><li><p>通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。</p></li><li><p>通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作。</p></li></ol><h4 id="2-10-2-类加载器"><a href="#2-10-2-类加载器" class="headerlink" title="2.10.2 类加载器"></a>2.10.2 类加载器</h4><p>虚拟机设计团队把加载动作放到 JVM 外部实现，以便让应用程序决定如何获取所需的类，JVM 提供了 3 种类加载器：</p><h5 id="2-10-2-1-启动类加载器-Bootstrap-ClassLoader"><a href="#2-10-2-1-启动类加载器-Bootstrap-ClassLoader" class="headerlink" title="2.10.2.1 启动类加载器(Bootstrap ClassLoader)"></a>2.10.2.1 启动类加载器(Bootstrap ClassLoader)</h5><p>负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath 参数指定路径中的，且被虚拟机认可（按文件名识别，如 rt.jar）的类。</p><h5 id="2-10-2-2-扩展类加载器-Extension-ClassLoader"><a href="#2-10-2-2-扩展类加载器-Extension-ClassLoader" class="headerlink" title="2.10.2.2 扩展类加载器(Extension ClassLoader)"></a>2.10.2.2 扩展类加载器(Extension ClassLoader)</h5><p>负责加载 JAVA_HOME\lib\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类库。</p><h5 id="2-10-2-3-应用程序类加载器-Application-ClassLoader-："><a href="#2-10-2-3-应用程序类加载器-Application-ClassLoader-：" class="headerlink" title="2.10.2.3 应用程序类加载器(Application ClassLoader)："></a>2.10.2.3 应用程序类加载器(Application ClassLoader)：</h5><p>负责加载用户路径（classpath）上的类库。</p><p>JVM 通过双亲委派模型进行类的加载，当然我们也可以通过继承 java.lang.ClassLoader实现自定义的类加载器。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/ApplicationClassLoader.png"></p><h4 id="2-10-3-双亲委派"><a href="#2-10-3-双亲委派" class="headerlink" title="2.10.3 双亲委派"></a>2.10.3 双亲委派</h4><p>当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。</p><p>采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/ParentsDelegate.png"></p><h4 id="2-10-4-OSGI（动态模型系统）"><a href="#2-10-4-OSGI（动态模型系统）" class="headerlink" title="2.10.4 OSGI（动态模型系统）"></a>2.10.4 OSGI（动态模型系统）</h4><p>OSGi(Open Service Gateway Initiative)，是面向 Java 的动态模型系统，是 Java 动态化模块化系统的一系列规范。</p><h5 id="2-10-4-1-动态改变构造"><a href="#2-10-4-1-动态改变构造" class="headerlink" title="2.10.4.1 动态改变构造"></a>2.10.4.1 动态改变构造</h5><p>OSGi 服务平台提供在多种网络设备上无需重启的动态改变构造的功能。为了最小化耦合度和促使这些耦合度可管理，OSGi 技术提供一种面向服务的架构，它能使这些组件动态地发现对方。</p><h5 id="2-10-4-2-模块化编程与热插拔"><a href="#2-10-4-2-模块化编程与热插拔" class="headerlink" title="2.10.4.2 模块化编程与热插拔"></a>2.10.4.2 模块化编程与热插拔</h5><p>OSGi 旨在为实现 Java 程序的模块化编程提供基础条件，基于 OSGi 的程序很可能可以实现模块级的热插拔功能，当程序升级更新时，可以只停用、重新安装然后启动程序的其中一部分，这对企业级程序开发来说是非常具有诱惑力的特性。</p><p>OSGi 描绘了一个很美好的模块化开发目标，而且定义了实现这个目标的所需要服务与架构，同时也有成熟的框架进行实现支持。但并非所有的应用都适合采用 OSGi 作为基础架构，它在提供强大功能同时，也引入了额外的复杂度，因为它不遵守了类加载的双亲委托模型。</p><h2 id="3-JAVA-集合"><a href="#3-JAVA-集合" class="headerlink" title="3. JAVA 集合"></a><strong>3. JAVA 集合</strong></h2><h3 id="3-1-接口继承关系和实现"><a href="#3-1-接口继承关系和实现" class="headerlink" title="3.1 接口继承关系和实现"></a>3.1 接口继承关系和实现</h3><p>集合类存放于 Java.util 包中，主要有 3 种：set(集）、list(列表包含 Queue）和 map(映射)。</p><ol><li><p>Collection：Collection 是集合 List、Set、Queue 的最基本的接口。</p></li><li><p>Iterator：迭代器，可以通过迭代器遍历集合中的数据</p></li><li><p>Map：是映射表的基础接口</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/JavaCollection.png"></p></li></ol><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/CollectionsFramework.png"></p><h3 id="3-2-List"><a href="#3-2-List" class="headerlink" title="3.2 List"></a>3.2 List</h3><p>Java 的 List 是非常常用的数据类型。List 是有序的 Collection。Java List 一共三个实现类：分别是 ArrayList、Vector 和 LinkedList。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/JavaListModel.png"></p><h4 id="3-2-1-ArrayList（数组）"><a href="#3-2-1-ArrayList（数组）" class="headerlink" title="3.2.1 ArrayList（数组）"></a>3.2.1 ArrayList（数组）</h4><p>ArrayList 是最常用的 List 实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。</p><h4 id="3-2-2-Vector（数组实现、线程同步）"><a href="#3-2-2-Vector（数组实现、线程同步）" class="headerlink" title="3.2.2 Vector（数组实现、线程同步）"></a>3.2.2 Vector（数组实现、线程同步）</h4><p>Vector 与 ArrayList 一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问 ArrayList 慢。</p><h4 id="3-2-3-LinkList（链表）"><a href="#3-2-3-LinkList（链表）" class="headerlink" title="3.2.3 LinkList（链表）"></a>3.2.3 LinkList（链表）</h4><p>LinkedList 是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了 List 接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。</p><h3 id="3-3-Set"><a href="#3-3-Set" class="headerlink" title="3.3 Set"></a>3.3 Set</h3><p>Set 注重独一无二的性质,该体系集合用于存储无序(存入和取出的顺序不一定相同)元素，值不能重复。对象的相等性本质是对象 hashCode 值（java 是依据对象的内存地址计算出的此序号）判断的，如果想要让两个不同的对象视为相等的，就必须覆盖 Object 的 hashCode 方法和 equals 方法。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/JavaSetModel.png"></p><h4 id="3-3-1-HashSet（Hash-表）"><a href="#3-3-1-HashSet（Hash-表）" class="headerlink" title="3.3.1 HashSet（Hash 表）"></a>3.3.1 HashSet（Hash 表）</h4><p>哈希表边存放的是哈希值。HashSet 存储元素的顺序并不是按照存入时的顺序（和 List 显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的hashcode 方法来获取的, HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals 方法 如果 equls 结果为 true ，HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素。</p><p>哈希值相同 equals 为 false 的元素是怎么存储呢,就是在同样的哈希值下顺延（可以认为哈希值相同的元素放在一个哈希桶中）。也就是哈希一样的存一列。如图 1 表示 hashCode 值不相同的情况；图 2 表示 hashCode 值相同，但 equals 不相同的情况。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/HashSetUseHashCodeCompare.png"></p><p>HashSet 通过 hashCode 值来确定元素在内存中的位置。一个 hashCode 位置上可以存放多个元素。</p><h4 id="3-3-2-TreeSet（二叉树）"><a href="#3-3-2-TreeSet（二叉树）" class="headerlink" title="3.3.2 TreeSet（二叉树）"></a>3.3.2 TreeSet（二叉树）</h4><ol><li><p>TreeSet()是使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。</p></li><li><p>Integer 和 String 对象都可以进行默认的 TreeSet 排序，而自定义类的对象是不可以的，自己定义的类必须实现 Comparable 接口，并且覆写相应的 compareTo()函数，才可以正常使用。</p></li><li><p>在覆写 compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序。</p></li><li><p>比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。</p></li></ol><h4 id="3-3-3-LinkHashSet（HashSet-LinkedHashMap）"><a href="#3-3-3-LinkHashSet（HashSet-LinkedHashMap）" class="headerlink" title="3.3.3 LinkHashSet（HashSet+LinkedHashMap）"></a>3.3.3 LinkHashSet（HashSet+LinkedHashMap）</h4><p> 对于 LinkedHashSet 而言，它继承与 HashSet、又基于 LinkedHashMap 来实现的。LinkedHashSet 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法操作上又与 HashSet 相同，因此 LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操作上与父类 HashSet 的操作相同，直接调用父类 HashSet 的方法即可。</p><h3 id="3-4-Map"><a href="#3-4-Map" class="headerlink" title="3.4 Map"></a>3.4 Map</h3><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/JavaMapModel.png"></p><h4 id="3-4-1-HashMap（数组-链表-红黑树）"><a href="#3-4-1-HashMap（数组-链表-红黑树）" class="headerlink" title="3.4.1 HashMap（数组+链表+红黑树）"></a>3.4.1 HashMap（数组+链表+红黑树）</h4><p>HashMap 根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap 最多只允许一条记录的键为 null，允许多条记录的值为 null。HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法使HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap。我们用下面这张图来介绍HashMap 的结构。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/Java7HashMapStructure.png"></p><h5 id="3-4-1-1-JAVA7-实现"><a href="#3-4-1-1-JAVA7-实现" class="headerlink" title="3.4.1.1 JAVA7 实现"></a>3.4.1.1 JAVA7 实现</h5><p>大方向上，HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。</p><ol><li><p>capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。</p></li><li><p>loadFactor：负载因子，默认为 0.75。</p></li><li><p>threshold：扩容的阈值，等于 capacity * loadFactor</p></li></ol><h5 id="3-4-1-2-JAVA8实现"><a href="#3-4-1-2-JAVA8实现" class="headerlink" title="3.4.1.2  JAVA8实现"></a>3.4.1.2  JAVA8实现</h5><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。</p><p>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/Java8HashMapStructure.png"></p><h4 id="3-4-2-ConcurrentHashMap"><a href="#3-4-2-ConcurrentHashMap" class="headerlink" title="3.4.2 ConcurrentHashMap"></a>3.4.2 ConcurrentHashMap</h4><h5 id="3-4-2-1-Segment-段"><a href="#3-4-2-1-Segment-段" class="headerlink" title="3.4.2.1 Segment 段"></a>3.4.2.1 Segment 段</h5><p>ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了“槽”来代表一个segment。</p><h5 id="3-4-2-2-线程安全（Segment-继承-ReentrantLock-加锁）"><a href="#3-4-2-2-线程安全（Segment-继承-ReentrantLock-加锁）" class="headerlink" title="3.4.2.2 线程安全（Segment 继承 ReentrantLock 加锁）"></a>3.4.2.2 线程安全（Segment 继承 ReentrantLock 加锁）</h5><p>简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/Java7ConcurrentHashMapStructure.png"></p><h5 id="3-4-2-3-并行度（默认-16）"><a href="#3-4-2-3-并行度（默认-16）" class="headerlink" title="3.4.2.3  并行度（默认 16）"></a>3.4.2.3  并行度（默认 16）</h5><p>concurrencyLevel：并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。</p><h5 id="3-4-2-4-Java8实现-（引入了红黑树）"><a href="#3-4-2-4-Java8实现-（引入了红黑树）" class="headerlink" title="3.4.2.4 Java8实现 （引入了红黑树）"></a>3.4.2.4 Java8实现 （引入了红黑树）</h5><p>Java8 对 ConcurrentHashMap 进行了比较大的改动,Java8 也引入了红黑树。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/Java8ConcurrentHashMapStructure.png"></p><h4 id="3-4-3-HashTable（线程安全）"><a href="#3-4-3-HashTable（线程安全）" class="headerlink" title="3.4.3 HashTable（线程安全）"></a>3.4.3 HashTable（线程安全）</h4><p>Hashtable 是遗留类，很多映射的常用功能与 HashMap 类似，不同的是它承自 Dictionary 类，并且是线程安全的，任一时间只有一个线程能写 Hashtable，并发性不如 ConcurrentHashMap，因为 ConcurrentHashMap 引入了分段锁。Hashtable 不建议在新代码中使用，不需要线程安全的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。</p><h4 id="3-4-4-TreeMap（可排序）"><a href="#3-4-4-TreeMap（可排序）" class="headerlink" title="3.4.4 TreeMap（可排序）"></a>3.4.4 TreeMap（可排序）</h4><p>TreeMap 实现 SortedMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。</p><p>如果使用排序的映射，建议使用 TreeMap。</p><p>在使用 TreeMap 时，key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的Comparator，否则会在运行时抛出 java.lang.ClassCastException 类型的异常。</p><p><strong>参考：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-tree/index.html">https://www.ibm.com/developerworks/cn/java/j-lo-tree/index.html</a></strong></p><h4 id="3-4-5-LinkHashMap（记录插入顺序）"><a href="#3-4-5-LinkHashMap（记录插入顺序）" class="headerlink" title="3.4.5 LinkHashMap（记录插入顺序）"></a>3.4.5 LinkHashMap（记录插入顺序）</h4><p>LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历LinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p><p><strong>参考 1：<a href="http://www.importnew.com/28263.html">http://www.importnew.com/28263.html</a></strong></p><p><strong>参考 2：<a href="http://www.importnew.com/20386.html#comment-64812313">http://www.importnew.com/20386.html#comment-64812313</a></strong></p><h2 id="4-JAVA-多线程并发"><a href="#4-JAVA-多线程并发" class="headerlink" title="4. JAVA 多线程并发"></a><strong>4. JAVA 多线程并发</strong></h2><h4 id="4-1-1-JAVA-并发知识库"><a href="#4-1-1-JAVA-并发知识库" class="headerlink" title="4.1.1 JAVA 并发知识库"></a>4.1.1 JAVA 并发知识库</h4><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/J.U.C.png"></p><h4 id="4-1-2-JAVA-线程实现-创建方式"><a href="#4-1-2-JAVA-线程实现-创建方式" class="headerlink" title="4.1.2 JAVA 线程实现/创建方式"></a>4.1.2 JAVA 线程实现/创建方式</h4><h5 id="4-1-2-1-继承-Thread-类"><a href="#4-1-2-1-继承-Thread-类" class="headerlink" title="4.1.2.1 继承 Thread 类"></a>4.1.2.1 继承 Thread 类</h5><p>Thread 类本质上是实现了 Runnable 接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过 Thread 类的 start()实例方法。start()方法是一个 native 方法，它将启动一个新线程，并执行 run()方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MyThread extends Thread {  public void run() {  System.out.println("MyThread.run()");  } } MyThread myThread1 = new MyThread(); myThread1.start(); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-1-2-2-实现-Runnable-接口"><a href="#4-1-2-2-实现-Runnable-接口" class="headerlink" title="4.1.2.2 实现 Runnable 接口"></a>4.1.2.2 实现 Runnable 接口</h5><p>如果自己的类已经 extends 另一个类，就无法直接 extends Thread，此时，可以实现一个Runnable 接口。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MyThread extends OtherClass implements Runnable {  public void run() {  System.out.println("MyThread.run()");    }  }//启动 MyThread，需要首先实例化一个 Thread，并传入自己的 MyThread 实例：MyThread myThread = new MyThread(); Thread thread = new Thread(myThread); thread.start(); //事实上，当传入一个 Runnable target 参数给 Thread 后，Thread 的 run()方法就会调用target.run()public void run() {  if (target != null) {  target.run();  } } <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-1-2-3-ExecutorService、Callable、Future-有返回值线程"><a href="#4-1-2-3-ExecutorService、Callable、Future-有返回值线程" class="headerlink" title="4.1.2.3 ExecutorService、Callable、Future 有返回值线程"></a>4.1.2.3 ExecutorService、Callable<class>、Future 有返回值线程</class></h5><p>有返回值的任务必须实现 Callable 接口，类似的，无返回值的任务必须 Runnable 接口。执行Callable 任务后，可以获取一个 Future 的对象，在该对象上调用 get 就可以获取到 Callable 任务返回的 Object 了，再结合线程池接口 ExecutorService 就可以实现传说中有返回结果的多线程了。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//创建一个线程池ExecutorService pool = Executors.newFixedThreadPool(taskSize);// 创建多个有返回值的任务List&lt;Future&gt; list = new ArrayList&lt;Future&gt;(); for (int i = 0; i &lt; taskSize; i++) {Callable c = new MyCallable(i + " ");     // 执行任务并获取 Future 对象Future f = pool.submit(c); list.add(f); } // 关闭线程池pool.shutdown(); // 获取所有并发任务的运行结果for (Future f : list) { // 从 Future 对象上获取任务的返回值，并输出到控制台System.out.println("res：" + f.get().toString()); }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-1-2-4-基于线程池的方式"><a href="#4-1-2-4-基于线程池的方式" class="headerlink" title="4.1.2.4 基于线程池的方式"></a>4.1.2.4 基于线程池的方式</h5><p>线程和数据库连接这些资源都是非常宝贵的资源。那么每次需要的时候创建，不需要的时候销毁，是非常浪费资源的。那么我们就可以使用缓存的策略，也就是使用线程池。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 创建线程池ExecutorService threadPool = Executors.newFixedThreadPool(10);while(true) {threadPool.execute(new Runnable() { // 提交多个线程任务，并执行@Overridepublic void run() {System.out.println(Thread.currentThread().getName() + " is running ..");try {Thread.sleep(3000);} catch (InterruptedException e) {e.printStackTrace();}  } });} }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-1-3-4种线程池"><a href="#4-1-3-4种线程池" class="headerlink" title="4.1.3   4种线程池"></a>4.1.3   4种线程池</h4><p>Java 里面线程池的顶级接口是 <strong>Executor</strong>，但是严格意义上讲 Executor 并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是<strong>ExecutorService</strong>。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/JavaThreadPool.png"></p><h5 id="4-1-3-1-newCachedThreadPool"><a href="#4-1-3-1-newCachedThreadPool" class="headerlink" title="4.1.3.1 newCachedThreadPool"></a>4.1.3.1 newCachedThreadPool</h5><p>创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用 execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。</p><h5 id="4-1-3-2-newFixedThreadPool"><a href="#4-1-3-2-newFixedThreadPool" class="headerlink" title="4.1.3.2 newFixedThreadPool"></a>4.1.3.2 newFixedThreadPool</h5><p>创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。</p><h5 id="4-1-3-3-newScheduledThreadPool"><a href="#4-1-3-3-newScheduledThreadPool" class="headerlink" title="4.1.3.3 newScheduledThreadPool"></a>4.1.3.3 newScheduledThreadPool</h5><p>创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">ScheduledExecutorService scheduledThreadPool= Executors.newScheduledThreadPool(3);   scheduledThreadPool.schedule(newRunnable(){ @Override public void run() {System.out.println("延迟三秒");}  }, 3, TimeUnit.SECONDS);scheduledThreadPool.scheduleAtFixedRate(newRunnable(){ @Override public void run() {System.out.println("延迟 1 秒后每三秒执行一次");}  },1,3,TimeUnit.SECONDS);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-1-3-4-newSingleThreadExecutor"><a href="#4-1-3-4-newSingleThreadExecutor" class="headerlink" title="4.1.3.4 newSingleThreadExecutor"></a>4.1.3.4 newSingleThreadExecutor</h5><p>Executors.newSingleThreadExecutor()返回一个线程池（这个线程池只有一个线程）,这个线程池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去！</p><h4 id="4-1-4-线程生命周期-状态"><a href="#4-1-4-线程生命周期-状态" class="headerlink" title="4.1.4 线程生命周期(状态)"></a>4.1.4 线程生命周期(状态)</h4><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，它要经过新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5 种状态。尤其是当线程启动以后，它不可能一直”霸占”着 CPU 独自运行，所以 CPU 需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换。</p><h5 id="4-1-4-1-新建状态（NEW）"><a href="#4-1-4-1-新建状态（NEW）" class="headerlink" title="4.1.4.1 新建状态（NEW）"></a>4.1.4.1 新建状态（NEW）</h5><p>当程序使用 new 关键字创建了一个线程之后，该线程就处于新建状态，此时仅由 JVM 为其分配内存，并初始化其成员变量的值。</p><h5 id="4-1-4-2-就绪状态（RUNNABLE）"><a href="#4-1-4-2-就绪状态（RUNNABLE）" class="headerlink" title="4.1.4.2 就绪状态（RUNNABLE）"></a>4.1.4.2 就绪状态（RUNNABLE）</h5><p>当线程对象调用了 start()方法之后，该线程处于就绪状态。Java 虚拟机会为其创建方法调用栈和程序计数器，等待调度运行。</p><h5 id="4-1-4-3-运行状态（RUNNING）"><a href="#4-1-4-3-运行状态（RUNNING）" class="headerlink" title="4.1.4.3 运行状态（RUNNING）"></a>4.1.4.3 运行状态（RUNNING）</h5><p>如果处于就绪状态的线程获得了 CPU，开始执行 run()方法的线程执行体，则该线程处于运行状态。</p><h5 id="4-1-4-4-阻塞状态（BLOCKED）"><a href="#4-1-4-4-阻塞状态（BLOCKED）" class="headerlink" title="4.1.4.4 阻塞状态（BLOCKED）"></a>4.1.4.4 阻塞状态（BLOCKED）</h5><p>阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得 cpu timeslice 转到运行(running)状态。阻塞的情况分三种：</p><p><strong><em>等待阻塞（o.wait-&gt;等待对列）：</em></strong></p><p>运行(running)的线程执行 o.wait()方法，JVM 会把该线程放入等待队列(waitting queue)中。</p><p><strong><em>同步阻塞(lock-&gt;锁池)：</em></strong></p><p>运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放入锁池(lock pool)中。</p><p><strong><em>其他阻塞(sleep/join)：</em></strong></p><p>运行(running)的线程执行 Thread.sleep(long ms)或 t.join()方法，或者发出了 I/O 请求时，JVM 会把该线程置为阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I/O处理完毕时，线程重新转入可运行(runnable)状态。</p><h5 id="4-1-4-5-线程死亡（DEAD）"><a href="#4-1-4-5-线程死亡（DEAD）" class="headerlink" title="4.1.4.5 线程死亡（DEAD）"></a>4.1.4.5 线程死亡（DEAD）</h5><p>线程会以下面三种方式结束，结束后就是死亡状态。</p><p><strong>正常结束</strong></p><ol><li>run()或 call()方法执行完成，线程正常结束。</li></ol><p><strong>异常结束</strong></p><ol start="2"><li>线程抛出一个未捕获的 Exception 或 Error。</li></ol><p><strong>调用</strong> <strong>stop</strong></p><ol start="3"><li><p>直接调用该线程的 stop()方法来结束该线程—该方法通常容易导致死锁，不推荐使用。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/ThreadLifeCycle.png"></p></li></ol><h4 id="4-1-5-终止线程-4-种方式"><a href="#4-1-5-终止线程-4-种方式" class="headerlink" title="4.1.5 终止线程 4 种方式"></a>4.1.5 终止线程 4 种方式</h4><h5 id="4-1-5-1-正常运行结束"><a href="#4-1-5-1-正常运行结束" class="headerlink" title="4.1.5.1 正常运行结束"></a>4.1.5.1 正常运行结束</h5><p> 程序运行结束，线程自动结束。</p><h5 id="4-1-5-2-使用退出标志退出线程"><a href="#4-1-5-2-使用退出标志退出线程" class="headerlink" title="4.1.5.2 使用退出标志退出线程"></a>4.1.5.2 使用退出标志退出线程</h5><p>一般 run()方法执行完，线程就会正常结束，然而，常常有些线程是伺服线程。它们需要长时间的运行，只有在外部某些条件满足的情况下，才能关闭这些线程。使用一个变量来控制循环，例如：最直接的方法就是设一个 boolean 类型的标志，并通过设置这个标志为 true 或 false 来控制 while循环是否退出，代码示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ThreadSafe extends Thread { public volatile boolean exit = false;   public void run() {   while (!exit){    //do something  } } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义了一个退出标志 exit，当 exit 为 true 时，while 循环退出，exit 的默认值为 false.在定义 exit时，使用了一个 Java 关键字 volatile，这个关键字的目的是使 exit 同步，也就是说在同一时刻只能由一个线程来修改 exit 的值。</p><h5 id="4-1-5-3-Interrupt-方法结束线程"><a href="#4-1-5-3-Interrupt-方法结束线程" class="headerlink" title="4.1.5.3 Interrupt 方法结束线程"></a>4.1.5.3 Interrupt 方法结束线程</h5><p>使用 interrupt()方法来中断线程有两种情况：</p><ol><li><p>线程处于阻塞状态：如使用了 sleep,同步锁的 wait,socket 中的 receiver,accept 等方法时，会使线程处于阻塞状态。当调用线程的 interrupt()方法时，会抛出 InterruptException 异常。阻塞中的那个方法抛出这个异常，通过代码捕获该异常，然后 break 跳出循环状态，从而让我们有机会结束这个线程的执行。通常很多人认为只要调用 interrupt 方法线程就会结束，实际上是错的， 一定要先捕获 InterruptedException 异常之后通过 break 来跳出循环，才能正常结束 run 方法。</p></li><li><p>线程未处于阻塞状态：使用 isInterrupted()判断线程的中断标志来退出循环。当使用interrupt()方法时，中断标志就会置 true，和使用自定义的标志来控制循环是一样的道理。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ThreadSafe extends Thread { public void run() {   while (!isInterrupted()){ //非阻塞过程中通过判断中断标志来退出   try{    Thread.sleep(5*1000);//阻塞过程捕获中断异常来退出   }catch(InterruptedException e){    e.printStackTrace();    break;//捕获到异常之后，执行 break 跳出循环   }  } } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-1-5-4-stop-方法终止线程（线程不安全）"><a href="#4-1-5-4-stop-方法终止线程（线程不安全）" class="headerlink" title="4.1.5.4 stop 方法终止线程（线程不安全）"></a>4.1.5.4 stop 方法终止线程（线程不安全）</h5></li></ol><p>程序中可以直接使用 thread.stop()来强行终止线程，但是 stop 方法是很危险的，就象突然关闭计算机电源，而不是按正常程序关机一样，可能会产生不可预料的结果，不安全主要是：thread.stop()调用之后，创建子线程的线程就会抛出 ThreadDeatherror 的错误，并且会释放子线程所持有的所有锁。一般任何进行加锁的代码块，都是为了保护数据的一致性，如果在调用thread.stop()后导致了该线程所持有的所有锁的突然释放(不可控制)，那么被保护数据就有可能呈现不一致性，其他线程在使用这些被破坏的数据时，有可能导致一些很奇怪的应用程序错误。因此，并不推荐使用 stop 方法来终止线程。</p><h4 id="4-1-6-sleep-与-wait-区别"><a href="#4-1-6-sleep-与-wait-区别" class="headerlink" title="4.1.6 sleep 与 wait 区别"></a>4.1.6 sleep 与 wait 区别</h4><ol><li><p>对于 sleep()方法，我们首先要知道该方法是属于 Thread 类中的。而 wait()方法，则是属于Object 类中的。</p></li><li><p>sleep()方法导致了程序暂停执行指定的时间，让出 cpu 该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。</p></li><li><p>在调用 sleep()方法的过程中，线程不会释放对象锁。</p></li><li><p>而当调用 wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用 notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。</p></li></ol><h4 id="4-1-7-start与run区别"><a href="#4-1-7-start与run区别" class="headerlink" title="4.1.7 start与run区别"></a>4.1.7 start与run区别</h4><ol><li><p><strong>start（）</strong>方法来启动线程，真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕，可以直接继续执行下面的代码。</p></li><li><p>通过调用 Thread 类的 start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。</p></li><li><p>方法 run()称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运行 run 函数当中的代码。 Run 方法运行结束， 此线程终止。然后 CPU 再调度其它线程。</p></li></ol><h4 id="4-1-8-JAVA后台线程"><a href="#4-1-8-JAVA后台线程" class="headerlink" title="4.1.8 JAVA后台线程"></a>4.1.8 JAVA后台线程</h4><ol><li><p>定义：守护线程–也称“服务线程”，他是后台线程，它有一个特性，即为用户线程 提供 公共服务，在没有用户线程可服务时会自动离开。</p></li><li><p>优先级：守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。</p></li><li><p>设置：通过 setDaemon(true)来设置线程为“守护线程”；将一个用户线程设置为守护线程的方式是在 线程对象创建 之前 用线程对象的 setDaemon 方法。</p></li><li><p>在 Daemon 线程中产生的新线程也是 Daemon 的。</p></li><li><p>线程则是 JVM 级别的，以 Tomcat 为例，如果你在 Web 应用中启动一个线程，这个线程的生命周期并不会和 Web 应用程序保持同步。也就是说，即使你停止了 Web 应用，这个线程依旧是活跃的。</p></li><li><p>example: 垃圾回收线程就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是 JVM 上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。</p></li><li><p>生命周期：守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依赖于系统，与系统“同生共死”。当 JVM 中所有的线程都是守护线程的时候，JVM 就可以退出了；如果还有一个或以上的非守护线程则 JVM 不会退出。</p></li></ol><h4 id="4-1-9-JAVA锁"><a href="#4-1-9-JAVA锁" class="headerlink" title="4.1.9 JAVA锁"></a>4.1.9 JAVA锁</h4><h5 id="4-1-9-1-乐观锁"><a href="#4-1-9-1-乐观锁" class="headerlink" title="4.1.9.1 乐观锁"></a>4.1.9.1 乐观锁</h5><p>乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。</p><p>java 中的乐观锁基本都是通过 CAS 操作实现的，CAS 是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。</p><h5 id="4-1-9-2-悲观锁"><a href="#4-1-9-2-悲观锁" class="headerlink" title="4.1.9.2 悲观锁"></a>4.1.9.2 悲观锁</h5><p>悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会 block 直到拿到锁。java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如 RetreenLock。</p><h5 id="4-1-9-3-自旋锁"><a href="#4-1-9-3-自旋锁" class="headerlink" title="4.1.9.3 自旋锁"></a>4.1.9.3 自旋锁</h5><p>自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</p><p>线程自旋是需要消耗 cup 的，说白了就是让 cup 在做无用功，如果一直获取不到锁，那线程也不能一直占用 cup 自旋做无用功，所以需要设定一个自旋等待的最大时间。</p><p>如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。</p><p><strong><em>自旋锁的优缺点</em></strong></p><p>自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！</p><p>但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，占着 XX 不 XX，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要 cup 的线程又不能获取到 cpu，造成 cpu 的浪费。所以这种情况下我们要关闭自旋锁；</p><p><strong><em>自旋锁时间阈值（1.6引入了适应性自旋锁）</em></strong></p><p>自旋锁的目的是为了占着 CPU 的资源不释放，等到获取到锁立即进行处理。但是如何去选择自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用 CPU 资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要！</p><p>JVM 对于自旋周期的选择，jdk1.5 这个限度是一定的写死的，在 1.6 引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间，同时 JVM 还针对当前 CPU 的负荷情况做了较多的优化，如果平均负载小于 CPUs 则一直自旋，如果有超过(CPUs/2)个线程正在自旋，则后来线程直接阻塞，如果正在自旋的线程发现 Owner 发生了变化则延迟自旋时间（自旋计数）或进入阻塞，如果 CPU 处于节电模式则停止自旋，自旋时间的最坏情况是 CPU的存储延迟（CPU A 存储了一个数据，到 CPU B 得知这个数据直接的时间差），自旋时会适当放弃线程优先级之间的差异。</p><p><strong><em>自旋锁的开启</em></strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">JDK1.6 中-XX:+UseSpinning 开启；-XX:PreBlockSpin=10 为自旋次数；JDK1.7 后，去掉此参数，由 jvm 控制；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="4-1-9-4-Synchronized同步锁"><a href="#4-1-9-4-Synchronized同步锁" class="headerlink" title="4.1.9.4 Synchronized同步锁"></a>4.1.9.4 Synchronized同步锁</h5><p>synchronized 它可以把任意一个非 NULL 的对象当作锁。他属于独占式的悲观锁，同时属于可重入锁。</p><p><strong><em>Synchronized作用范围</em></strong></p><ol><li><p>作用于方法时，锁住的是对象的实例(this)；</p></li><li><p>当作用于静态方法时，锁住的是Class实例，又因为Class的相关数据存储在永久带PermGen（jdk1.8 则是 metaspace），永久带是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程；</p></li><li><p>synchronized 作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。它有多个队列，当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。</p></li></ol><p><strong><em>Synchronized核心组件</em></strong></p><ol><li><p>Wait Set：哪些调用 wait 方法被阻塞的线程被放置在这里；</p></li><li><p>Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中；</p></li><li><p>Entry List：Contention List 中那些有资格成为候选资源的线程被移动到 Entry List 中；</p></li><li><p>OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为 OnDeck；</p></li><li><p>Owner：当前已经获取到所资源的线程被称为 Owner；</p></li><li><p>!Owner：当前释放锁的线程。</p></li></ol><p><strong><em>Synchronized实现</em></strong></p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/SynchronizedImplementation.png"></p><ol><li><p>JVM 每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下，ContentionList 会被大量的并发线程进行 CAS 访问，为了降低对尾部元素的竞争，JVM 会将一部分线程移动到 EntryList 中作为候选竞争线程。</p></li><li><p>Owner 线程会在 unlock 时，将 ContentionList 中的部分线程迁移到 EntryList 中，并指定EntryList 中的某个线程为 OnDeck 线程（一般是最先进去的那个线程）。</p></li><li><p>Owner 线程并不直接把锁传递给 OnDeck 线程，而是把锁竞争的权利交给 OnDeck，OnDeck 需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在JVM 中，也把这种选择行为称之为“竞争切换”。</p></li><li><p>OnDeck 线程获取到锁资源后会变为 Owner 线程，而没有得到锁资源的仍然停留在 EntryList中。如果 Owner 线程被 wait 方法阻塞，则转移到 WaitSet 队列中，直到某个时刻通过 notify或者 notifyAll 唤醒，会重新进去 EntryList 中。</p></li><li><p>处于 ContentionList、EntryList、WaitSet 中的线程都处于阻塞状态，该阻塞是由操作系统来完成的（Linux 内核下采用 pthread_mutex_lock 内核函数实现的）。</p></li><li><p>Synchronized 是非公平锁。 Synchronized 在线程进入 ContentionList 时，等待的线程会先尝试自旋获取锁，如果获取不到就进入 ContentionList，这明显对于已经进入队列的线程是不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁资源。<strong>参考：<a href="https://blog.csdn.net/zqz_zqz/article/details/70233767">https://blog.csdn.net/zqz_zqz/article/details/70233767</a></strong></p></li><li><p>每个对象都有个 monitor 对象，加锁就是在竞争 monitor 对象，代码块加锁是在前后分别加上 monitorenter 和 monitorexit 指令来实现的，方法加锁是通过一个标记位来判断的。</p></li><li><p>synchronized 是一个重量级操作，需要调用操作系统相关接口，性能是低效的，有可能给线程加锁消耗的时间比有用操作消耗的时间更多。</p></li><li><p>Java1.6，synchronized 进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等，效率有了本质上的提高。在之后推出的 Java1.7 与 1.8 中，均对该关键字的实现机理做了优化。引入了偏向锁和轻量级锁。都是在对象头中有标记位，不需要经过操作系统加锁。</p></li><li><p>锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。这种升级过程叫做锁膨胀；</p></li><li><p>JDK 1.6 中默认是开启偏向锁和轻量级锁，可以通过-XX:-UseBiasedLocking 来禁用偏向锁。</p></li></ol><h5 id="4-1-9-5-ReentrantLock"><a href="#4-1-9-5-ReentrantLock" class="headerlink" title="4.1.9.5 ReentrantLock"></a>4.1.9.5 ReentrantLock</h5><p>ReentantLock 继承接口 Lock 并实现了接口中定义的方法，他是一种可重入锁，除了能成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。</p><p><strong><em>Lock接口的主要方法</em></strong></p><ol><li><p>void lock(): 执行此方法时, 如果锁处于空闲状态, 当前线程将获取到锁. 相反, 如果锁已经被其他线程持有, 将禁用当前线程, 直到当前线程获取到锁.</p></li><li><p>boolean tryLock()：如果锁可用, 则获取锁, 并立即返回 true, 否则返回 false. 该方法和lock()的区别在于, tryLock()只是”试图”获取锁, 如果锁不可用, 不会导致当前线程被禁用, 当前线程仍然继续往下执行代码. 而 lock()方法则是一定要获取到锁, 如果锁不可用, 就一直等待, 在未获得锁之前,当前线程并不继续向下执行. </p></li><li><p>void unlock()：执行此方法时, 当前线程将释放持有的锁. 锁只能由持有者释放, 如果线程并不持有锁, 却执行该方法, 可能导致异常的发生.</p></li><li><p>Condition newCondition()：条件对象，获取等待通知组件。该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的 await()方法，而调用后，当前线程将缩放锁。</p></li><li><p>getHoldCount() ：查询当前线程保持此锁的次数，也就是执行此线程执行 lock 方法的次数。</p></li><li><p>getQueueLength（）：返回正等待获取此锁的线程估计数，比如启动 10 个线程，1 个线程获得锁，此时返回的是 9</p></li><li><p>getWaitQueueLength：（Condition condition）返回等待与此锁相关的给定条件的线程估计数。比如 10 个线程，用同一个 condition 对象，并且此时这 10 个线程都执行了condition 对象的 await 方法，那么此时执行此方法返回 10</p></li><li><p>hasWaiters(Condition condition)：查询是否有线程等待与此锁有关的给定条件(condition)，对于指定 contidion 对象，有多少线程执行了 condition.await 方法</p></li><li><p>hasQueuedThread(Thread thread)：查询给定线程是否等待获取此锁</p></li><li><p>hasQueuedThreads()：是否有线程等待此锁</p></li><li><p>isFair()：该锁是否公平锁</p></li><li><p>isHeldByCurrentThread()： 当前线程是否保持锁锁定，线程的执行 lock 方法的前后分别是 false 和 true</p></li><li><p>isLock()：此锁是否有任意线程占用</p></li><li><p>lockInterruptibly（）：如果当前线程未被中断，获取锁</p></li><li><p>tryLock（）：尝试获得锁，仅在调用时锁未被线程占用，获得锁</p></li><li><p>tryLock(long timeout TimeUnit unit)：如果锁在给定等待时间内没有被另一个线程保持，则获取该锁。</p></li></ol><p><strong><em>非公平锁</em></strong></p><p>JVM 按随机、就近原则分配锁的机制则称为不公平锁，ReentrantLock 在构造函数中提供了是否公平锁的初始化方式，默认为非公平锁。非公平锁实际执行的效率要远远超出公平锁，除非程序有特殊需要，否则最常用非公平锁的分配机制。</p><p><strong><em>公平锁</em></strong></p><p>公平锁指的是锁的分配机制是公平的，通常先对锁提出获取请求的线程会先被分配到锁，ReentrantLock 在构造函数中提供了是否公平锁的初始化方式来定义公平锁。</p><p><strong><em>ReentrantLock 与 synchronized</em></strong></p><ol><li><p>ReentrantLock 通过方法 lock()与 unlock()来进行加锁与解锁操作，与 synchronized 会 被 JVM 自动解锁机制不同，ReentrantLock 加锁后需要手动进行解锁。为了避免程序出现异常而无法正常解锁的情况，使用 ReentrantLock 必须在 finally 控制块中进行解锁操作。</p></li><li><p>ReentrantLock 相比 synchronized 的优势是可中断、公平锁、多个锁。这种情况下需要使用 ReentrantLock。</p></li></ol><p><strong><em>ReentrantLock实现</em></strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MyService {  private Lock lock = new ReentrantLock();  //Lock lock=new ReentrantLock(true);//公平锁  //Lock lock=new ReentrantLock(false);//非公平锁  private Condition condition=lock.newCondition();//创建 Conditionpublic void testMethod() {try {  lock.lock();//lock 加锁  //1：wait 方法等待：  //System.out.println("开始 wait");  condition.await();  //通过创建 Condition 对象来使线程 wait，必须先执行 lock.lock 方法获得锁              //:2：signal 方法唤醒  condition.signal();//condition 对象的 signal 方法可以唤醒 wait 线程  for (int i = 0; i &lt; 5; i++) {System.out.println("ThreadName=" + Thread.currentThread().getName()+ (" " + (i + 1)));   }} catch (InterruptedException e) {e.printStackTrace();}finally {  lock.unlock(); }} }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>Condition类和Object类锁方法区别区别</em></strong></p><ol><li><p>Condition 类的 awiat 方法和 Object 类的 wait 方法等效</p></li><li><p>Condition 类的 signal 方法和 Object 类的 notify 方法等效</p></li><li><p>Condition 类的 signalAll 方法和 Object 类的 notifyAll 方法等效</p></li><li><p>ReentrantLock 类可以唤醒指定条件的线程，而 object 的唤醒是随机的</p></li></ol><p><strong><em>tryLock和lock和lockInterruptibly的区别</em></strong></p><ol><li><p>tryLock 能获得锁就返回 true，不能就立即返回 false，tryLock(long timeout,TimeUnit unit)，可以增加时间限制，如果超过该时间段还没获得锁，返回 false</p></li><li><p>lock 能获得锁就返回 true，不能的话一直等待获得锁</p></li><li><p>lock 和 lockInterruptibly，如果两个线程分别执行这两个方法，但此时中断这两个线程，lock 不会抛出异常，而 lockInterruptibly 会抛出异常。</p></li></ol><h5 id="4-1-9-6-Semaphore信号量"><a href="#4-1-9-6-Semaphore信号量" class="headerlink" title="4.1.9.6 Semaphore信号量"></a>4.1.9.6 Semaphore信号量</h5><p>Semaphore 是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore 可以用来构建一些对象池，资源池之类的，比如数据库连接池。</p><p><strong><em>实现互斥锁（计数器为1）</em></strong></p><p>我们也可以创建计数为 1 的 Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。</p><p><strong><em>代码实现</em></strong></p><p>它的用法如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 创建一个计数阈值为 5 的信号量对象// 只能 5 个线程同时访问Semaphore semp = new Semaphore(5);try { // 申请许可semp.acquire();try {// 业务逻辑} catch (Exception e) {} finally {// 释放许可semp.release();}  } catch (InterruptedException e) {}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>Semaphore与ReentrantLock</em></strong></p><p>Semaphore 基本能完成 ReentrantLock 的所有工作，使用方法也与之类似，通过 acquire()与release()方法来获得和释放临界资源。经实测，Semaphone.acquire()方法默认为可响应中断锁，与 ReentrantLock.lockInterruptibly()作用效果一致，也就是说在等待临界资源的过程中可以被Thread.interrupt()方法中断。</p><p>此外，Semaphore 也实现了可轮询的锁请求与定时锁的功能，除了方法名 tryAcquire 与 tryLock不同，其使用方法与 ReentrantLock 几乎一致。Semaphore 也提供了公平与非公平锁的机制，也可在构造函数中进行设定。</p><p>Semaphore 的锁释放操作也由手动进行，因此与 ReentrantLock 一样，为避免线程因抛出异常而无法正常释放锁的情况发生，释放锁的操作也必须在 finally 代码块中完成。</p><h5 id="4-1-9-7-AtomicInteger"><a href="#4-1-9-7-AtomicInteger" class="headerlink" title="4.1.9.7 AtomicInteger"></a>4.1.9.7 AtomicInteger</h5><p>首先说明，此处 AtomicInteger ，一个提供原子操作的 Integer 的类，常见的还有AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference 等，他们的实现原理相同，区别在与运算对象类型的不同。令人兴奋地，还可以通过 AtomicReference<v>将一个对象的所有操作转化成原子操作。</v></p><p>我们知道，在多线程程序中，诸如++i 或 i++等运算不具有原子性，是不安全的线程操作之一。通常我们会使用 synchronized 将该操作变成一个原子操作，但 JVM 为此类操作特意提供了一些同步类，使得使用更方便，且使程序运行效率变得更高。通过相关资料显示，通常AtomicInteger的性能是 ReentantLock 的好几倍。</p><h5 id="4-1-9-8-可重入锁（递归锁）"><a href="#4-1-9-8-可重入锁（递归锁）" class="headerlink" title="4.1.9.8 可重入锁（递归锁）"></a>4.1.9.8 可重入锁（递归锁）</h5><p>本文里面讲的是广义上的可重入锁，而不是单指 JAVA 下的 ReentrantLock。可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。在 JAVA 环境下 ReentrantLock 和 synchronized 都是 可重入锁。</p><h5 id="4-1-9-9-公平锁与非公平锁"><a href="#4-1-9-9-公平锁与非公平锁" class="headerlink" title="4.1.9.9 公平锁与非公平锁"></a>4.1.9.9 公平锁与非公平锁</h5><p><strong><em>公平锁（Fair）</em></strong></p><p>加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得</p><p><strong><em>非公平锁（Nonfair）</em></strong></p><p>加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待</p><ol><li><p>非公平锁性能比公平锁高 5~10 倍，因为公平锁需要在多核的情况下维护一个队列</p></li><li><p>Java 中的 synchronized 是非公平锁，ReentrantLock 默认的 lock()方法采用的是非公平锁。</p></li></ol><h5 id="4-1-9-10-ReadWriteLock读写锁"><a href="#4-1-9-10-ReadWriteLock读写锁" class="headerlink" title="4.1.9.10 ReadWriteLock读写锁"></a>4.1.9.10 ReadWriteLock读写锁</h5><p>为了提高性能，Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的，你只要上好相应的锁即可。</p><p><strong><em>读锁</em></strong></p><p>如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁</p><p><strong><em>写锁</em></strong></p><p>如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！</p><p>Java 中 读 写 锁 有 个 接 口 java.util.concurrent.locks.ReadWriteLock ， 也 有 具 体 的 实 现ReentrantReadWriteLock。</p><h5 id="4-1-9-11-共享锁和独占锁"><a href="#4-1-9-11-共享锁和独占锁" class="headerlink" title="4.1.9.11 共享锁和独占锁"></a>4.1.9.11 共享锁和独占锁</h5><p>java 并发包提供的加锁模式分为独占锁和共享锁。</p><p><strong><em>独占锁</em></strong></p><p>独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock 就是以独占方式实现的互斥锁。独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。</p><p><strong><em>共享锁</em></strong></p><p>共享锁则允许多个线程同时获取锁，并发访问 共享资源，如：ReadWriteLock。共享锁则是一种乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。</p><ol><li><p>AQS 的内部类 Node 定义了两个常量 SHARED 和 EXCLUSIVE，他们分别标识 AQS 队列中等待线程的锁获取模式。</p></li><li><p>java 的并发包中提供了 ReadWriteLock，读-写锁。它允许一个资源可以被多个读操作访问，或者被一个 写操作访问，但两者不能同时进行。</p></li></ol><h5 id="4-1-9-12-重量级锁（Mutex-Lock）"><a href="#4-1-9-12-重量级锁（Mutex-Lock）" class="headerlink" title="4.1.9.12 重量级锁（Mutex Lock）"></a>4.1.9.12 重量级锁（Mutex Lock）</h5><p>Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的 Mutex Lock 来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized 效率低的原因。因此，这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为“重量级锁”。JDK 中对 Synchronized 做的种种优化，其核心都是为了减少这种重量级锁的使用。JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。</p><h5 id="4-1-9-13-轻量级锁"><a href="#4-1-9-13-轻量级锁" class="headerlink" title="4.1.9.13 轻量级锁"></a>4.1.9.13 轻量级锁</h5><p>锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。</p><p><strong><em>锁升级</em></strong></p><p>随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。</p><p>“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。</p><h5 id="4-1-9-14-偏向锁"><a href="#4-1-9-14-偏向锁" class="headerlink" title="4.1.9.14 偏向锁"></a>4.1.9.14 偏向锁</h5><p>Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换ThreadID 的时候依赖一次 CAS 原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗）。上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</p><h5 id="4-1-9-15-分段锁"><a href="#4-1-9-15-分段锁" class="headerlink" title="4.1.9.15 分段锁"></a>4.1.9.15 分段锁</h5><p>分段锁也并非一种实际的锁，而是一种思想 ConcurrentHashMap 是学习分段锁的最好实践。</p><h5 id="4-1-9-16-锁优化"><a href="#4-1-9-16-锁优化" class="headerlink" title="4.1.9.16 锁优化"></a>4.1.9.16 锁优化</h5><p><strong><em>减少锁持有时间</em></strong></p><p>只用在有线程安全要求的程序上加锁。</p><p><strong><em>减小锁粒度</em></strong></p><p>将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。最最典型的减小锁粒度的案例就是ConcurrentHashMap。</p><p><strong><em>锁分离</em></strong></p><p>最常见的锁分离就是读写锁 ReadWriteLock，根据功能进行分离成读锁和写锁，这样读读不互斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能，具体也请查看[高并发 Java 五] JDK 并发包 1。读写分离思想可以延伸，只要操作互不影响，锁就可以分离。比如LinkedBlockingQueue 从头部取出，从尾部放数据。</p><p><strong><em>锁粗化</em></strong></p><p>通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，应该立即释放锁。但是，凡事都有一个度，如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。</p><p><strong><em>锁消除</em></strong></p><p>锁消除是在编译器级别的事情。在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作，多数是因为程序员编码不规范引起。</p><p><strong>参考：<a href="https://www.jianshu.com/p/39628e1180a9">https://www.jianshu.com/p/39628e1180a9</a></strong></p><h4 id="4-1-10-线程基本方法"><a href="#4-1-10-线程基本方法" class="headerlink" title="4.1.10 线程基本方法"></a>4.1.10 线程基本方法</h4><p>线程相关的基本方法有 wait，notify，notifyAll，sleep，join，yield 等。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/ThreadMethod.png"></p><h5 id="4-1-10-1-线程等待（wait）"><a href="#4-1-10-1-线程等待（wait）" class="headerlink" title="4.1.10.1 线程等待（wait）"></a>4.1.10.1 线程等待（wait）</h5><p>调用该方法的线程进入 WAITING 状态，只有等待另外线程的通知或被中断才会返回，需要注意的是调用 wait()方法后，会释放对象的锁。因此，wait 方法一般用在同步方法或同步代码块中。</p><h5 id="4-1-10-2-线程睡眠（sleep）"><a href="#4-1-10-2-线程睡眠（sleep）" class="headerlink" title="4.1.10.2 线程睡眠（sleep）"></a>4.1.10.2 线程睡眠（sleep）</h5><p>sleep 导致当前线程休眠，与 wait 方法不同的是 sleep 不会释放当前占有的锁,sleep(long)会导致线程进入 TIMED-WATING 状态，而 wait()方法会导致当前线程进入 WATING 状态</p><h5 id="4-1-10-3-线程让步（yield）"><a href="#4-1-10-3-线程让步（yield）" class="headerlink" title="4.1.10.3 线程让步（yield）"></a>4.1.10.3 线程让步（yield）</h5><p>yield 会使当前线程让出 CPU 执行时间片，与其他线程一起重新竞争 CPU 时间片。一般情况下，优先级高的线程有更大的可能性成功竞争得到 CPU 时间片，但这又不是绝对的，有的操作系统对线程优先级并不敏感。</p><h5 id="4-1-10-4-线程中断（interrupt）"><a href="#4-1-10-4-线程中断（interrupt）" class="headerlink" title="4.1.10.4 线程中断（interrupt）"></a>4.1.10.4 线程中断（interrupt）</h5><p>中断一个线程，其本意是给这个线程一个通知信号，会影响这个线程内部的一个中断标识位。这个线程本身并不会因此而改变状态(如阻塞，终止等)。</p><ol><li><p>调用 interrupt()方法并不会中断一个正在运行的线程。也就是说处于 Running 状态的线程并不会因为被中断而被终止，仅仅改变了内部维护的中断标识位而已。</p></li><li><p>若调用 sleep()而使线程处于 TIMED-WATING 状态，这时调用 interrupt()方法，会抛出InterruptedException,从而使线程提前结束 TIMED-WATING 状态。</p></li><li><p>许多声明抛出 InterruptedException 的方法(如 Thread.sleep(long mills 方法))，抛出异常前，都会清除中断标识位，所以抛出异常后，调用 isInterrupted()方法将会返回 false。</p></li><li><p>中断状态是线程固有的一个标识位，可以通过此标识位安全的终止线程。比如,你想终止一个线程 thread 的时候，可以调用 thread.interrupt()方法，在线程的 run 方法内部可以根据 thread.isInterrupted()的值来优雅的终止线程。</p></li></ol><h5 id="4-1-10-5-Join等待其他线程终止"><a href="#4-1-10-5-Join等待其他线程终止" class="headerlink" title="4.1.10.5 Join等待其他线程终止"></a>4.1.10.5 Join等待其他线程终止</h5><p>join() 方法，等待其他线程终止，在当前线程中调用一个线程的 join() 方法，则当前线程转为阻塞状态，回到另一个线程结束，当前线程再由阻塞状态变为就绪状态，等待 cpu 的宠幸。</p><h5 id="4-1-10-6-为什么要用join-方法"><a href="#4-1-10-6-为什么要用join-方法" class="headerlink" title="4.1.10.6 为什么要用join()方法?"></a>4.1.10.6 为什么要用join()方法?</h5><p>很多情况下，主线程生成并启动了子线程，需要用到子线程返回的结果，也就是需要主线程需要在子线程结束后再结束，这时候就要用到 join() 方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">System.out.println(Thread.currentThread().getName() + "线程运行开始!"); Thread6 thread1 = new Thread6(); thread1.setName("线程 B"); thread1.join();System.out.println("这时 thread1 执行完毕之后才能执行主线程");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-1-10-7-线程唤醒（notify）"><a href="#4-1-10-7-线程唤醒（notify）" class="headerlink" title="4.1.10.7 线程唤醒（notify）"></a>4.1.10.7 线程唤醒（notify）</h5><p>Object 类中的 notify() 方法，唤醒在此对象监视器上等待的单个线程，如果所有线程都在此对象上等待，则会选择唤醒其中一个线程，选择是任意的，并在对实现做出决定时发生，线程通过调用其中一个 wait() 方法，在对象的监视器上等待，直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程，被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。类似的方法还有 notifyAll() ，唤醒再次监视器上等待的所有线程。</p><h5 id="4-1-10-8-其他方法"><a href="#4-1-10-8-其他方法" class="headerlink" title="4.1.10.8 其他方法"></a>4.1.10.8 其他方法</h5><ol><li><p>sleep()：强迫一个线程睡眠Ｎ毫秒。</p></li><li><p>isAlive()： 判断一个线程是否存活。</p></li><li><p>join()： 等待线程终止。</p></li><li><p>activeCount()： 程序中活跃的线程数。</p></li><li><p>enumerate()： 枚举程序中的线程。</p></li><li><p>currentThread()： 得到当前线程。</p></li><li><p>isDaemon()： 一个线程是否为守护线程。</p></li><li><p>setDaemon()： 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束) </p></li><li><p>setName()： 为线程设置一个名称。</p></li><li><p>wait()： 强迫一个线程等待。</p></li><li><p>notify()： 通知一个线程继续运行。</p></li><li><p>setPriority()： 设置一个线程的优先级。</p></li><li><p>getPriority():：获得一个线程的优先级。</p></li></ol><h4 id="4-1-11-线程上下文切换"><a href="#4-1-11-线程上下文切换" class="headerlink" title="4.1.11 线程上下文切换"></a>4.1.11 线程上下文切换</h4><p>巧妙地利用了时间片轮转的方式, CPU 给每个任务都服务一定的时间，然后把当前任务的状态保存下来，在加载下一任务的状态后，继续服务下一任务，任务的状态保存及再加载, 这段过程就叫做上下文切换。时间片轮转的方式使多个任务在同一颗 CPU 上执行变成了可能。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/ThreadContextSwitching.png"></p><h5 id="4-1-11-1-进程"><a href="#4-1-11-1-进程" class="headerlink" title="4.1.11.1 进程"></a>4.1.11.1 进程</h5><p>（有时候也称做任务）是指一个程序运行的实例。在 Linux 系统中，线程就是能并行运行并且与他们的父进程（创建他们的进程）共享同一地址空间（一段内存区域）和其他资源的轻量级的进程。</p><h5 id="4-1-11-2-上下文"><a href="#4-1-11-2-上下文" class="headerlink" title="4.1.11.2 上下文"></a>4.1.11.2 上下文</h5><p>是指某一时间点 CPU 寄存器和程序计数器的内容。</p><h5 id="4-1-11-3-寄存器"><a href="#4-1-11-3-寄存器" class="headerlink" title="4.1.11.3 寄存器"></a>4.1.11.3 寄存器</h5><p>是 CPU 内部的数量较少但是速度很快的内存（与之对应的是 CPU 外部相对较慢的 RAM 主内存）。寄存器通过对常用值（通常是运算的中间值）的快速访问来提高计算程序运行的速度。</p><h5 id="4-1-11-4-程序计数器"><a href="#4-1-11-4-程序计数器" class="headerlink" title="4.1.11.4 程序计数器"></a>4.1.11.4 程序计数器</h5><p>是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体依赖于特定的系统。</p><h5 id="4-1-11-5-PCB-“切换桢”"><a href="#4-1-11-5-PCB-“切换桢”" class="headerlink" title="4.1.11.5 PCB-“切换桢”"></a>4.1.11.5 PCB-“切换桢”</h5><p>上下文切换可以认为是内核（操作系统的核心）在 CPU 上对于进程（包括线程）进行切换，上下文切换过程中的信息是保存在进程控制块（PCB, process control block）中的。PCB 还经常被称作“切换桢”（switchframe）。信息会一直保存到 CPU 的内存中，直到他们被再次使用。</p><h5 id="4-1-11-6-上下文切换的活动"><a href="#4-1-11-6-上下文切换的活动" class="headerlink" title="4.1.11.6 上下文切换的活动"></a>4.1.11.6 上下文切换的活动</h5><ol><li><p>挂起一个进程，将这个进程在 CPU 中的状态（上下文）存储于内存中的某处。</p></li><li><p>在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复。</p></li><li><p>跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程在程序中。</p></li></ol><h5 id="4-1-11-7-引起线程上下文切换的原因"><a href="#4-1-11-7-引起线程上下文切换的原因" class="headerlink" title="4.1.11.7 引起线程上下文切换的原因"></a>4.1.11.7 引起线程上下文切换的原因</h5><ol><li><p>当前执行任务的时间片用完之后，系统 CPU 正常调度下一个任务；</p></li><li><p>当前执行任务碰到 IO 阻塞，调度器将此任务挂起，继续下一任务；</p></li><li><p>多个任务抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续下一任务；</p></li><li><p>用户代码挂起当前任务，让出 CPU 时间；</p></li><li><p>硬件中断。</p></li></ol><h4 id="4-1-12-同步锁与死锁"><a href="#4-1-12-同步锁与死锁" class="headerlink" title="4.1.12 同步锁与死锁"></a>4.1.12 同步锁与死锁</h4><h5 id="4-1-12-1-同步锁"><a href="#4-1-12-1-同步锁" class="headerlink" title="4.1.12.1 同步锁"></a>4.1.12.1 同步锁</h5><p>当多个线程同时访问同一个数据时，很容易出现问题。为了避免这种情况出现，我们要保证线程同步互斥，就是指并发执行的多个线程，在同一时间内只允许一个线程访问共享数据。 Java 中可以使用 synchronized 关键字来取得一个对象的同步锁。</p><h5 id="4-1-12-2-死锁"><a href="#4-1-12-2-死锁" class="headerlink" title="4.1.12.2 死锁"></a>4.1.12.2 死锁</h5><p>何为死锁，就是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。</p><h4 id="4-1-13-线程池原理"><a href="#4-1-13-线程池原理" class="headerlink" title="4.1.13 线程池原理"></a>4.1.13 线程池原理</h4><p>线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。他的主要特点为：线程复用；控制最大并发数；管理线程。</p><h5 id="4-1-13-1-线程复用"><a href="#4-1-13-1-线程复用" class="headerlink" title="4.1.13.1 线程复用"></a>4.1.13.1 线程复用</h5><p>每一个 Thread 的类都有一个 start 方法。 当调用 start 启动线程时 Java 虚拟机会调用该类的 run 方法。 那么该类的 run() 方法中就是调用了 Runnable 对象的 run() 方法。 我们可以继承重写Thread 类，在其 start 方法中添加不断循环调用传递过来的 Runnable 对象。 这就是线程池的实现原理。循环方法中不断获取 Runnable 是用 Queue 实现的，在获取下一个 Runnable 之前可以是阻塞的。</p><h5 id="4-1-13-2-线程池的组成"><a href="#4-1-13-2-线程池的组成" class="headerlink" title="4.1.13.2 线程池的组成"></a>4.1.13.2 线程池的组成</h5><p>一般的线程池主要分为以下 4 个组成部分：</p><ol><li><p>线程池管理器：用于创建并管理线程池</p></li><li><p>工作线程：线程池中的线程</p></li><li><p>任务接口：每个任务必须实现的接口，用于工作线程调度其运行</p></li><li><p>任务队列：用于存放待处理的任务，提供一种缓冲机制</p></li></ol><p>Java 中的线程池是通过 Executor 框架实现的，该框架中用到了 Executor，Executors，ExecutorService，ThreadPoolExecutor ，Callable 和 Future、FutureTask 这几个类。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/ExecuterFramework.png"></p><p>ThreadPoolExecutor 的构造方法如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize, long keepAliveTime,TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) {this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,Executors.defaultThreadFactory(), defaultHandler);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>corePoolSize：指定了线程池中的线程数量。</p></li><li><p>maximumPoolSize：指定了线程池中的最大线程数量。</p></li><li><p>keepAliveTime：当前线程池数量超过 corePoolSize 时，多余的空闲线程的存活时间，即多次时间内会被销毁。</p></li><li><p>unit：keepAliveTime 的单位。</p></li><li><p>workQueue：任务队列，被提交但尚未被执行的任务。</p></li><li><p>threadFactory：线程工厂，用于创建线程，一般用默认的即可。</p></li><li><p>handler：拒绝策略，当任务太多来不及处理，如何拒绝任务。</p></li></ol><h5 id="4-1-13-3-拒绝策略"><a href="#4-1-13-3-拒绝策略" class="headerlink" title="4.1.13.3 拒绝策略"></a>4.1.13.3 拒绝策略</h5><p>线程池中的线程已经用完了，无法继续为新任务服务，同时，等待队列也已经排满了，再也塞不下新任务了。这时候我们就需要拒绝策略机制合理的处理这个问题。JDK 内置的拒绝策略如下：</p><ol><li><p>AbortPolicy ： 直接抛出异常，阻止系统正常运行。</p></li><li><p>CallerRunsPolicy ： 只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。</p></li><li><p>DiscardOldestPolicy ： 丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。</p></li><li><p>DiscardPolicy ： 该策略默默地丢弃无法处理的任务，不予任何处理。如果允许任务丢失，这是最好的一种方案。以上内置拒绝策略均实现了 RejectedExecutionHandler 接口，若以上策略仍无法满足实际需要，完全可以自己扩展 RejectedExecutionHandler 接口。</p></li></ol><h5 id="4-1-13-4-Java-线程池工作过程"><a href="#4-1-13-4-Java-线程池工作过程" class="headerlink" title="4.1.13.4 Java 线程池工作过程"></a>4.1.13.4 Java 线程池工作过程</h5><ol><li><p>线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。</p></li><li><p>当调用 execute() 方法添加一个任务时，线程池会做如下判断：</p><p>a) 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</p><p>b) 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</p><p>c) 如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</p><p>d) 如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常 RejectExecutionException。</p></li><li><p>当一个线程完成任务时，它会从队列中取下一个任务来执行。</p></li><li><p>当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/ThreadPoolWorkingProcedure.png"></p></li></ol><h4 id="4-1-14-JAVA阻塞队列原理"><a href="#4-1-14-JAVA阻塞队列原理" class="headerlink" title="4.1.14 JAVA阻塞队列原理"></a>4.1.14 JAVA阻塞队列原理</h4><p>阻塞队列，关键字是阻塞，先理解阻塞的含义，在阻塞队列中，线程阻塞有这样的两种情况：</p><ol><li><p>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/BlockingQueuePQrinciple1.png"></p></li><li><p>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程被自动唤醒。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/BlockingQueuePrinciple2.png"></p></li></ol><h5 id="4-1-14-1-阻塞队列的主要方法"><a href="#4-1-14-1-阻塞队列的主要方法" class="headerlink" title="4.1.14.1 阻塞队列的主要方法"></a>4.1.14.1 阻塞队列的主要方法</h5><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/BlockQueueMainMethod.png"></p><ul><li>抛出异常：抛出一个异常；</li></ul><ul><li>特殊值：返回一个特殊值（null 或 false,视情况而定）</li></ul><ul><li>阻塞：在成功操作之前，一直阻塞线程</li></ul><ul><li>超时：放弃前只在最大的时间内阻塞</li></ul><p><strong><em>插入操作：</em></strong></p><p>1：public abstract boolean add(E paramE)：将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回 true，如果当前没有可用的空间，则抛出 IllegalStateException。如果该元素是 NULL，则会抛出 NullPointerException 异常。</p><p>2：public abstract boolean offer(E paramE)：将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回 true，如果当前没有可用的空间，则返回 false。 </p><p>3：public abstract void put(E paramE) throws InterruptedException： 将指定元素插入此队列中，将等待可用的空间（如果有必要）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void put(E paramE) throws InterruptedException {checkNotNull(paramE);ReentrantLock localReentrantLock = this.lock;localReentrantLock.lockInterruptibly();try {while (this.count == this.items.length)  this.notFull.await();//如果队列满了，则线程阻塞等待enqueue(paramE);localReentrantLock.unlock();} finally {  localReentrantLock.unlock();}} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4：offer(E o, long timeout, TimeUnit unit)：可以设定等待的时间，如果在指定的时间内，还不能往队列中加入 BlockingQueue，则返回失败。</p><p><strong><em>获取数据操作：</em></strong> </p><p>1：poll(time):取走 BlockingQueue 里排在首位的对象,若不能立即取出,则可以等 time 参数规定的时间,取不到时返回 null;</p><p>2：poll(long timeout, TimeUnit unit)：从 BlockingQueue 取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则直到时间超时还没有数据可取，返回失败。</p><p>3：take():取走 BlockingQueue 里排在首位的对象,若 BlockingQueue 为空,阻断进入等待状态直到 BlockingQueue 有新的数据被加入。</p><p>4.drainTo():一次性从 BlockingQueue 获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。</p><h5 id="4-1-14-2-Java-中的阻塞队列"><a href="#4-1-14-2-Java-中的阻塞队列" class="headerlink" title="4.1.14.2 Java 中的阻塞队列"></a>4.1.14.2 Java 中的阻塞队列</h5><ol><li><p>ArrayBlockingQueue ：由数组结构组成的有界阻塞队列。</p></li><li><p>LinkedBlockingQueue ：由链表结构组成的有界阻塞队列。</p></li><li><p>PriorityBlockingQueue ：支持优先级排序的无界阻塞队列。</p></li><li><p>DelayQueue：使用优先级队列实现的无界阻塞队列。</p></li><li><p>SynchronousQueue：不存储元素的阻塞队列。</p></li><li><p>LinkedTransferQueue：由链表结构组成的无界阻塞队列。</p></li><li><p>LinkedBlockingDeque：由链表结构组成的双向阻塞队列</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/BlockingQueueFamily.png"></p></li></ol><h5 id="4-1-14-3-ArrayBlockingQueue（公平、非公平）"><a href="#4-1-14-3-ArrayBlockingQueue（公平、非公平）" class="headerlink" title="4.1.14.3 ArrayBlockingQueue（公平、非公平）"></a>4.1.14.3 ArrayBlockingQueue（公平、非公平）</h5><p>用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐量。我们可以使用以下代码创建一个公平的阻塞队列：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">ArrayBlockingQueue fairQueue = new ArrayBlockingQueue(1000,true);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="4-1-14-4-LinkedBlockingQueue（两个独立锁提高并发）"><a href="#4-1-14-4-LinkedBlockingQueue（两个独立锁提高并发）" class="headerlink" title="4.1.14.4 LinkedBlockingQueue（两个独立锁提高并发）"></a>4.1.14.4 LinkedBlockingQueue（两个独立锁提高并发）</h5><p>基于链表的阻塞队列，同 ArrayListBlockingQueue 类似，此队列按照先进先出（FIFO）的原则对元素进行排序。而 LinkedBlockingQueue 之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。LinkedBlockingQueue 会默认一个类似无限大小的容量（Integer.MAX_VALUE）。</p><h5 id="4-1-14-5-PriorityBlockingQueue（compareTo-排序实现优先）"><a href="#4-1-14-5-PriorityBlockingQueue（compareTo-排序实现优先）" class="headerlink" title="4.1.14.5 PriorityBlockingQueue（compareTo 排序实现优先）"></a>4.1.14.5 PriorityBlockingQueue（compareTo 排序实现优先）</h5><p>是一个支持优先级的无界队列。默认情况下元素采取自然顺序升序排列。可以自定义实现compareTo()方法来指定元素进行排序规则，或者初始化 PriorityBlockingQueue 时，指定构造参数 Comparator 来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。</p><h5 id="4-1-14-6-DelayQueue（缓存失效、定时任务-）"><a href="#4-1-14-6-DelayQueue（缓存失效、定时任务-）" class="headerlink" title="4.1.14.6 DelayQueue（缓存失效、定时任务 ）"></a>4.1.14.6 DelayQueue（缓存失效、定时任务 ）</h5><p>是一个支持延时获取元素的无界阻塞队列。队列使用 PriorityQueue 来实现。队列中的元素必须实现 Delayed 接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。我们可以将 DelayQueue 运用在以下应用场景：</p><ol><li><p>缓存系统的设计：可以用 DelayQueue 保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从 DelayQueue 中获取元素时，表示缓存有效期到了。</p></li><li><p>定时任务调度：使用 DelayQueue 保存当天将会执行的任务和执行时间，一旦从DelayQueue 中获取到任务就开始执行，从比如 TimerQueue 就是使用 DelayQueue 实现的。</p></li></ol><h5 id="4-1-14-7-SynchronousQueue（不存储数据、可用于传递数据）"><a href="#4-1-14-7-SynchronousQueue（不存储数据、可用于传递数据）" class="headerlink" title="4.1.14.7 SynchronousQueue（不存储数据、可用于传递数据）"></a>4.1.14.7 SynchronousQueue（不存储数据、可用于传递数据）</h5><p>是一个不存储元素的阻塞队列。每一个 put 操作必须等待一个 take 操作，否则不能继续添加元素。SynchronousQueue 可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合于传递性场景,比如在一个线程中使用的数据，传递给另 外 一 个 线 程 使 用 ， SynchronousQueue 的 吞 吐 量 高 于 LinkedBlockingQueue 和ArrayBlockingQueue。</p><h5 id="4-1-14-8-LinkedTransferQueue"><a href="#4-1-14-8-LinkedTransferQueue" class="headerlink" title="4.1.14.8 LinkedTransferQueue"></a>4.1.14.8 LinkedTransferQueue</h5><p>是 一 个 由 链 表 结 构 组 成 的 无 界 阻 塞 TransferQueue 队 列 。 相 对 于 其 他 阻 塞 队 列 ，LinkedTransferQueue 多了 tryTransfer 和 transfer 方法。</p><ol><li><p>transfer 方法：如果当前有消费者正在等待接收元素（消费者使用 take()方法或带时间限制的poll()方法时），transfer 方法可以把生产者传入的元素立刻 transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer 方法会将元素存放在队列的 tail 节点，并等到该元素被消费者消费了才返回。</p></li><li><p>tryTransfer 方法。则是用来试探下生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回 false。和 transfer 方法的区别是 tryTransfer 方法无论消费者是否接收，方法立即返回。而 transfer 方法是必须等到消费者消费了才返回。对于带有时间限制的 tryTransfer(E e, long timeout, TimeUnit unit)方法，则是试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回 false，如果在超时时间内消费了元素，则返回 true。</p></li></ol><h5 id="4-1-14-9-LinkedBlockingDeque"><a href="#4-1-14-9-LinkedBlockingDeque" class="headerlink" title="4.1.14.9 LinkedBlockingDeque"></a>4.1.14.9 LinkedBlockingDeque</h5><p>是一个由链表结构组成的双向阻塞队列。所谓双向队列指的你可以从队列的两端插入和移出元素。双端队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque 多了 addFirst，addLast，offerFirst，offerLast，peekFirst，peekLast 等方法，以 First 单词结尾的方法，表示插入，获取（peek）或移除双端队列的第一个元素。以 Last 单词结尾的方法，表示插入，获取或移除双端队列的最后一个元素。另外插入方法 add 等同于 addLast，移除方法 remove 等效于 removeFirst。但是 take 方法却等同于 takeFirst，不知道是不是 Jdk 的 bug，使用时还是用带有 First 和 Last 后缀的方法更清楚。在初始化 LinkedBlockingDeque 时可以设置容量防止其过渡膨胀。另外双向阻塞队列可以运用在“工作窃取”模式中。</p><h4 id="4-1-15-CyclicBarrier、CountDownLatch、Semaphore的用法"><a href="#4-1-15-CyclicBarrier、CountDownLatch、Semaphore的用法" class="headerlink" title="4.1.15 CyclicBarrier、CountDownLatch、Semaphore的用法"></a>4.1.15 CyclicBarrier、CountDownLatch、Semaphore的用法</h4><h5 id="4-1-15-1-CountDownLatch（线程计数器-）"><a href="#4-1-15-1-CountDownLatch（线程计数器-）" class="headerlink" title="4.1.15.1 CountDownLatch（线程计数器 ）"></a>4.1.15.1 CountDownLatch（线程计数器 ）</h5><p>CountDownLatch 类位于 java.util.concurrent 包下，利用它可以实现类似计数器的功能。比如有一个任务 A，它要等待其他 4 个任务执行完毕之后才能执行，此时就可以利用 CountDownLatch来实现这种功能了。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">final CountDownLatch latch = new CountDownLatch(2);  new Thread(){public void run() {System.out.println("子线程"+Thread.currentThread().getName()+"正在执行");Thread.sleep(3000);System.out.println("子线程"+Thread.currentThread().getName()+"执行完毕");latch.countDown();  };}.start();  new Thread(){ public void run() {System.out.println("子线程"+Thread.currentThread().getName()+"正在执行");Thread.sleep(3000);System.out.println("子线程"+Thread.currentThread().getName()+"执行完毕");latch.countDown();  };}.start();  System.out.println("等待 2 个子线程执行完毕...");  latch.await();  System.out.println("2 个子线程已经执行完毕");  System.out.println("继续执行主线程");  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-1-15-2-CyclicBarrier（回环栅栏-等待至-barrier-状态再全部同时执行）"><a href="#4-1-15-2-CyclicBarrier（回环栅栏-等待至-barrier-状态再全部同时执行）" class="headerlink" title="4.1.15.2 CyclicBarrier（回环栅栏-等待至 barrier 状态再全部同时执行）"></a>4.1.15.2 CyclicBarrier（回环栅栏-等待至 barrier 状态再全部同时执行）</h5><p>字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier 可以被重用。我们暂且把这个状态就叫做barrier，当调用 await()方法之后，线程就处于 barrier 了。</p><p>CyclicBarrier 中最重要的方法就是 await 方法，它有 2 个重载版本：</p><ol><li><p>public int await()：用来挂起当前线程，直至所有线程都到达 barrier 状态再同时执行后续任务；</p></li><li><p>public int await(long timeout, TimeUnit unit)：让这些线程等待至一定的时间，如果还有线程没有到达 barrier 状态就直接让到达 barrier 的线程执行后续任务。</p><p>具体使用如下，另外 CyclicBarrier 是可以重用的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> public static void main(String[] args) { int N = 4; CyclicBarrier barrier = new CyclicBarrier(N); for(int i=0;i&lt;N;i++)   new Writer(barrier).start(); } static class Writer extends Thread{   private CyclicBarrier cyclicBarrier;   public Writer(CyclicBarrier cyclicBarrier) {   this.cyclicBarrier = cyclicBarrier;   }   @Override   public void run() {   try {     Thread.sleep(5000); //以睡眠来模拟线程需要预定写入数据操作  System.out.println("线程"+Thread.currentThread().getName()+"写入数据完毕，等待其他线程写入完毕");     cyclicBarrier.await();    } catch (InterruptedException e) {     e.printStackTrace();    }catch(BrokenBarrierException e){     e.printStackTrace();   }  System.out.println("所有线程写入完毕，继续处理其他任务，比如数据操作");   }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-1-15-3-Semaphore（信号量-控制同时访问的线程个数）"><a href="#4-1-15-3-Semaphore（信号量-控制同时访问的线程个数）" class="headerlink" title="4.1.15.3 Semaphore（信号量-控制同时访问的线程个数）"></a>4.1.15.3 Semaphore（信号量-控制同时访问的线程个数）</h5></li></ol><p>Semaphore 翻译成字面意思为 信号量，Semaphore 可以控制同时访问的线程个数，通过acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。Semaphore 类中比较重要的几个方法：</p><ol><li><p>public void acquire(): 用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许可。</p></li><li><p>public void acquire(int permits):获取 permits 个许可</p></li><li><p>public void release() { } :释放许可。注意，在释放许可之前，必须先获获得许可。</p></li><li><p>public void release(int permits) { }:释放 permits 个许可</p></li></ol><p>上面 4 个方法都会被阻塞，如果想立即得到执行结果，可以使用下面几个方法：</p><ol><li><p>public boolean tryAcquire():尝试获取一个许可，若获取成功，则立即返回 true，若获取失败，则立即返回 false</p></li><li><p>public boolean tryAcquire(long timeout, TimeUnit unit):尝试获取一个许可，若在指定的时间内获取成功，则立即返回 true，否则则立即返回 false</p></li><li><p>public boolean tryAcquire(int permits):尝试获取 permits 个许可，若获取成功，则立即返回 true，若获取失败，则立即返回 false</p></li><li><p>public boolean tryAcquire(int permits, long timeout, TimeUnit unit): 尝试获取 permits个许可，若在指定的时间内获取成功，则立即返回 true，否则则立即返回 false</p></li><li><p>还可以通过 availablePermits()方法得到可用的许可数目。</p></li></ol><p>例子：若一个工厂有 5 台机器，但是有 8 个工人，一台机器同时只能被一个工人使用，只有使用完了，其他工人才能继续使用。那么我们就可以通过 Semaphore 来实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int N = 8; //工人数 Semaphore semaphore = new Semaphore(5); //机器数目 for(int i=0;i&lt;N;i++)   new Worker(i,semaphore).start(); } static class Worker extends Thread{ private int num; private Semaphore semaphore; public Worker(int num,Semaphore semaphore){   this.num = num;   this.semaphore = semaphore; } @Override public void run() { try {semaphore.acquire();System.out.println("工人"+this.num+"占用一个机器在生产...");Thread.sleep(2000);System.out.println("工人"+this.num+"释放出机器");semaphore.release();   } catch (InterruptedException e) {e.printStackTrace();   } } <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li> CountDownLatch 和 CyclicBarrier 都能够实现线程之间的等待，只不过它们侧重点不同；CountDownLatch 一般用于某个线程 A 等待若干个其他线程执行完任务之后，它才执行；而 CyclicBarrier 一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；另外，CountDownLatch 是不能够重用的，而 CyclicBarrier 是可以重用的。</li></ul><ul><li>Semaphore 其实和锁有点类似，它一般用于控制对某组资源的访问权限。</li></ul><h4 id="4-1-16-volatile-关键字的作用（变量可见性、禁止重排序）"><a href="#4-1-16-volatile-关键字的作用（变量可见性、禁止重排序）" class="headerlink" title="4.1.16 volatile 关键字的作用（变量可见性、禁止重排序）"></a>4.1.16 volatile 关键字的作用（变量可见性、禁止重排序）</h4><p>Java 语言提供了一种稍弱的同步机制，即 volatile 变量，用来确保将变量的更新操作通知到其他线程。volatile 变量具备两种特性，volatile 变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取 volatile 类型的变量时总会返回最新写入的值。</p><p><strong><em>变量可见性</em></strong></p><p>其一是保证该变量对所有线程可见，这里的可见性指的是当一个线程修改了变量的值，那么新的值对于其他线程是可以立即获取的。</p><p><strong><em>禁止重排序</em></strong></p><p>volatile 禁止了指令重排。 </p><p><strong><em>比sychronized更轻量级的同步锁</em></strong></p><p>在访问 volatile 变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此 volatile 变量是一种比 sychronized 关键字更轻量级的同步机制。volatile 适合这种场景：一个变量被多个线程共享，线程直接给这个变量赋值。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/VolatileLock.png"></p><p>当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到 CPU 缓存中。如果计算机有多个 CPU，每个线程可能在不同的 CPU 上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。</p><p><strong><em>适用场景</em></strong></p><p>值得说明的是对 volatile 变量的单次读/写操作可以保证原子性的，如 long 和 double 类型变量，但是并不能保证 i++这种操作的原子性，因为本质上 i++是读、写两次操作。在某些场景下可以代替 Synchronized。但是,volatile 的不能完全取代 Synchronized 的位置，只有在一些特殊的场景下，才能适用 volatile。总的来说，必须同时满足下面两个条件才能保证在并发环境的线程安全：</p><p> （1）对变量的写操作不依赖于当前值（比如 i++），或者说是单纯的变量赋值（boolean flag = true）。 </p><p>（2）该变量没有包含在具有其他变量的不变式中，也就是说，不同的 volatile 变量之间，不能互相依赖。只有在状态真正独立于程序内其他内容时才能使用 volatile。</p><h4 id="4-1-17-如何在两个线程之间共享数据"><a href="#4-1-17-如何在两个线程之间共享数据" class="headerlink" title="4.1.17 如何在两个线程之间共享数据"></a>4.1.17 如何在两个线程之间共享数据</h4><p>Java 里面进行多线程通信的主要方式就是共享内存的方式，共享内存主要的关注点有两个：可见性和有序性原子性。Java 内存模型（JMM）解决了可见性和有序性的问题，而锁解决了原子性的问题，理想情况下我们希望做到“同步”和“互斥”。有以下常规实现方法：</p><p><strong>将数据抽象成一个类，并将数据的操作作为这个类的方法</strong></p><ol><li><p>将数据抽象成一个类，并将对这个数据的操作作为这个类的方法，这么设计可以和容易做到同步，只要在方法上加”synchronized“</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MyData {private int j=0;  public synchronized void add(){  j++;System.out.println("线程"+Thread.currentThread().getName()+"j 为："+j);  }  public synchronized void dec(){  j--;System.out.println("线程"+Thread.currentThread().getName()+"j 为："+j);  }  public int getData(){return j;  } }public class AddRunnable implements Runnable{MyData data;public AddRunnable(MyData data){  this.data= data;}public void run() {  data.add();}   }public class DecRunnable implements Runnable {MyData data;public DecRunnable(MyData data){  this.data = data;}public void run() {  data.dec();}   }public static void main(String[] args) {MyData data = new MyData();Runnable add = new AddRunnable(data);Runnable dec = new DecRunnable(data);for(int i=0;i&lt;2;i++){  new Thread(add).start();  new Thread(dec).start();  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <strong><em>Runnable对象作为一个类的内部类</em></strong></p></li><li><p>将 Runnable 对象作为一个类的内部类，共享数据作为这个类的成员变量，每个线程对共享数据的操作方法也封装在外部类，以便实现对数据的各个操作的同步和互斥，作为内部类的各个 Runnable 对象调用外部类的这些方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MyData {  private int j=0;  public synchronized void add(){   j++;  System.out.println("线程"+Thread.currentThread().getName()+"j 为："+j);  }  public synchronized void dec(){   j--;  System.out.println("线程"+Thread.currentThread().getName()+"j 为："+j);  }  public int getData(){   return j;  } }public class TestThread { public static void main(String[] args) {  final MyData data = new MyData();  for(int i=0;i&lt;2;i++){         new Thread(new Runnable(){ public void run() {   data.add(); } }).start(); new Thread(new Runnable(){ public void run() {  data.dec();  } }).start(); }   } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-1-18-ThreadLocal作用（线程本地存储）"><a href="#4-1-18-ThreadLocal作用（线程本地存储）" class="headerlink" title="4.1.18 ThreadLocal作用（线程本地存储）"></a>4.1.18 ThreadLocal作用（线程本地存储）</h4></li></ol><p>ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，ThreadLocal 的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。</p><p><strong><em>ThreadLocalMap（线程的一个属性）</em></strong></p><ol><li><p>每个线程中都有一个自己的 ThreadLocalMap 类对象，可以将线程自己的对象保持到其中，各管各的，线程可以正确的访问到自己的对象。</p></li><li><p>将一个共用的 ThreadLocal 静态实例作为 key，将不同对象的引用保存到不同线程的ThreadLocalMap 中，然后在线程执行的各处通过这个静态 ThreadLocal 实例的 get()方法取得自己线程保存的那个对象，避免了将这个对象作为参数传递的麻烦。</p></li><li><p>ThreadLocalMap 其实就是线程里面的一个属性，它在 Thread 类中定义ThreadLocal.ThreadLocalMap threadLocals = null。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/ThreadLocal%3CT%3E.png"></p></li></ol><p><strong><em>使用场景</em></strong></p><p>最常见的 ThreadLocal 使用场景为 用来解决 数据库连接、Session 管理等。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">private static final ThreadLocal threadSession = new ThreadLocal(); public static Session getSession() throws InfrastructureException { Session s = (Session) threadSession.get(); try { if (s == null) { s = getSessionFactory().openSession(); threadSession.set(s);   } } catch (HibernateException ex) {   throw new InfrastructureException(ex); } return s; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-1-19-synchronized和ReentrantLock的区别"><a href="#4-1-19-synchronized和ReentrantLock的区别" class="headerlink" title="4.1.19 synchronized和ReentrantLock的区别"></a>4.1.19 synchronized和ReentrantLock的区别</h4><h5 id="4-1-19-1-两者的共同点："><a href="#4-1-19-1-两者的共同点：" class="headerlink" title="4.1.19.1 两者的共同点："></a>4.1.19.1 两者的共同点：</h5><ol><li><p>都是用来协调多线程对共享对象、变量的访问</p></li><li><p>都是可重入锁，同一线程可以多次获得同一个锁</p></li><li><p>都保证了可见性和互斥性</p></li></ol><h5 id="4-1-19-2-两者的不同点："><a href="#4-1-19-2-两者的不同点：" class="headerlink" title="4.1.19.2 两者的不同点："></a>4.1.19.2 两者的不同点：</h5><ol><li><p>ReentrantLock 显示的获得、释放锁，synchronized 隐式获得释放锁</p></li><li><p>ReentrantLock 可响应中断、可轮回，synchronized 是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性</p></li><li><p>ReentrantLock 是 API 级别的，synchronized 是 JVM 级别的</p></li><li><p>ReentrantLock 可以实现公平锁</p></li><li><p>ReentrantLock 通过 Condition 可以绑定多个条件</p></li><li><p>底层实现不一样， synchronized 是同步阻塞，使用的是悲观并发策略，lock 是同步非阻塞，采用的是乐观并发策略</p></li><li><p>Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言实现。</p></li><li><p>synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁。</p></li><li><p>Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时，等待的线程会一直等待下去，不能够响应中断。</p></li><li><p>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</p></li><li><p>Lock 可以提高多个线程进行读操作的效率，既就是实现读写锁等。</p></li></ol><h4 id="4-1-20-ConcurrentHashMap并发"><a href="#4-1-20-ConcurrentHashMap并发" class="headerlink" title="4.1.20 ConcurrentHashMap并发"></a>4.1.20 ConcurrentHashMap并发</h4><h5 id="4-1-20-1-减小锁粒度"><a href="#4-1-20-1-减小锁粒度" class="headerlink" title="4.1.20.1 减小锁粒度"></a>4.1.20.1 减小锁粒度</h5><p>减小锁粒度是指缩小锁定对象的范围，从而减小锁冲突的可能性，从而提高系统的并发能力。减小锁粒度是一种削弱多线程锁竞争的有效手段，这种技术典型的应用是 ConcurrentHashMap(高性能的 HashMap)类的实现。对于 HashMap 而言，最重要的两个方法是 get 与 set 方法，如果我们对整个 HashMap 加锁，可以得到线程安全的对象，但是加锁粒度太大。Segment 的大小也被称为 ConcurrentHashMap 的并发度。</p><h5 id="4-1-20-2-ConcurrentHashMap-分段锁"><a href="#4-1-20-2-ConcurrentHashMap-分段锁" class="headerlink" title="4.1.20.2 ConcurrentHashMap 分段锁"></a>4.1.20.2 ConcurrentHashMap 分段锁</h5><p>ConcurrentHashMap，它内部细分了若干个小的 HashMap，称之为段(Segment)。默认情况下一个 ConcurrentHashMap 被进一步细分为 16 个段，既就是锁的并发度。</p><p>如果需要在 ConcurrentHashMap 中添加一个新的表项，并不是将整个 HashMap 加锁，而是首先根据 hashcode 得到该表项应该存放在哪个段中，然后对该段加锁，并完成 put 操作。在多线程环境中，如果多个线程同时进行 put操作，只要被加入的表项不存放在同一个段中，则线程间可以做到真正的并行。</p><p><strong><em>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成</em></strong></p><p>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。Segment 是一种可重入锁 ReentrantLock，在 ConcurrentHashMap 里扮演锁的角色，HashEntry 则用于存储键值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，Segment 的结构和 HashMap类似，是一种数组和链表结构， 一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素， 每个 Segment 守护一个 HashEntry 数组里的元素,当对 HashEntry 数组的数据进行修改时，必须首先获得它对应的 Segment 锁。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/ConcurrentHashMapComposition.png"></p><h4 id="4-1-21-Java中用到的线程调度"><a href="#4-1-21-Java中用到的线程调度" class="headerlink" title="4.1.21 Java中用到的线程调度"></a>4.1.21 Java中用到的线程调度</h4><h5 id="4-1-21-1-抢占式调度："><a href="#4-1-21-1-抢占式调度：" class="headerlink" title="4.1.21.1 抢占式调度："></a>4.1.21.1 抢占式调度：</h5><p>抢占式调度指的是每条线程执行的时间、线程的切换都由系统控制，系统控制指的是在系统某种运行机制下，可能每条线程都分同样的执行时间片，也可能是某些线程执行的时间片较长，甚至某些线程得不到执行的时间片。在这种机制下，一个线程的堵塞不会导致整个进程堵塞。</p><h5 id="4-1-21-2-协同式调度："><a href="#4-1-21-2-协同式调度：" class="headerlink" title="4.1.21.2 协同式调度："></a>4.1.21.2 协同式调度：</h5><p>协同式调度指某一线程执行完后主动通知系统切换到另一线程上执行，这种模式就像接力赛一样，一个人跑完自己的路程就把接力棒交接给下一个人，下个人继续往下跑。线程的执行时间由线程本身控制，线程切换可以预知，不存在多线程同步问题，但它有一个致命弱点：如果一个线程编写有问题，运行到一半就一直堵塞，那么可能导致整个系统崩溃。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/CollaborativeScheduling.png" alt="image-20210203164550442"></p><h5 id="4-1-21-3-JVM-的线程调度实现（抢占式调度）"><a href="#4-1-21-3-JVM-的线程调度实现（抢占式调度）" class="headerlink" title="4.1.21.3 JVM 的线程调度实现（抢占式调度）"></a>4.1.21.3 JVM 的线程调度实现（抢占式调度）</h5><p>java 使用的线程调使用抢占式调度，Java 中线程会按优先级分配 CPU 时间片运行，且优先级越高越优先执行，但优先级高并不代表能独自占用执行时间片，可能是优先级高得到越多的执行时间片，反之，优先级低的分到的执行时间少但不会分配不到执行时间。</p><h5 id="4-1-21-4-线程让出-cpu-的情况："><a href="#4-1-21-4-线程让出-cpu-的情况：" class="headerlink" title="4.1.21.4 线程让出 cpu 的情况："></a>4.1.21.4 线程让出 cpu 的情况：</h5><ol><li><p>当前运行线程主动放弃 CPU，JVM 暂时放弃 CPU 操作（基于时间片轮转调度的 JVM 操作系统不会让线程永久放弃 CPU，或者说放弃本次时间片的执行权），例如调用 yield()方法。</p></li><li><p>当前运行线程因为某些原因进入阻塞状态，例如阻塞在 I/O 上。</p></li><li><p>当前运行线程结束，即运行完 run()方法里面的任务。</p></li></ol><h4 id="4-1-22-进程调度算法"><a href="#4-1-22-进程调度算法" class="headerlink" title="4.1.22  进程调度算法"></a>4.1.22  进程调度算法</h4><h5 id="4-1-22-1-优先调度算法"><a href="#4-1-22-1-优先调度算法" class="headerlink" title="4.1.22.1 优先调度算法"></a>4.1.22.1 优先调度算法</h5><ol><li><p>先来先服务调度算法（FCFS）</p><p>当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用 FCFS 算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机，特点是：算法比较简单，可以实现基本上的公平。</p></li><li><p>短作业(进程)优先调度算法</p></li></ol><p>短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。该算法未照顾紧迫型作业。</p><h5 id="4-1-22-2-高优先权优先调度算法"><a href="#4-1-22-2-高优先权优先调度算法" class="headerlink" title="4.1.22.2 高优先权优先调度算法"></a>4.1.22.2 高优先权优先调度算法</h5><p> 为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程。</p><ol><li>非抢占式优先权算法</li></ol><p>在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。</p><ol start="2"><li>抢占式优先权调度算法</li></ol><p>在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。</p><p>​    3. 高响应比优先调度算法</p><p> 在批处理系统中，短作业优先算法是一种比较好的算法，其主要的不足之处是长作业的运行得不到保证。如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时间的增加而以速率 a 提高，则长作业在等待一定的时间后，必然有机会分配到处理机。该优先权的变化规律可描述为：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/HighResponseRatioPrioritySchedulingAlgorithm.png"></p><p> (1) 如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而该算法有利于短作业。</p><p> (2) 当要求服务的时间相同时，作业的优先权决定于其等待时间，等待时间愈长，其优先权愈高，因而它实现的是先来先服务。</p><p> (3) 对于长作业，作业的优先级可以随等待时间的增加而提高，当其等待时间足够长时，其优先级便可升到很高，从而也可获得处理机。简言之，该算法既照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务。因此，该算法实现了一种较好的折衷。当然，在利用该算法时，每要进行调度之前，都须先做响应比的计算，这会增加系统开销。</p><h5 id="4-1-22-3-基于时间片的轮转调度算法"><a href="#4-1-22-3-基于时间片的轮转调度算法" class="headerlink" title="4.1.22.3 基于时间片的轮转调度算法"></a>4.1.22.3 基于时间片的轮转调度算法</h5><ol><li>时间片轮转法</li></ol><p>在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把 CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几 ms 到几百 ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。</p><ol start="2"><li><p>多级反馈队列调度算法</p><p>(1) 应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第 i+1 个队列的时间片要比第 i 个队列的时间片长一倍。</p><p>(2) 当一个新进程进入内存后，首先将它放入第一队列的末尾，按 FCFS 原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按 FCFS 原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第 n 队列后，在第 n 队列便采取按时间片轮转的方式运行。</p></li></ol><p>(3) 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第 1～(i-1)队列均空时，才会调度第 i 队列中的进程运行。如果处理机正在第 i 队列中为某进程服务时，又有新进程进入优先权较高的队列(第 1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第 i 队列的末尾，把处理机分配给新到的高优先权进程。</p><p>​    在多级反馈队列调度算法中，如果规定第一个队列的时间片略大于多数人机交互所需之处理时间时，便能够较好的满足各种类型用户的需要。</p><h4 id="4-1-23-什么是CAS（比较并交换-乐观锁机制-锁自旋）"><a href="#4-1-23-什么是CAS（比较并交换-乐观锁机制-锁自旋）" class="headerlink" title="4.1.23 什么是CAS（比较并交换-乐观锁机制-锁自旋）"></a>4.1.23 什么是CAS（比较并交换-乐观锁机制-锁自旋）</h4><h5 id="4-1-23-1-概念及特性"><a href="#4-1-23-1-概念及特性" class="headerlink" title="4.1.23.1 概念及特性"></a>4.1.23.1 概念及特性</h5><p>CAS（Compare And Swap/Set）比较并交换，CAS 算法的过程是这样：它包含 3 个参数CAS(V,E,N)。V 表示要更新的变量(内存值)，E 表示预期值(旧的)，N 表示新值。当且仅当 V 值等于 E 值时，才会将 V 的值设为 N，如果 V 值和 E 值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS 返回当前 V 的真实值。</p><p>CAS 操作是抱着乐观的态度进行的(乐观锁)，它总是认为自己可以成功完成操作。当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理，CAS 操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。</p><h5 id="4-1-23-2-原子包-java-util-concurrent-atomic（锁自旋）"><a href="#4-1-23-2-原子包-java-util-concurrent-atomic（锁自旋）" class="headerlink" title="4.1.23.2 原子包 java.util.concurrent.atomic（锁自旋）"></a>4.1.23.2 原子包 java.util.concurrent.atomic（锁自旋）</h5><p>JDK1.5 的原子包：java.util.concurrent.atomic 这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由 JVM 从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。相对于对于 synchronized 这种阻塞算法，CAS 是非阻塞算法的一种常见实现。由于一般 CPU 切换时间比 CPU 指令集操作更加长， 所以 J.U.C 在性能上有了很大的提升。如下代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class AtomicInteger extends Number implements java.io.Serializable { private volatile int value; public final int get() { return value; } public final int getAndIncrement() { for (;;) { //CAS 自旋，一直尝试，直达成功int current = get(); int next = current + 1; if (compareAndSet(current, next)) return current; } } public final boolean compareAndSet(int expect, int update) { return unsafe.compareAndSwapInt(this, valueOffset, expect, update); } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>getAndIncrement 采用了 CAS 操作，每次从内存中读取数据然后将此数据和+1 后的结果进行CAS 操作，如果成功就返回结果，否则重试直到成功为止。而 compareAndSet 利用 JNI 来完成CPU 指令的操作。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/CAS.png"></p><h5 id="4-1-23-3-ABA-问题"><a href="#4-1-23-3-ABA-问题" class="headerlink" title="4.1.23.3 ABA 问题"></a>4.1.23.3 ABA 问题</h5><p>CAS 会导致“ABA 问题”。CAS 算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。</p><p>比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但是不代表这个过程就是没有问题的。</p><p>部分乐观锁的实现是通过版本号（version）的方式来解决 ABA 问题，乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1 操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现 ABA 问题，因为版本号只会增加不会减少。</p><h4 id="4-1-24-什么是AQS（抽象的队列同步器）"><a href="#4-1-24-什么是AQS（抽象的队列同步器）" class="headerlink" title="4.1.24 什么是AQS（抽象的队列同步器）"></a>4.1.24 什么是AQS（抽象的队列同步器）</h4><p>AbstractQueuedSynchronizer 类如其名，抽象的队列式的同步器，AQS 定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/CLFQueueFIFO.png"></p><p>它维护了一个 volatile int state（代表共享资源）和一个 FIFO 线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里 volatile 是核心关键词，具体 volatile 的语义，在此不述。state 的访问方式有三种:</p><p>​        getState()</p><p>​        setState()</p><p>​        compareAndSetState()</p><p><strong><em>AQS 定义两种资源共享方式：</em></strong></p><ul><li><p><strong>Exclusive独占资源-ReentrantLock</strong></p><p>Exclusive（独占，只有一个线程能执行，如 ReentrantLock）</p></li><li><p><strong>Share共享资源-Semaphore/CountDownLatch</strong></p><p>Share（共享，多个线程可同时执行，如 Semaphore/CountDownLatch）。</p></li></ul><p>AQS 只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现，AQS 这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过 state 的 get/set/CAS)之所以没有定义成abstract ，是 因 为独 占模 式 下 只 用实现 tryAcquire-tryRelease ，而 共享 模 式 下 只用 实 现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p><p>1．isHeldExclusively()：该线程是否正在独占资源。只有用到 condition 才需要去实现它。</p><p>2．tryAcquire(int)：独占方式。尝试获取资源，成功则返回 true，失败则返回 false。 </p><p>3．tryRelease(int)：独占方式。尝试释放资源，成功则返回 true，失败则返回 false。 </p><p>4．tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</p><p>5．tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回 false。</p><p><strong><em>同步器的实现是ABS核心（state资源状态计数）</em></strong></p><p>同步器的实现是 ABS 核心，以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到 A 线程 unlock()到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。</p><p>以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown()一次，state会 CAS 减 1。等到所有子线程都执行完后(即 state=0)，会 unpark()主调用线程，然后主调用线程就会从 await()函数返回，继续后余动作。</p><p><strong><em>ReentrantReadWriteLock实现独占和共享两种方式</em></strong></p><p> 一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现 tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared 中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如 ReentrantReadWriteLock。</p><h2 id="5-JAVA基础"><a href="#5-JAVA基础" class="headerlink" title="5. JAVA基础"></a><strong>5. JAVA基础</strong></h2><h4 id="5-1-1-JAVA-异常分类及处理"><a href="#5-1-1-JAVA-异常分类及处理" class="headerlink" title="5.1.1 JAVA 异常分类及处理"></a>5.1.1 JAVA 异常分类及处理</h4><h5 id="5-1-1-1-概念"><a href="#5-1-1-1-概念" class="headerlink" title="5.1.1.1 概念"></a>5.1.1.1 概念</h5><p>如果某个方法不能按照正常的途径完成任务，就可以通过另一种路径退出方法。在这种情况下会抛出一个封装了错误信息的对象。此时，这个方法会立刻退出同时不返回任何值。另外，调用这个方法的其他代码也无法继续执行，异常处理机制会将代码执行交给异常处理器。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/JavaAbnormalClassification.png"></p><h5 id="5-1-1-2-异常分类"><a href="#5-1-1-2-异常分类" class="headerlink" title="5.1.1.2 异常分类"></a>5.1.1.2 异常分类</h5><p>Throwable 是 Java 语言中所有错误或异常的超类。下一层分为 Error 和 Exception </p><p><strong><em>Error</em></strong></p><ol><li>Error 类是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。</li></ol><p><strong><em>Exception（RuntimeException、CheckedException）</em></strong></p><ol start="2"><li>Exception 又 有 两 个 分 支 ， 一 个 是 运 行 时 异 常 RuntimeException ， 一 个 是CheckedException。</li></ol><p><strong><em>RuntimeException</em></strong> 如 ： NullPointerException 、 ClassCastException ； 一 个 是 检 查 异 常CheckedException，如 I/O 错误导致的 IOException、SQLException。 RuntimeException 是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。 如果出现 RuntimeException，那么一定是程序员的错误.</p><p><strong><em>检查异常 CheckedException</em></strong>：一般是外部错误，这种异常都发生在编译阶段，Java 编译器会强制程序去捕获此类异常，即会出现要求你把这段可能出现异常的程序进行 try catch，该类异常一般包括几个方面：</p><ol><li><p>试图在文件尾部读取数据</p></li><li><p>试图打开一个错误格式的 URL </p></li><li><p>试图根据给定的字符串查找 class 对象，而这个字符串表示的类并不存在</p></li></ol><h5 id="5-1-1-3-异常的处理方式"><a href="#5-1-1-3-异常的处理方式" class="headerlink" title="5.1.1.3 异常的处理方式"></a>5.1.1.3 异常的处理方式</h5><p><strong><em>遇到问题不进行具体处理，而是继续抛给调用者 （throw,throws）</em></strong></p><p>抛出异常有三种形式，一是 throw,一个 throws，还有一种系统自动抛异常。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) {  String s = "abc";  if(s.equals("abc")) {  throw new NumberFormatException();  } else {  System.out.println(s);  } } int div(int a,int b) throws Exception{return a/b;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>try catch捕获异常针对性处理方式</em></strong></p><h5 id="5-1-1-4-Throw-和-throws-的区别："><a href="#5-1-1-4-Throw-和-throws-的区别：" class="headerlink" title="5.1.1.4 Throw 和 throws 的区别："></a>5.1.1.4 Throw 和 throws 的区别：</h5><p><strong><em>位置不同</em></strong></p><ol><li>throws 用在函数上，后面跟的是异常类，可以跟多个；而 throw 用在函数内，后面跟的是异常对象。</li></ol><p><strong><em>功能不同：</em></strong></p><ol start="2"><li><p>throws 用来声明异常，让调用者只知道该功能可能出现的问题，可以给出预先的处理方式；throw 抛出具体的问题对象，执行到 throw，功能就已经结束了，跳转到调用者，并将具体的问题对象抛给调用者。也就是说 throw 语句独立存在时，下面不要定义其他语句，因为执行不到。</p></li><li><p>throws 表示出现异常的一种可能性，并不一定会发生这些异常；throw 则是抛出了异常，执行 throw 则一定抛出了某种异常对象。</p></li><li><p>两者都是消极处理异常的方式，只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。</p></li></ol><h4 id="5-1-2-JAVA反射"><a href="#5-1-2-JAVA反射" class="headerlink" title="5.1.2 JAVA反射"></a>5.1.2 JAVA反射</h4><h5 id="5-1-2-1-动态语言"><a href="#5-1-2-1-动态语言" class="headerlink" title="5.1.2.1 动态语言"></a>5.1.2.1 动态语言</h5><p>动态语言，是指程序在运行时可以改变其结构：新的函数可以引进，已有的函数可以被删除等结构上的变化。比如常见的 JavaScript 就是动态语言，除此之外 Ruby,Python 等也属于动态语言，而 C、C++则不属于动态语言。从反射角度说 JAVA 属于半动态语言。</p><h5 id="5-1-2-2-反射机制概念-（运行状态中知道类所有的属性和方法）"><a href="#5-1-2-2-反射机制概念-（运行状态中知道类所有的属性和方法）" class="headerlink" title="5.1.2.2 反射机制概念 （运行状态中知道类所有的属性和方法）"></a>5.1.2.2 反射机制概念 （运行状态中知道类所有的属性和方法）</h5><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/JavaReflection.png"></p><p>在 Java 中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为 Java 语言的反射机制。</p><h5 id="5-1-2-3-反射的应用场合"><a href="#5-1-2-3-反射的应用场合" class="headerlink" title="5.1.2.3 反射的应用场合"></a>5.1.2.3 反射的应用场合</h5><p><strong><em>编译时类型和运行时类型</em></strong></p><p>在 Java 程序中许多对象在运行是都会出现两种类型：编译时类型和运行时类型。 编译时的类型由声明对象时实用的类型来决定，运行时的类型由实际赋值给对象的类型决定 。如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Person p=new Student();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中编译时类型为 Person，运行时类型为 Student。</p><p><strong><em>编译时类型无法获取具体方法</em></strong></p><p>程序在运行时还可能接收到外部传入的对象，该对象的编译时类型为 Object,但是程序有需要调用该对象的运行时类型的方法。为了解决这些问题，程序需要在运行时发现对象和类的真实信息。然而，如果编译时根本无法预知该对象和类属于哪些类，程序只能依靠运行时信息来发现该对象和类的真实信息，此时就必须使用到反射了。</p><h5 id="5-1-2-4-Java-反射-API"><a href="#5-1-2-4-Java-反射-API" class="headerlink" title="5.1.2.4 Java 反射 API"></a>5.1.2.4 Java 反射 API</h5><p><strong><em>反射API用来生成JVM中的类、接口或则对象的信息。</em></strong></p><ol><li><p>Class 类：反射的核心类，可以获取类的属性，方法等信息。</p></li><li><p>Field 类：Java.lang.reflec 包中的类，表示类的成员变量，可以用来获取和设置类之中的属性值。</p></li><li><p>Method 类： Java.lang.reflec 包中的类，表示类的方法，它可以用来获取类中的方法信息或者执行方法。</p></li><li><p>Constructor 类： Java.lang.reflec 包中的类，表示类的构造方法。</p></li></ol><h5 id="5-1-2-5-反射使用步骤（获取-Class-对象、调用对象方法）"><a href="#5-1-2-5-反射使用步骤（获取-Class-对象、调用对象方法）" class="headerlink" title="5.1.2.5 反射使用步骤（获取 Class 对象、调用对象方法）"></a>5.1.2.5 反射使用步骤（获取 Class 对象、调用对象方法）</h5><ol><li><p>获取想要操作的类的 Class 对象，他是反射的核心，通过 Class 对象我们可以任意调用类的方法。</p></li><li><p>调用 Class 类中的方法，既就是反射的使用阶段。</p></li><li><p>使用反射 API 来操作这些信息。</p></li></ol><h5 id="5-1-2-6-获取-Class-对象的-3-种方法"><a href="#5-1-2-6-获取-Class-对象的-3-种方法" class="headerlink" title="5.1.2.6 获取 Class 对象的 3 种方法"></a>5.1.2.6 获取 Class 对象的 3 种方法</h5><p><strong><em>调用某个对象的getClass()方法</em></strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Person p=new Person();Class clazz=p.getClass();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong><em>调用某个类的class属性来获取该类对应的Class对象</em></strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Class clazz=Person.class;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong><em>使用Class类中的forName()静态方法(最安全/性能最好)</em></strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Class clazz=Class.forName("类的全路径"); (最常用)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当我们获得了想要操作的类的 Class 对象后，可以通过 Class 类中的方法获取并查看该类中的方法和属性。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//获取 Person 类的 Class 对象Class clazz=Class.forName("reflection.Person");//获取 Person 类的所有方法信息Method[] method=clazz.getDeclaredMethods();for(Method m:method){System.out.println(m.toString());}//获取 Person 类的所有成员属性信息Field[] field=clazz.getDeclaredFields();for(Field f:field){System.out.println(f.toString());}//获取 Person 类的所有构造方法信息Constructor[] constructor=clazz.getDeclaredConstructors();for(Constructor c:constructor){System.out.println(c.toString());}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="5-1-2-7-创建对象的两种方法"><a href="#5-1-2-7-创建对象的两种方法" class="headerlink" title="5.1.2.7 创建对象的两种方法"></a>5.1.2.7 创建对象的两种方法</h5><p><strong><em>Class对象的newInstance()</em></strong></p><ol><li>使用 Class 对象的 newInstance()方法来创建该 Class 对象对应类的实例，但是这种方法要求该 Class 对象对应的类有默认的空构造器。</li></ol><p><strong><em>调用Constructor对象的newInstance()</em></strong></p><ol start="2"><li><p>先使用 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 newInstance()方法来创建 Class 对象对应类的实例,通过这种方法可以选定构造方法创建实例。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> //获取 Person 类的 Class 对象 Class clazz=Class.forName("reflection.Person");  //使用.newInstane 方法创建对象 Person p=(Person) clazz.newInstance();//获取构造方法并创建对象 Constructor c=clazz.getDeclaredConstructor(String.class,String.class,int.class); //创建对象并设置属性 Person p1=(Person) c.newInstance("李四","男",20);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-1-3-JAVA注解"><a href="#5-1-3-JAVA注解" class="headerlink" title="5.1.3 JAVA注解"></a>5.1.3 JAVA注解</h4></li></ol><h5 id="5-1-3-1-概念"><a href="#5-1-3-1-概念" class="headerlink" title="5.1.3.1 概念"></a>5.1.3.1 概念</h5><p>Annotation（注解）是 Java 提供的一种对元程序中元素关联信息和元数据（metadata）的途径和方法。Annatation(注解)是一个接口，程序可以通过反射来获取指定程序中元素的 Annotation对象，然后通过该 Annotation 对象来获取注解中的元数据信息。</p><h5 id="5-1-3-2-4-种标准元注解"><a href="#5-1-3-2-4-种标准元注解" class="headerlink" title="5.1.3.2  4 种标准元注解"></a>5.1.3.2  4 种标准元注解</h5><p>元注解的作用是负责注解其他注解。 Java5.0 定义了 4 个标准的 meta-annotation 类型，它们被用来提供对其它 annotation 类型作说明。</p><p><strong><em>@Target修饰的对象范围</em></strong></p><p>@Target说明了Annotation所修饰的对象范围： Annotation可被用于 packages、types（类、接口、枚举、Annotation 类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch 参数）。在 Annotation 类型的声明中使用了 target 可更加明晰其修饰的目标</p><p><strong><em>@Retention定义 被保留的时间长短</em></strong></p><p>Retention 定义了该 Annotation 被保留的时间长短：表示需要在什么级别保存注解信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效），取值（RetentionPoicy）由：</p><ul><li>SOURCE:在源文件中有效（即源文件保留）</li></ul><ul><li>CLASS:在 class 文件中有效（即 class 保留）</li></ul><ul><li>RUNTIME:在运行时有效（即运行时保留）</li></ul><p><strong><em>@Documented描述-javadoc</em></strong></p><p>@ Documented 用于描述其它类型的 annotation 应该被作为被标注的程序成员的公共 API，因此可以被例如 javadoc 此类的工具文档化。</p><p><strong><em>@Inherited阐述了某个被标注的类型是被继承的</em></strong></p><p>@Inherited 元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 修饰的 annotation 类型被用于一个 class，则这个 annotation 将被用于该class 的子类。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/JavaAnnotation.png"></p><h5 id="5-1-3-3-注解处理器"><a href="#5-1-3-3-注解处理器" class="headerlink" title="5.1.3.3 注解处理器"></a>5.1.3.3 注解处理器</h5><p>如果没有用来读取注解的方法和工作，那么注解也就不会比注释更有用处了。使用注解的过程中，很重要的一部分就是创建于使用注解处理器。Java SE5 扩展了反射机制的 API，以帮助程序员快速的构造自定义注解处理器。下面实现一个注解处理器。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/1：*** 定义注解*/@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface FruitProvider {     /**供应商编号*/    public int id() default -1;    /*** 供应商名称*/    public String name() default ""；     /** * 供应商地址*/    public String address() default "";}//2：注解使用public class Apple {     @FruitProvider(id = 1, name = "陕西红富士集团", address = "陕西省西安市延安路")     private String appleProvider;     public void setAppleProvider(String appleProvider) {     this.appleProvider = appleProvider;     }     public String getAppleProvider() {     return appleProvider;     } }/3：*********** 注解处理器 ***************/public class FruitInfoUtil {     public static void getFruitInfo(Class&lt;?&gt; clazz) {     String strFruitProvicer = "供应商信息：";     Field[] fields = clazz.getDeclaredFields();//通过反射获取处理注解     for (Field field : fields) {     if (field.isAnnotationPresent(FruitProvider.class)) {     FruitProvider fruitProvider = (FruitProvider) field.getAnnotation(FruitProvider.class);    //注解信息的处理地方     strFruitProvicer = " 供应商编号：" + fruitProvider.id() + " 供应商名称："     \+ fruitProvider.name() + " 供应商地址："+ fruitProvider.address();     System.out.println(strFruitProvicer);     }     }   } }public class FruitRun { public static void main(String[] args) { FruitInfoUtil.getFruitInfo(Apple.class);/***********输出结果***************/// 供应商编号：1 供应商名称：陕西红富士集团 供应商地址：陕西省西安市延 } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-1-4-JAVA内部类"><a href="#5-1-4-JAVA内部类" class="headerlink" title="5.1.4 JAVA内部类"></a>5.1.4 JAVA内部类</h4><p>Java 类中不仅可以定义变量和方法，还可以定义类，这样定义在类内部的类就被称为内部类。根据定义的方式不同，内部类分为静态内部类，成员内部类，局部内部类，匿名内部类四种。</p><h5 id="5-1-4-1-静态内部类"><a href="#5-1-4-1-静态内部类" class="headerlink" title="5.1.4.1  静态内部类"></a>5.1.4.1  静态内部类</h5><p>定义在类内部的静态类，就是静态内部类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Out {     private static int a;     private int b;     public static class Inner {     public void print() {     System.out.println(a);     }   } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>静态内部类可以访问外部类所有的静态变量和方法，即使是 private 的也一样。</p></li><li><p>静态内部类和一般类一致，可以定义静态变量、方法，构造方法等。</p></li><li><p>其它类使用静态内部类需要使用“外部类.静态内部类”方式，如下所示：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Out.Inner inner = new Out.Inner();inner.print();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>Java集合类HashMap内部就有一个静态内部类Entry。Entry是HashMap存放元素的抽象，HashMap 内部维护 Entry 数组用了存放元素，但是 Entry 对使用者是透明的。像这种和外部类关系密切的，且不依赖外部类实例的，都可以使用静态内部类。</p></li></ol><h5 id="5-1-4-2-成员内部类"><a href="#5-1-4-2-成员内部类" class="headerlink" title="5.1.4.2 成员内部类"></a>5.1.4.2 成员内部类</h5><p>定义在类内部的非静态类，就是成员内部类。成员内部类不能定义静态方法和变量（final 修饰的除外）。这是因为成员内部类是非静态的，类初始化的时候先初始化静态成员，如果允许成员内部类定义静态变量，那么成员内部类的静态变量初始化顺序是有歧义的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> public class Out {     private static int a;     private int b;     public class Inner {     public void print() {     System.out.println(a);    System.out.println(b);     }     } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="5-1-4-3-局部内部类（定义在方法中的类）"><a href="#5-1-4-3-局部内部类（定义在方法中的类）" class="headerlink" title="5.1.4.3  局部内部类（定义在方法中的类）"></a>5.1.4.3  局部内部类（定义在方法中的类）</h5><p>定义在方法中的类，就是局部类。如果一个类只在某个方法中使用，则可以考虑使用局部类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> public class Out {     private static int a;     private int b;     public void test(final int c) {     final int d = 1;     class Inner {     public void print() {     System.out.println(c);     }         }     } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="5-1-4-4-匿名内部类（要继承一个父类或者实现一个接口、直接使用new来生成一个对象的引用）"><a href="#5-1-4-4-匿名内部类（要继承一个父类或者实现一个接口、直接使用new来生成一个对象的引用）" class="headerlink" title="5.1.4.4 匿名内部类（要继承一个父类或者实现一个接口、直接使用new来生成一个对象的引用）"></a>5.1.4.4 匿名内部类（要继承一个父类或者实现一个接口、直接使用new来生成一个对象的引用）</h5><p>匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口。同时它也是没有 class 关键字，这是因为匿名内部类是直接使用 new 来生成一个对象的引用。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract class Bird { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } public abstract int fly();}public class Test { public void test(Bird bird){ System.out.println(bird.getName() + "能够飞 " + bird.fly() + "米"); }    public static void main(String[] args) { Test test = new Test(); test.test(new Bird() { public int fly() { return 10000; } public String getName() { return "大雁"; } });} }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-1-5-JAVA泛型"><a href="#5-1-5-JAVA泛型" class="headerlink" title="5.1.5 JAVA泛型"></a>5.1.5 JAVA泛型</h4><p>泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。比如我们要写一个排序方法，能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，我们就可以使用 Java 泛型。</p><h5 id="5-1-5-1-泛型方法（）"><a href="#5-1-5-1-泛型方法（）" class="headerlink" title="5.1.5.1  泛型方法（）"></a>5.1.5.1  泛型方法（<e>）</e></h5><p>你可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 泛型方法 printArray public static &lt; E &gt; void printArray( E[] inputArray ){ for ( E element : inputArray ){ System.out.printf( "%s ", element );}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><!--? extends T-->表示该通配符所代表的类型是 T 类型的子类。</li><li><!--? super T-->表示该通配符所代表的类型是 T 类型的父类。</li></ol><h5 id="5-1-5-2-泛型类"><a href="#5-1-5-2-泛型类" class="headerlink" title="5.1.5.2 泛型类"></a>5.1.5.2 泛型类<t></t></h5><p>泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Box&lt;T&gt; {     private T t;     public void add(T t) {     this.t = t;     }     public T get() {     return t; }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="5-1-5-3-类型通配符"><a href="#5-1-5-3-类型通配符" class="headerlink" title="5.1.5.3 类型通配符?"></a>5.1.5.3 类型通配符?</h5><p>类型通配符一般是使用 ? 代 替 具 体 的 类 型 参 数 。 例 如 List&lt;?&gt; 在逻辑上是List<string>,List<integer> 等所有 List&lt;具体类型实参&gt;的父类。</integer></string></p><h5 id="5-1-5-4-类型擦除"><a href="#5-1-5-4-类型擦除" class="headerlink" title="5.1.5.4 类型擦除"></a>5.1.5.4 类型擦除</h5><p>Java 中的泛型基本上都是在编译器这个层次来实现的。在生成的 Java 字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。如在代码中定义的 List<object>和 List<string>等类型，在编译之后都会变成 List。JVM 看到的只是 List，而由泛型附加的类型信息对 JVM 来说是不可见的。类型擦除的基本过程也比较简单，首先是找到用来替换类型参数的具体类。这个具体类一般是 Object。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换成具体的类。<p></p><h4 id="5-1-6-JAVA-序列化-创建可复用的Java对象"><a href="#5-1-6-JAVA-序列化-创建可复用的Java对象" class="headerlink" title="5.1.6 JAVA 序列化(创建可复用的Java对象)"></a>5.1.6 JAVA 序列化(创建可复用的Java对象)</h4><p><strong><em>保存(持久化)对象及其状态到内存或者磁盘</em></strong></p><p>Java 平台允许我们在内存中创建可复用的 Java 对象，但一般情况下，只有当 JVM 处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比 JVM 的生命周期更长。但在现实应用中，就可能要求在JVM停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。Java 对象序列化就能够帮助我们实现该功能。</p><p><strong><em>序列化对象以字节数组保持-静态成员不保存</em></strong></p><p>使用 Java 对象序列化，在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装成对象。必须注意地是，对象序列化保存的是对象的”状态”，即它的成员变量。由此可知，对象序列化不会关注类中的静态变量。</p><p><strong><em>序列化用户远程对象传输</em></strong></p><p>除了在持久化对象时会用到对象序列化之外，当使用 RMI(远程方法调用)，或在网络中传递对象时，都会用到对象序列化。Java序列化API为处理对象序列化提供了一个标准机制，该API简单易用。</p><p><strong><em>Serializable 实现序列化</em></strong></p><p>在 Java 中，只要一个类实现了 java.io.Serializable 接口，那么它就可以被序列化。</p><p><strong><em>ObjectOutputStream和ObjectInputStream对对象进行序列化及反序列化</em></strong></p><p>通过 ObjectOutputStream 和 ObjectInputStream 对对象进行序列化及反序列化。</p><p><strong><em>writeObject和readObject自定义序列化策略</em></strong></p><p>在类中增加 writeObject 和 readObject 方法可以实现自定义序列化策略。</p><p><strong><em>序列化 ID</em></strong></p><p>虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID）</p><p><strong><em>序列化并不保存静态变量</em></strong></p><p><strong><em>序列化子父类说明</em></strong></p><p>要想将父类对象也序列化，就需要让父类也实现 Serializable 接口。</p><p><strong><em>Transient 关键字阻止该变量被序列化到文件中</em></strong></p><ol><li><p>在变量声明前加上 Transient 关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。</p></li><li><p>服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。</p></li></ol><h4 id="5-1-7-JAVA复制"><a href="#5-1-7-JAVA复制" class="headerlink" title="5.1.7 JAVA复制"></a>5.1.7 JAVA复制</h4><p>将一个对象的引用复制给另外一个对象，一共有三种方式。第一种方式是直接赋值，第二种方式是浅拷贝，第三种是深拷贝。所以大家知道了哈，这三种概念实际上都是为了拷贝对象。</p><h5 id="5-1-7-1-直接赋值复制"><a href="#5-1-7-1-直接赋值复制" class="headerlink" title="5.1.7.1 直接赋值复制"></a>5.1.7.1 直接赋值复制</h5><p>直接赋值。在 Java 中，A a1 = a2，我们需要理解的是这实际上复制的是引用，也就是说 a1 和 a2 指向的是同一个对象。因此，当 a1 变化的时候，a2 里面的成员变量也会跟着变化。</p><h5 id="5-1-7-2-浅复制（复制引用但不复制引用的对象）"><a href="#5-1-7-2-浅复制（复制引用但不复制引用的对象）" class="headerlink" title="5.1.7.2 浅复制（复制引用但不复制引用的对象）"></a>5.1.7.2 浅复制（复制引用但不复制引用的对象）</h5><p>创建一个新对象，然后将当前对象的非静态字段复制到该新对象，如果字段是值类型的，那么对该字段执行复制；如果该字段是引用类型的话，则复制引用但不复制引用的对象。因此，原始对象及其副本引用同一个对象。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Resume implements Cloneable{  public Object clone() {  try {  return (Resume)super.clone();  } catch (Exception e) {  e.printStackTrace();  return null;  }   } } <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="5-1-7-3-深复制（复制对象和其应用对象）"><a href="#5-1-7-3-深复制（复制对象和其应用对象）" class="headerlink" title="5.1.7.3 深复制（复制对象和其应用对象）"></a>5.1.7.3 深复制（复制对象和其应用对象）</h5><p>深拷贝不仅复制对象本身，而且复制对象包含的引用指向的所有对象。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Student implements Cloneable {     String name;     int age;     Professor p;     Student(String name, int age, Professor p) {         this.name = name;         this.age = age;         this.p = p; } public Object clone() { Student o = null; try { o = (Student) super.clone(); } catch (CloneNotSupportedException e) { System.out.println(e.toString()); } o.p = (Professor) p.clone(); return o;} }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="5-1-7-4-序列化（深-clone-一中实现）"><a href="#5-1-7-4-序列化（深-clone-一中实现）" class="headerlink" title="5.1.7.4 序列化（深 clone 一中实现）"></a>5.1.7.4 序列化（深 clone 一中实现）</h5><p>在 Java 语言里深复制一个对象，常常可以先使对象实现 Serializable 接口，然后把对象（实际上只是对象的一个拷贝）写到一个流里，再从流里读出来，便可以重建对象。</p><h2 id="6-Spring-原理"><a href="#6-Spring-原理" class="headerlink" title="6. Spring 原理"></a><strong>6. Spring 原理</strong></h2><p>它是一个全面的、企业应用开发一站式的解决方案，贯穿表现层、业务层、持久层。但是 Spring仍然可以和其他的框架无缝整合。</p><h4 id="6-1-1-Spring-特点"><a href="#6-1-1-Spring-特点" class="headerlink" title="6.1.1 Spring 特点"></a>6.1.1 Spring 特点</h4><h5 id="6-1-1-1-轻量级"><a href="#6-1-1-1-轻量级" class="headerlink" title="6.1.1.1 轻量级"></a>6.1.1.1 轻量级</h5><h5 id="6-1-1-2-控制反转"><a href="#6-1-1-2-控制反转" class="headerlink" title="6.1.1.2 控制反转"></a>6.1.1.2 控制反转</h5><h5 id="6-1-1-3-面向切面"><a href="#6-1-1-3-面向切面" class="headerlink" title="6.1.1.3 面向切面"></a>6.1.1.3 面向切面</h5><h5 id="6-1-1-4-容器"><a href="#6-1-1-4-容器" class="headerlink" title="6.1.1.4 容器"></a>6.1.1.4 容器</h5><h5 id="6-1-1-5-框架集合"><a href="#6-1-1-5-框架集合" class="headerlink" title="6.1.1.5 框架集合"></a>6.1.1.5 框架集合</h5><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/SpringCharacteristics.png"></p><h4 id="6-1-2-Spring-核心组件"><a href="#6-1-2-Spring-核心组件" class="headerlink" title="6.1.2 Spring 核心组件"></a>6.1.2 Spring 核心组件</h4><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/SpringCoreComponents.png"></p><h4 id="6-1-3-Spring-常用模块"><a href="#6-1-3-Spring-常用模块" class="headerlink" title="6.1.3 Spring 常用模块"></a>6.1.3 Spring 常用模块</h4><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/SpringCommonlyModules.png"></p><h4 id="6-1-4-Spring-主要包"><a href="#6-1-4-Spring-主要包" class="headerlink" title="6.1.4 Spring 主要包"></a>6.1.4 Spring 主要包</h4><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/SpringMainPackage.png"></p><h4 id="6-1-5-Spring-常用注解"><a href="#6-1-5-Spring-常用注解" class="headerlink" title="6.1.5 Spring 常用注解"></a>6.1.5 Spring 常用注解</h4><p>bean 注入与装配的的方式有很多种，可以通过 xml，get set 方式，构造函数或者注解等。简单易用的方式就是使用 Spring 的注解了，Spring 提供了大量的注解方式。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/SpringCommonlyAnnotations.png"></p><h4 id="6-1-6-Spring-第三方结合"><a href="#6-1-6-Spring-第三方结合" class="headerlink" title="6.1.6 Spring 第三方结合"></a>6.1.6 Spring 第三方结合</h4><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/SpringThirdPartyFrameworkIntegration.png"></p><h4 id="6-1-7-Spring-IOC-原理"><a href="#6-1-7-Spring-IOC-原理" class="headerlink" title="6.1.7 Spring IOC 原理"></a>6.1.7 Spring IOC 原理</h4><h5 id="6-1-7-1-概念"><a href="#6-1-7-1-概念" class="headerlink" title="6.1.7.1 概念"></a>6.1.7.1 概念</h5><p>Spring 通过一个配置文件描述 Bean 及 Bean 之间的依赖关系，利用 Java 语言的反射功能实例化Bean 并建立 Bean 之间的依赖关系。 Spring 的 IoC 容器在完成这些底层工作的基础上，还提供了 Bean 实例缓存、生命周期管理、 Bean 实例代理、事件发布、资源装载等高级服务。</p><h5 id="6-1-7-2-Spring-容器高层视图"><a href="#6-1-7-2-Spring-容器高层视图" class="headerlink" title="6.1.7.2 Spring 容器高层视图"></a>6.1.7.2 Spring 容器高层视图</h5><p>Spring 启动时读取应用程序提供的 Bean 配置信息，并在 Spring 容器中生成一份相应的 Bean 配置注册表，然后根据这张注册表实例化 Bean，装配好 Bean 之间的依赖关系，为上层应用提供准备就绪的运行环境。其中 Bean 缓存池为 HashMap 实现。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/SpringContainer.png"></p><h5 id="6-1-7-3-IOC-容器实现"><a href="#6-1-7-3-IOC-容器实现" class="headerlink" title="6.1.7.3 IOC 容器实现"></a>6.1.7.3 IOC 容器实现</h5><p><strong><em>BeanFactory-框架基础设施</em></strong></p><p>BeanFactory 是 Spring 框架的基础设施，面向 Spring 本身；ApplicationContext 面向使用Spring 框架的开发者，几乎所有的应用场合我们都直接使用 ApplicationContext 而非底层的 BeanFactory。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/BeanFactoryClassInheritanceSystem.png"></p><p><strong><em>1.1..1.1.1 BeanDefinitionRegistry 注册表</em></strong></p><ol><li>Spring 配置文件中每一个节点元素在 Spring 容器里都通过一个 BeanDefinition 对象表示，它描述了 Bean 的配置信息。而 BeanDefinitionRegistry 接口提供了向容器手工注册BeanDefinition 对象的方法。</li></ol><p><strong><em>1.1..1.1.2 BeanFactory 顶层接口</em></strong></p><ol start="2"><li>位于类结构树的顶端 ，它最主要的方法就是 getBean(String beanName)，该方法从容器中返回特定名称的 Bean，BeanFactory 的功能通过其他的接口得到不断扩展：</li></ol><p><strong><em>1.1..1.1.3 ListableBeanFactory</em></strong></p><ol start="3"><li>该接口定义了访问容器中 Bean 基本信息的若干方法，如查看 Bean 的个数、获取某一类型Bean 的配置名、查看容器中是否包括某一 Bean 等方法；</li></ol><p><strong><em>1.1..1.1.4 HierarchicalBeanFactory 父子级联</em></strong></p><ol start="4"><li>父子级联 IoC 容器的接口，子容器可以通过接口方法访问父容器； 通过HierarchicalBeanFactory 接口， Spring 的 IoC 容器可以建立父子层级关联的容器体系，子容器可以访问父容器中的 Bean，但父容器不能访问子容器的 Bean。Spring 使用父子容器实现了很多功能，比如在 Spring MVC 中，展现层 Bean 位于一个子容器中，而业务层和持久层的 Bean 位于父容器中。这样，展现层 Bean 就可以引用业务层和持久层的 Bean，而业务层和持久层的 Bean 则看不到展现层的 Bean。</li></ol><p><strong><em>1.1..1.1.5 ConfigurableBeanFactory</em></strong></p><ol start="5"><li>是一个重要的接口，增强了 IoC 容器的可定制性，它定义了设置类装载器、属性编辑器、容器初始化后置处理器等方法；</li></ol><p><strong><em>1.1..1.1.6 AutowireCapableBeanFactory 自动装配</em></strong></p><ol start="6"><li>定义了将容器中的 Bean 按某种规则（如按名字匹配、按类型匹配等）进行自动装配的方法；</li></ol><p><strong><em>1.1..1.1.7 SingletonBeanRegistry 运行期间注册单例 Bean</em></strong></p><ol start="7"><li>定义了允许在运行期间向容器注册单实例 Bean 的方法；对于单实例（ singleton）的 Bean 来说，BeanFactory 会缓存 Bean 实例，所以第二次使用 getBean() 获取 Bean 时将直接从IoC 容器的缓存中获取 Bean 实例。Spring 在 DefaultSingletonBeanRegistry 类中提供了一个用于缓存单实例 Bean 的缓存器，它是一个用 HashMap 实现的缓存器，单实例的 Bean 以beanName 为键保存在这个 HashMap 中。</li></ol><p><strong><em>1.1..1.1.8 依赖日志框框</em></strong></p><ol start="8"><li>在初始化 BeanFactory 时，必须为其提供一种日志框架，比如使用 Log4J， 即在类路径下提供 Log4J 配置文件，这样启动 Spring 容器才不会报错。</li></ol><p><strong><em>ApplicationContext 面向开发应用</em></strong></p><p>ApplicationContext 由 BeanFactory 派 生 而 来 ， 提 供 了 更 多 面 向 实 际 应 用 的 功 能 。ApplicationContext 继承了 HierarchicalBeanFactory 和 ListableBeanFactory 接口，在此基础上，还通过多个其他的接口扩展了 BeanFactory 的功能：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/ApplicationClassInheritanceSystem.png"></p><ol><li><p>ClassPathXmlApplicationContext：默认从类路径加载配置文件</p></li><li><p>FileSystemXmlApplicationContext：默认从文件系统中装载配置文件</p></li><li><p>ApplicationEventPublisher：让容器拥有发布应用上下文事件的功能，包括容器启动事件、关闭事件等。</p></li><li><p>MessageSource：为应用提供 i18n 国际化消息访问的功能；</p></li><li><p>ResourcePatternResolver ： 所 有 ApplicationContext 实现类都实现了类似于PathMatchingResourcePatternResolver 的功能，可以通过带前缀的 Ant 风格的资源文件路径装载 Spring 的配置文件。</p></li><li><p>LifeCycle：该接口是 Spring 2.0 加入的，该接口提供了 start()和 stop()两个方法，主要用于控制异步处理过程。在具体使用时，该接口同时被 ApplicationContext 实现及具体Bean 实现， ApplicationContext 会将 start/stop 的信息传递给容器中所有实现了该接口的 Bean，以达到管理和控制 JMX、任务调度等目的。</p></li><li><p>ConfigurableApplicationContext 扩展于 ApplicationContext，它新增加了两个主要的方法： refresh()和 close()，让 ApplicationContext 具有启动、刷新和关闭应用上下文的能力。在应用上下文关闭的情况下调用 refresh()即可启动应用上下文，在已经启动的状态下，调用 refresh()则清除缓存并重新装载配置信息，而调用 close()则可关闭应用上下文。</p></li></ol><p><strong><em>WebApplication 体系架构</em></strong></p><p>WebApplicationContext 是专门为 Web 应用准备的，它允许从相对于 Web 根目录的路径中装载配置文件完成初始化工作。从 WebApplicationContext 中可以获得ServletContext 的引用，整个 Web 应用上下文对象将作为属性放置到 ServletContext 中，以便 Web 应用环境可以访问 Spring 应用上下文。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/WebApplicationSystemFrame.png"></p><h5 id="6-1-7-4-Spring-Bean-作用域"><a href="#6-1-7-4-Spring-Bean-作用域" class="headerlink" title="6.1.7.4 Spring Bean 作用域"></a>6.1.7.4 Spring Bean 作用域</h5><p>Spring 3 中为 Bean 定义了 5 中作用域，分别为 singleton（单例）、prototype（原型）、request、session 和 global session，5 种作用域说明如下：</p><p><strong><em>singleton：单例模式（多线程下不安全）</em></strong></p><ol><li>singleton：单例模式，Spring IoC 容器中只会存在一个共享的 Bean 实例，无论有多少个Bean 引用它，始终指向同一对象。该模式在多线程下是不安全的。Singleton 作用域是Spring 中的缺省作用域，也可以显示的将 Bean 定义为 singleton 模式，配置为：</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;bean id="userDao" class="com.ioc.UserDaoImpl" scope="singleton"/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong><em>prototype: 原型模式每次使用时创建</em></strong></p><ol start="2"><li>prototype:原型模式，每次通过 Spring 容器获取 prototype 定义的 bean 时，容器都将创建一个新的 Bean 实例，每个 Bean 实例都有自己的属性和状态，而 singleton 全局只有一个对象。根据经验，对有状态的bean使用prototype作用域，而对无状态的bean使用singleton作用域。 </li></ol><p><strong><em>Request：一次 request 一个实例</em></strong></p><ol start="3"><li>request：在一次 Http 请求中，容器会返回该 Bean 的同一实例。而对不同的 Http 请求则会产生新的 Bean，而且该 bean 仅在当前 Http Request 内有效,当前 Http 请求结束，该 bean实例也将会被销毁。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;bean id="loginAction" class="com.cnblogs.Login" scope="request"/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong><em>session</em></strong></p><ol start="4"><li>session：在一次 Http Session 中，容器会返回该 Bean 的同一实例。而对不同的 Session 请求则会创建新的实例，该 bean 实例仅在当前 Session 内有效。同 Http 请求相同，每一次session 请求创建新的实例，而不同的实例之间不共享属性，且实例仅在自己的 session 请求内有效，请求结束，则实例将被销毁。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;bean id="userPreference" class="com.ioc.UserPreference" scope="session"/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong><em>global Session</em></strong></p><ol start="5"><li>global Session：在一个全局的 Http Session 中，容器会返回该 Bean 的同一个实例，仅在使用 portlet context 时有效。</li></ol><h5 id="6-1-7-5-Spring-Bean-生命周期"><a href="#6-1-7-5-Spring-Bean-生命周期" class="headerlink" title="6.1.7.5 Spring Bean 生命周期"></a>6.1.7.5 Spring Bean 生命周期</h5><p><strong><em>实例化</em></strong></p><ol><li>实例化一个 Bean，也就是我们常说的 new。</li></ol><p><strong><em>IOC 依赖注入</em></strong></p><ol start="2"><li>按照 Spring 上下文对实例化的 Bean 进行配置，也就是 IOC 注入。</li></ol><p><strong><em>setBeanName 实现</em></strong></p><ol start="3"><li>如果这个 Bean 已经实现了 BeanNameAware 接口，会调用它实现的 setBeanName(String)方法，此处传递的就是 Spring 配置文件中 Bean 的 id 值</li></ol><p><strong><em>BeanFactoryAware 实现</em></strong></p><ol start="4"><li>如果这个 Bean 已经实现了 BeanFactoryAware 接口，会调用它实现的 setBeanFactory，setBeanFactory(BeanFactory)传递的是 Spring 工厂自身（可以用这个方式来获取其它 Bean，只需在 Spring 配置文件中配置一个普通的 Bean 就可以）。1</li></ol><p><strong><em>ApplicationContextAware 实现</em></strong></p><ol start="5"><li>如果这个 Bean 已经实现了 ApplicationContextAware 接口，会调用setApplicationContext(ApplicationContext)方法，传入 Spring 上下文（同样这个方式也可以实现步骤 4 的内容，但比 4 更好，因为 ApplicationContext 是 BeanFactory 的子接口，有更多的实现方法）</li></ol><p><strong><em>postProcessBeforeInitialization 接口实现-初始化预处理</em></strong></p><ol start="6"><li>如果这个 Bean 关联了 BeanPostProcessor 接口，将会调用postProcessBeforeInitialization(Object obj, String s)方法，BeanPostProcessor 经常被用作是 Bean 内容的更改，并且由于这个是在 Bean 初始化结束时调用那个的方法，也可以被应用于内存或缓存技术。</li></ol><p><strong><em>init-method</em></strong></p><ol start="7"><li>如果 Bean 在 Spring 配置文件中配置了 init-method 属性会自动调用其配置的初始化方法。</li></ol><p><strong><em>postProcessAfterInitialization</em></strong></p><ol start="8"><li><p>如果这个 Bean 关联了 BeanPostProcessor 接口，将会调用postProcessAfterInitialization(Object obj, String s)方法。</p><p>注：以上工作完成以后就可以应用这个 Bean 了，那这个 Bean 是一个 Singleton 的，所以一般情况下我们调用同一个 id 的 Bean 会是在内容地址相同的实例，当然在 Spring 配置文件中也可以配置非 Singleton。 </p></li></ol><p><strong><em>Destroy 过期自动清理阶段</em></strong></p><ol start="9"><li>当 Bean 不再需要时，会经过清理阶段，如果 Bean 实现了 DisposableBean 这个接口，会调用那个其实现的 destroy()方法；</li></ol><p><strong><em>destroy-method 自配置清理</em></strong></p><ol start="10"><li><p>最后，如果这个 Bean 的 Spring 配置中配置了 destroy-method 属性，会自动调用其配置的销毁方法。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/BeanLifecycleInApplicationContext.png"></p></li><li><p>bean 标签有两个重要的属性（init-method 和 destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct 和@PreDestroy）。</p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;bean id="" class="" init-method="初始化方法" destroy-method="销毁方法"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="6-1-7-6-Spring-依赖注入四种方式"><a href="#6-1-7-6-Spring-依赖注入四种方式" class="headerlink" title="6.1.7.6 Spring 依赖注入四种方式"></a>6.1.7.6 Spring 依赖注入四种方式</h5><p><strong><em>构造器注入</em></strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/*带参数，方便利用构造器进行注入*/  public CatDaoImpl(String message){  this. message = message;  } &lt;bean id="CatDaoImpl" class="com.CatDaoImpl"&gt; &lt;constructor-arg value=" message "&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;**setter** **方法注入** public class Id {      private int id;      public int getId() { return id; }      public void setId(int id) { this.id = id; } } &lt;bean id="id" class="com.id "&gt; &lt;property name="id" value="123"&gt;&lt;/property&gt; &lt;/bean&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>静态工厂注入</em></strong></p><p>静态工厂顾名思义，就是通过调用静态工厂的方法来获取自己需要的对象，为了让 spring 管理所有对象，我们不能直接通过”工程类.静态方法()”来获取对象，而是依然通过 spring 注入的形式获取：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DaoFactory { //静态工厂  public static final FactoryDao getStaticFactoryDaoImpl()   { return new StaticFacotryDaoImpl();   } } public class SpringAction {  private FactoryDao staticFactoryDao; //注入对象 //注入对象的 set 方法  public void setStaticFactoryDao(FactoryDao staticFactoryDao) {  this.staticFactoryDao = staticFactoryDao;  } } //factory-method="getStaticFactoryDaoImpl"指定调用哪个工厂方法&lt;bean name="springAction" class=" SpringAction" &gt;  &lt;!--使用静态工厂的方法注入对象,对应下面的配置文件--&gt;  &lt;property name="staticFactoryDao" ref="staticFactoryDao"&gt;&lt;/property&gt;  &lt;/bean&gt;  &lt;!--此处获取对象的方式是从工厂类中获取静态方法--&gt; &lt;bean name="staticFactoryDao" class="DaoFactory" factory-method="getStaticFactoryDaoImpl"&gt;&lt;/bean&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>实例工厂</em></strong></p><p>实例工厂的意思是获取对象实例的方法不是静态的，所以你需要首先 new 工厂类，再调用普通的实例方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> public class DaoFactory { //实例工厂  public FactoryDao getFactoryDaoImpl(){  return new FactoryDaoImpl();  } } public class SpringAction {  private FactoryDao factoryDao; //注入对象  public void setFactoryDao(FactoryDao factoryDao) {  this.factoryDao = factoryDao;  } }  &lt;bean name="springAction" class="SpringAction"&gt;  &lt;!--使用实例工厂的方法注入对象,对应下面的配置文件--&gt; &lt;property name="factoryDao" ref="factoryDao"&gt;&lt;/property&gt;  &lt;/bean&gt;  &lt;!--此处获取对象的方式是从工厂类中获取实例方法--&gt; &lt;bean name="daoFactory" class="com.DaoFactory"&gt;&lt;/bean&gt; &lt;bean name="factoryDao" factory-bean="daoFactory"factory-method="getFactoryDaoImpl"&gt;&lt;/bean&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="6-1-7-7-5-种不同方式的自动装配"><a href="#6-1-7-7-5-种不同方式的自动装配" class="headerlink" title="6.1.7.7  5 种不同方式的自动装配"></a>6.1.7.7  5 种不同方式的自动装配</h5><p>Spring 装配包括手动装配和自动装配，手动装配是有基于 xml 装配、构造方法、setter 方法等自动装配有五种自动装配的方式，可以用来指导 Spring 容器用自动装配方式来进行依赖注入。</p><ol><li><p>no：默认的方式是不进行自动装配，通过显式设置 ref 属性来进行装配。</p></li><li><p>byName：通过参数名 自动装配，Spring 容器在配置文件中发现 bean 的 autowire 属性被设置成 byname，之后容器试图匹配、装配和该 bean 的属性具有相同名字的 bean。</p></li><li><p>byType：通过参数类型自动装配，Spring 容器在配置文件中发现 bean 的 autowire 属性被设置成 byType，之后容器试图匹配、装配和该 bean 的属性具有相同类型的 bean。如果有多个 bean 符合条件，则抛出错误。</p></li><li><p>constructor：这个方式类似于 byType， 但是要提供给构造器参数，如果没有确定的带参数的构造器参数类型，将会抛出异常。</p></li><li><p>autodetect：首先尝试使用 constructor 来自动装配，如果无法工作，则使用 byType 方式。</p></li></ol><h4 id="6-1-8-Spring-APO-原理"><a href="#6-1-8-Spring-APO-原理" class="headerlink" title="6.1.8 Spring APO 原理"></a>6.1.8 Spring APO 原理</h4><h5 id="6-1-8-1-概念"><a href="#6-1-8-1-概念" class="headerlink" title="6.1.8.1 概念"></a>6.1.8.1 概念</h5><p>“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。</p><p>使用”横切”技术，AOP 把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</p><p><strong><em>AOP 主要应用场景有：</em></strong></p><ol><li><p>Authentication 权限</p></li><li><p>Caching 缓存</p></li><li><p>Context passing 内容传递</p></li><li><p>Error handling 错误处理</p></li><li><p>Lazy loading 懒加载</p></li><li><p>Debugging 调试</p></li><li><p>logging, tracing, profiling and monitoring 记录跟踪 优化 校准</p></li><li><p>Performance optimization 性能优化</p></li><li><p>Persistence 持久化</p></li><li><p>Resource pooling 资源池</p></li><li><p>Synchronization 同步</p></li><li><p>Transactions 事务</p></li></ol><h5 id="6-1-8-2-AOP-核心概念"><a href="#6-1-8-2-AOP-核心概念" class="headerlink" title="6.1.8.2 AOP 核心概念"></a>6.1.8.2 AOP 核心概念</h5><p>1、切面（aspect）：类是对物体特征的抽象，切面就是对横切关注点的抽象</p><p>2、横切关注点：对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点。 </p><p>3、连接点（joinpoint）：被拦截到的点，因为 Spring 只支持方法类型的连接点，所以在 Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器。 </p><p>4、切入点（pointcut）：对连接点进行拦截的定义</p><p>5、通知（advice）：所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕通知五类。 </p><p>6、目标对象：代理的目标对象</p><p>7、织入（weave）：将切面应用到目标对象并导致代理对象创建的过程</p><p>8、引入（introduction）：在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段。</p><p><strong>参考：<a href="https://segmentfault.com/a/1190000007469968">https://segmentfault.com/a/1190000007469968</a></strong></p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/AOPCore.png"></p><h5 id="6-1-8-3-AOP-两种代理方式"><a href="#6-1-8-3-AOP-两种代理方式" class="headerlink" title="6.1.8.3 AOP 两种代理方式"></a>6.1.8.3 AOP 两种代理方式</h5><p>Spring 提供了两种方式来生成代理对象: JDKProxy 和 Cglib，具体使用哪种方式生成由AopProxyFactory 根据 AdvisedSupport 对象的配置来决定。默认的策略是如果目标类是接口，则使用 JDK 动态代理技术，否则使用 Cglib 来生成代理。</p><p><strong><em>JDK 动态接口代理</em></strong></p><ol><li>JDK 动态代理主要涉及到 java.lang.reflect 包中的两个类：Proxy 和 InvocationHandler。InvocationHandler是一个接口，通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态将横切逻辑和业务逻辑编制在一起。Proxy 利用 InvocationHandler 动态创建一个符合某一接口的实例，生成目标类的代理对象。</li></ol><p><strong><em>CGLib 动态代理</em></strong></p><ol start="2"><li>CGLib 全称为 Code Generation Library，是一个强大的高性能，高质量的代码生成类库，可以在运行期扩展 Java 类与实现 Java 接口，CGLib 封装了 asm，可以再运行期动态生成新的 class。和 JDK 动态代理相比较：JDK 创建代理有一个限制，就是只能为接口创建代理实例，而对于没有通过接口定义业务方法的类，则可以通过 CGLib 创建动态代理。</li></ol><h5 id="6-1-8-4-实现原理"><a href="#6-1-8-4-实现原理" class="headerlink" title="6.1.8.4 实现原理"></a>6.1.8.4 实现原理</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Aspectpublic class TransactionDemo { @Pointcut(value="execution(* com.yangxin.core.service.*.*.*(..))") public void point(){ } @Before(value="point()") public void before(){ System.out.println("transaction begin"); } @AfterReturning(value = "point()") public void after(){ System.out.println("transaction commit"); } @Around("point()") public void around(ProceedingJoinPoint joinPoint) throws Throwable{     System.out.println("transaction begin");     joinPoint.proceed();     System.out.println("transaction commit"); } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/AOPPrinciple.png"></p><h4 id="6-1-9-Spring-MVC-原理"><a href="#6-1-9-Spring-MVC-原理" class="headerlink" title="6.1.9 Spring MVC 原理"></a>6.1.9 Spring MVC 原理</h4><p>Spring 的模型-视图-控制器（MVC）框架是围绕一个 DispatcherServlet 来设计的，这个 Servlet会把请求分发给各个处理器，并支持可配置的处理器映射、视图渲染、本地化、时区与主题渲染等，甚至还能支持文件上传。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/SpringMVCProcess.png"></p><h5 id="6-1-9-1-MVC-流程"><a href="#6-1-9-1-MVC-流程" class="headerlink" title="6.1.9.1 MVC 流程"></a>6.1.9.1 MVC 流程</h5><p><strong>Http</strong> <strong>请求到</strong> <strong>DispatcherServlet</strong></p><p>(1) 客户端请求提交到 DispatcherServlet。</p><p><strong>HandlerMapping</strong> <strong>寻找处理器</strong></p><p>(2) 由 DispatcherServlet 控制器查询一个或多个 HandlerMapping，找到处理请求的Controller。</p><p><strong>调用处理器</strong> <strong>Controller</strong></p><p>(3) DispatcherServlet 将请求提交到 Controller。</p><p><strong>Controller</strong> <strong>调用业务逻辑处理后，返回</strong> <strong>ModelAndView</strong></p><p>(4)(5)调用业务处理和返回结果：Controller 调用业务逻辑处理后，返回 ModelAndView。</p><p><strong>DispatcherServlet</strong> <strong>查询</strong> <strong>ModelAndView</strong></p><p>(6)(7)处理视图映射并返回模型： DispatcherServlet 查询一个或多个 ViewResoler 视图解析器，找到 ModelAndView 指定的视图。</p><p><strong>ModelAndView</strong> <strong>反馈浏览器</strong> <strong>HTTP</strong></p><p>(8) Http 响应：视图负责将结果显示到客户端。</p><p> <img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/MVCAnnotations.png"></p><h4 id="6-1-10-Spring-Boot原理"><a href="#6-1-10-Spring-Boot原理" class="headerlink" title="6.1.10 Spring Boot原理"></a>6.1.10 Spring Boot原理</h4><p>Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot 致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。其特点如下：</p><p><strong>1.</strong> <strong>创建独立的Spring应用程序</strong></p><p><strong>2.</strong> <strong>嵌入的Tomcat，无需部署 WAR 文件</strong></p><p><strong>3.</strong> <strong>简化Maven配置</strong></p><p><strong>4.</strong> <strong>自动配置Spring</strong></p><p><strong>5.</strong> <strong>提供生产就绪型功能，如指标，健康检查和外部配置</strong></p><p><strong>6.</strong> <strong>绝对没有代码生成和对XML没有要求配置[1]</strong></p><h4 id="6-1-11-JPA原理"><a href="#6-1-11-JPA原理" class="headerlink" title="6.1.11 JPA原理"></a>6.1.11 JPA原理</h4><h5 id="6-1-11-1-事务"><a href="#6-1-11-1-事务" class="headerlink" title="6.1.11.1 事务"></a>6.1.11.1 事务</h5><p>事务是计算机应用中不可或缺的组件模型，它保证了用户操作的原子性 ( Atomicity )、一致性( Consistency )、隔离性 ( Isolation ) 和持久性 ( Durabilily )。</p><h5 id="6-1-11-2-本地事务"><a href="#6-1-11-2-本地事务" class="headerlink" title="6.1.11.2 本地事务"></a>6.1.11.2 本地事务</h5><p>紧密依赖于底层资源管理器（例如数据库连接 )，事务处理局限在当前事务资源内。此种事务处理方式不存在对应用服务器的依赖，因而部署灵活却无法支持多数据源的分布式事务。在数据库连接中使用本地事务示例如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void transferAccount() { Connection conn = null; Statement stmt = null;   try{ conn = getDataSource().getConnection(); // 将自动提交设置为 false，若设置为 true 则数据库将会把每一次数据更新认定为一个事务并自动提交conn.setAutoCommit(false);stmt = conn.createStatement(); // 将 A 账户中的金额减少 500stmt.execute("update t_account set amount = amount - 500 where account_id = 'A'");// 将 B 账户中的金额增加 500 stmt.execute("update t_account set amount = amount + 500 where account_id = 'B'");// 提交事务conn.commit();// 事务提交：转账的两步操作同时成功} catch(SQLException sqle){ // 发生异常，回滚在本事务中的操做conn.rollback();// 事务回滚：转账的两步操作完全撤销stmt.close(); conn.close(); } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="6-1-11-3-分布式事务"><a href="#6-1-11-3-分布式事务" class="headerlink" title="6.1.11.3  分布式事务"></a>6.1.11.3  分布式事务</h5><p>Java 事务编程接口（JTA：Java Transaction API）和 Java 事务服务 (JTS；Java Transaction Service) 为 J2EE 平台提供了分布式事务服务。分布式事务（Distributed Transaction）包括事务管理器（Transaction Manager）和一个或多个支持 XA 协议的资源管理器 ( Resource Manager )。我们可以将资源管理器看做任意类型的持久化数据存储；事务管理器承担着所有事务参与单元的协调与控制。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void transferAccount() { UserTransaction userTx = null; onnection connA = null; Statement stmtA = null; Connection connB = null; Statement stmtB = null; try{ // 获得 Transaction 管理对象userTx = (UserTransaction)getContext().lookup("java:comp/UserTransaction"); connA = getDataSourceA().getConnection();// 从数据库 A 中取得数据库连接connB = getDataSourceB().getConnection();// 从数据库 B 中取得数据库连接userTx.begin(); // 启动事务stmtA = connA.createStatement();// 将 A 账户中的金额减少 500 stmtA.execute("update t_account set amount = amount - 500 where account_id = 'A'");// 将 B 账户中的金额增加 500 stmtB = connB.createStatement(); stmtB.execute("update t_account set amount = amount + 500 where account_id = 'B'");userTx.commit();// 提交事务// 事务提交：转账的两步操作同时成功（数据库 A 和数据库 B 中的数据被同时更新）} catch(SQLException sqle){ // 发生异常，回滚在本事务中的操纵userTx.rollback();// 事务回滚：数据库 A 和数据库 B 中的数据更新被同时撤销} catch(Exception e){ } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="6-1-11-4-两阶段提交"><a href="#6-1-11-4-两阶段提交" class="headerlink" title="6.1.11.4 两阶段提交"></a>6.1.11.4 两阶段提交</h5><p>两阶段提交主要保证了分布式事务的原子性：即所有结点要么全做要么全不做，所谓的两个阶段是指：<strong>第一阶段：准备阶段；第二阶段：提交阶段。</strong></p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/TransactionTwo-phaseCommit.png"></p><p><strong><em>1 准备阶段</em></strong></p><p>事务协调者(事务管理器)给每个参与者(资源管理器)发送 Prepare 消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的 redo 和 undo 日志，但不提交，到达一种“万事俱备，只欠东风”的状态。</p><p><strong><em>2 提交阶段：</em></strong></p><p>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)将提交分成两阶段进行的目的很明确，就是尽可能晚地提交事务，让事务在提交前尽可能地完成所有能完成的工作。</p><h4 id="6-1-12-Mybatis-缓存"><a href="#6-1-12-Mybatis-缓存" class="headerlink" title="6.1.12 Mybatis 缓存"></a>6.1.12 Mybatis 缓存</h4><p>Mybatis 中有一级缓存和二级缓存，默认情况下一级缓存是开启的，而且是不能关闭的。一级缓存是指 SqlSession 级别的缓存，当在同一个 SqlSession 中进行相同的 SQL 语句查询时，第二次以后的查询不会从数据库查询，而是直接从缓存中获取，一级缓存最多缓存 1024 条 SQL。二级缓存是指可以跨 SqlSession 的缓存。是 mapper 级别的缓存，对于 mapper 级别的缓存不同的sqlsession 是可以共享的。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/MyBatisCachingMechanisms.png"></p><h5 id="6-1-12-1-Mybatis-的一级缓存原理（sqlsession-级别）"><a href="#6-1-12-1-Mybatis-的一级缓存原理（sqlsession-级别）" class="headerlink" title="6.1.12.1 Mybatis 的一级缓存原理（sqlsession 级别）"></a>6.1.12.1 Mybatis 的一级缓存原理（sqlsession 级别）</h5><p>第一次发出一个查询 sql，sql 查询结果写入 sqlsession 的一级缓存中，缓存使用的数据结构是一个 map。</p><p><strong><em>key：MapperID+offset+limit+Sql+所有的入参</em></strong></p><p>value：用户信息</p><p>同一个 sqlsession 再次发出相同的 sql，就从缓存中取出数据。**<em>如果两次中间出现 commit 操作（修改、添加、删除），本 sqlsession 中的一级缓存区域全部清空，下次再去缓存中查询不到所以要从数据库查询**</em>，从数据库查询到再写入缓存。</p><h5 id="6-1-12-2-二级缓存原理（mapper-基本）"><a href="#6-1-12-2-二级缓存原理（mapper-基本）" class="headerlink" title="6.1.12.2  二级缓存原理（mapper 基本）"></a>6.1.12.2  二级缓存原理（mapper 基本）</h5><p>二级缓存的范围是 mapper 级别（mapper 同一个命名空间），mapper 以命名空间为单位创建缓存数据结构，结构是 map。mybatis 的二级缓存是通过 CacheExecutor 实现的。CacheExecutor其实是 Executor 的代理对象。所有的查询操作，在 CacheExecutor 中都会先匹配缓存中是否存在，不存在则查询数据库。</p><p>key：MapperID+offset+limit+Sql+所有的入参</p><p><strong><em>具体使用需要配置：</em></strong></p><ol><li><p>Mybatis 全局配置中启用二级缓存配置</p></li><li><p>在对应的 Mapper.xml 中配置 cache 节点</p></li><li><p>在对应的 select 查询节点中添加 useCache=true</p></li></ol><h4 id="6-1-13-Tomcat-架构"><a href="#6-1-13-Tomcat-架构" class="headerlink" title="6.1.13 Tomcat 架构"></a>6.1.13 Tomcat 架构</h4><p><a href="http://www.importnew.com/21112.html">http://www.importnew.com/21112.html</a></p><h2 id="7-微服务"><a href="#7-微服务" class="headerlink" title="7. 微服务"></a><strong>7. 微服务</strong></h2><h4 id="7-1-1-服务注册发现"><a href="#7-1-1-服务注册发现" class="headerlink" title="7.1.1  服务注册发现"></a>7.1.1  服务注册发现</h4><p>服务注册就是维护一个登记簿，它管理系统内所有的服务地址。当新的服务启动后，它会向登记簿交待自己的地址信息。服务的依赖方直接向登记簿要 Service Provider 地址就行了。当下用于服务注册的工具非常多 ZooKeeper，Consul，Etcd, 还有 Netflix 家的 eureka 等。服务注册有两种形式：客户端注册和第三方注册。</p><h5 id="7-1-1-1-客户端注册（zookeeper）"><a href="#7-1-1-1-客户端注册（zookeeper）" class="headerlink" title="7.1.1.1  客户端注册（zookeeper）"></a>7.1.1.1  客户端注册（zookeeper）</h5><p>客户端注册是服务自身要负责注册与注销的工作。当服务启动后向注册中心注册自身，当服务下线时注销自己。期间还需要和注册中心保持心跳。心跳不一定要客户端来做，也可以由注册中心负责（这个过程叫探活）。这种方式的缺点是注册工作与服务耦合在一起，不同语言都要实现一套注册逻辑。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/ServiceRegistry.png" alt="ClientRegistration"></p><h5 id="7-1-1-2-第三方注册（独立的服务-Registrar）"><a href="#7-1-1-2-第三方注册（独立的服务-Registrar）" class="headerlink" title="7.1.1.2  第三方注册（独立的服务 Registrar）"></a>7.1.1.2  第三方注册（独立的服务 Registrar）</h5><p>第三方注册由一个独立的服务Registrar负责注册与注销。当服务启动后以某种方式通知Registrar， 然后 Registrar 负责向注册中心发起注册工作。同时注册中心要维护与服务之间的心跳，当服务不可用时，向注册中心注销服务。这种方式的缺点是 Registrar 必须是一个高可用的系统，否则注册工作没法进展。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/ThirdPartyRegistration.png"></p><h5 id="7-1-1-3-客户端发现"><a href="#7-1-1-3-客户端发现" class="headerlink" title="7.1.1.3  客户端发现"></a>7.1.1.3  客户端发现</h5><p>客户端发现是指客户端负责查询可用服务地址，以及负载均衡的工作。这种方式最方便直接，而且也方便做负载均衡。再者一旦发现某个服务不可用立即换另外一个，非常直接。缺点也在于多语言时的重复工作，每个语言实现相同的逻辑。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/Client-sideDiscovery.png"></p><h5 id="7-1-1-4-服务端发现"><a href="#7-1-1-4-服务端发现" class="headerlink" title="7.1.1.4 服务端发现"></a>7.1.1.4 服务端发现</h5><p>服务端发现需要额外的 Router 服务，请求先打到 Router，然后 Router 负责查询服务与负载均衡。这种方式虽然没有客户端发现的缺点，但是它的缺点是保证 Router 的高可用。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/Server-sideDiscovery.png"></p><h5 id="7-1-1-5-Consul"><a href="#7-1-1-5-Consul" class="headerlink" title="7.1.1.5 Consul"></a>7.1.1.5 Consul</h5><h5 id="7-1-1-6-Eureka"><a href="#7-1-1-6-Eureka" class="headerlink" title="7.1.1.6 Eureka"></a>7.1.1.6 Eureka</h5><h5 id="7-1-1-7-SmartStack"><a href="#7-1-1-7-SmartStack" class="headerlink" title="7.1.1.7 SmartStack"></a>7.1.1.7 SmartStack</h5><h5 id="7-1-1-8-Etcd"><a href="#7-1-1-8-Etcd" class="headerlink" title="7.1.1.8 Etcd"></a>7.1.1.8 Etcd</h5><h4 id="7-1-2-API-网关"><a href="#7-1-2-API-网关" class="headerlink" title="7.1.2  API 网关"></a>7.1.2  API 网关</h4><p>API Gateway 是一个服务器，也可以说是进入系统的唯一节点。这跟面向对象设计模式中的Facade 模式很像。API Gateway 封装内部系统的架构，并且提供 API 给各个客户端。它还可能有其他功能，如授权、监控、负载均衡、缓存、请求分片和管理、静态响应处理等。下图展示了一个适应当前架构的 API Gateway。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/APIGateway.png"></p><p><strong><em>API Gateway 负责请求转发、合成和协议转换</em></strong>。所有来自客户端的请求都要先经过 API Gateway，然后路由这些请求到对应的微服务。API Gateway 将经常通过调用多个微服务来处理一个请求以及聚合多个服务的结果。它可以在 web 协议与内部使用的非 Web 友好型协议间进行转换，如HTTP 协议、WebSocket 协议。</p><h5 id="7-1-2-1-请求转发"><a href="#7-1-2-1-请求转发" class="headerlink" title="7.1.2.1 请求转发"></a>7.1.2.1 请求转发</h5><p>服务转发主要是对客户端的请求安装微服务的负载转发到不同的服务上。</p><h5 id="7-1-2-2-响应合并"><a href="#7-1-2-2-响应合并" class="headerlink" title="7.1.2.2 响应合并"></a>7.1.2.2 响应合并</h5><p>把业务上需要调用多个服务接口才能完成的工作合并成一次调用对外统一提供服务。</p><h5 id="7-1-2-3-协议转换"><a href="#7-1-2-3-协议转换" class="headerlink" title="7.1.2.3 协议转换"></a>7.1.2.3 协议转换</h5><p>重点是支持 SOAP，JMS，Rest 间的协议转换。</p><h5 id="7-1-2-4-数据转换"><a href="#7-1-2-4-数据转换" class="headerlink" title="7.1.2.4 数据转换"></a>7.1.2.4 数据转换</h5><p>重点是支持 XML 和 Json 之间的报文格式转换能力（可选）。</p><h5 id="7-1-2-5-安全认证"><a href="#7-1-2-5-安全认证" class="headerlink" title="7.1.2.5 安全认证"></a>7.1.2.5 安全认证</h5><ol><li><p>基于 Token 的客户端访问控制和安全策略</p></li><li><p>传输数据和报文加密，到服务端解密，需要在客户端有独立的 SDK 代理包</p></li><li><p>基于 Https 的传输加密，客户端和服务端数字证书支持</p></li><li><p>基于 OAuth2.0 的服务安全认证(授权码，客户端，密码模式等）</p></li></ol><h4 id="7-1-3-配置中心"><a href="#7-1-3-配置中心" class="headerlink" title="7.1.3 配置中心"></a>7.1.3 配置中心</h4><p>配置中心一般用作系统的参数配置，它需要满足如下几个要求：高效获取、实时感知、分布式访问。</p><h5 id="7-1-3-1-zookeeper-配置中心"><a href="#7-1-3-1-zookeeper-配置中心" class="headerlink" title="7.1.3.1 zookeeper 配置中心"></a>7.1.3.1 zookeeper 配置中心</h5><p>实现的架构图如下所示，采取数据加载到内存方式解决高效获取的问题，借助 zookeeper 的节点监听机制来实现实时感知。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/ZookeeperConfigurationCenter.png"></p><h5 id="7-1-3-2-配置中心数据分类"><a href="#7-1-3-2-配置中心数据分类" class="headerlink" title="7.1.3.2 配置中心数据分类"></a>7.1.3.2 配置中心数据分类</h5><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/ConfigureTheCentralDataClassification.png"></p><h4 id="7-1-4-事件调度（kafka）"><a href="#7-1-4-事件调度（kafka）" class="headerlink" title="7.1.4 事件调度（kafka）"></a>7.1.4 事件调度（kafka）</h4><p>消息服务和事件的统一调度，常用用 kafka ，activemq 等。</p><h4 id="7-1-5-服务跟踪（starter-sleuth）"><a href="#7-1-5-服务跟踪（starter-sleuth）" class="headerlink" title="7.1.5 服务跟踪（starter-sleuth）"></a>7.1.5 服务跟踪（starter-sleuth）</h4><p>随着微服务数量不断增长，需要跟踪一个请求从一个微服务到下一个微服务的传播过程， <strong><em>Spring Cloud Sleuth 正是解决这个问题，它在日志中引入唯一 ID，以保证微服务调用之间的一致性，这样你就能跟踪某个请求是如何从一个微服务传递到下一个</em></strong>。</p><ol><li><p>为了实现请求跟踪，当请求发送到分布式系统的入口端点时，只需要服务跟踪框架为该请求创建一个唯一的跟踪标识，同时在分布式系统内部流转的时候，框架始终保持传递该唯一标识，直到返回给请求方为止，**<em>这个唯一标识就是前文中提到的 Trace ID**</em>。通过 Trace ID 的记录，我们就能将所有请求过程日志关联起来。</p></li><li><p>为了统计各处理单元的时间延迟，当请求达到各个服务组件时，或是处理逻辑到达某个状态时，也通过一个唯一标识来标记它的开始、具体过程以及结束，该标识就是我们前文中提到的 Span ID，**<em>对于每个 Span 来说，它必须有开始和结束两个节点，通过记录开始 Span 和结束 Span 的时间戳，就能统计出该 Span 的时间延迟**</em>，除了时间戳记录之外，它还可以包含一些其他元数据，比如：事件名称、请求信息等。</p></li><li><p>在快速入门示例中，我们轻松实现了日志级别的跟踪信息接入，这完全归功于spring-cloud-starter-sleuth 组件的实现。在 Spring Boot 应用中，通过在工程中引入 spring-cloud-starter-sleuth 依赖之后， 它会自动的为当前应用构建起各通信通道的跟踪机制，比如：</p></li></ol><ul><li>通过诸如 RabbitMQ、Kafka（或者其他任何 Spring Cloud Stream 绑定器实现的消息中间件）传递的请求。 </li><li>通过 Zuul 代理传递的请求。 </li><li>通过 RestTemplate 发起的请求。</li></ul><h4 id="7-1-6-服务熔断（Hystrix）"><a href="#7-1-6-服务熔断（Hystrix）" class="headerlink" title="7.1.6 服务熔断（Hystrix）"></a>7.1.6 服务熔断（Hystrix）</h4><p>在微服务架构中通常会有多个服务层调用，基础服务的故障可能会导致级联故障，进而造成整个系统不可用的情况，这种现象被称为服务雪崩效应。服务雪崩效应是一种因“服务提供者”的不可用导致“服务消费者”的不可用,并将不可用逐渐放大的过程。</p><p>熔断器的原理很简单，如同电力过载保护器。它可以实现快速失败，如果它在一段时间内侦测到许多类似的错误，会强迫其以后的多个调用快速失败，不再访问远程服务器，从而防止应用程序不断地尝试执行可能会失败的操作，使得应用程序继续执行而不用等待修正错误，或者浪费 CPU时间去等到长时间的超时产生。熔断器也可以使应用程序能够诊断错误是否已经修正，如果已经修正，应用程序会再次尝试调用操作。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/Hystrix.png"></p><h5 id="7-1-6-1-Hystrix-断路器机制"><a href="#7-1-6-1-Hystrix-断路器机制" class="headerlink" title="7.1.6.1 Hystrix 断路器机制"></a>7.1.6.1 Hystrix 断路器机制</h5><p>断路器很好理解, 当 Hystrix Command 请求后端服务失败数量超过一定比例(默认 50%), 断路器会切换到开路状态(Open). 这时所有请求会直接失败而不会发送到后端服务. 断路器保持在开路状态一段时间后(默认 5 秒), 自动切换到半开路状态(HALF-OPEN). 这时会判断下一次请求的返回情况, 如果请求成功, 断路器切回闭路状态(CLOSED), 否则重新切换到开路状态(OPEN). Hystrix 的断路器就像我们家庭电路中的保险丝, 一旦后端服务不可用, 断路器会直接切断请求链, 避免发送大量无效请求影响系统吞吐量, 并且断路器有自我检测并恢复的能力。</p><h4 id="7-1-7-API-管理"><a href="#7-1-7-API-管理" class="headerlink" title="7.1.7 API 管理"></a>7.1.7 API 管理</h4><p>SwaggerAPI 管理工具。</p><h2 id="8-Netty-与-RPC"><a href="#8-Netty-与-RPC" class="headerlink" title="8. Netty 与 RPC"></a><strong>8. Netty 与 RPC</strong></h2><h4 id="8-1-1-Netty-原理"><a href="#8-1-1-Netty-原理" class="headerlink" title="8.1.1 Netty 原理"></a>8.1.1 Netty 原理</h4><p>Netty 是一个高性能、异步事件驱动的 NIO 框架，基于 JAVA NIO 提供的 API 实现。它提供了对TCP、UDP 和文件传输的支持，作为一个异步 NIO 框架，Netty 的所有 IO 操作都是异步非阻塞的，**<em>通过 Future-Listener 机制，用户可以方便的主动获取或者通过通知机制获得 IO 操作结果**</em>。</p><h4 id="8-1-2-Netty-高性能"><a href="#8-1-2-Netty-高性能" class="headerlink" title="8.1.2 Netty 高性能"></a>8.1.2 Netty 高性能</h4><p>在 IO 编程过程中，当需要同时处理多个客户端接入请求时，可以利用多线程或者 IO 多路复用技术进行处理。IO 多路复用技术通过把多个 IO 的阻塞复用到同一个 select 的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的多线程/多进程模型比，I/O 多路复用的最大优势是系统开销小，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降低了系统的维护工作量，节省了系统资源。</p><p>与 Socket 类和 ServerSocket 类相对应，NIO 也提供了 SocketChannel 和 ServerSocketChannel两种不同的套接字通道实现。</p><h5 id="8-1-2-1-多路复用通讯方式"><a href="#8-1-2-1-多路复用通讯方式" class="headerlink" title="8.1.2.1 多路复用通讯方式"></a>8.1.2.1 多路复用通讯方式</h5><p>Netty 架构按照 Reactor 模式设计和实现，它的服务端通信序列图如下：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/NettyServerCommunication.png"></p><p>客户端通信序列图如下：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/NettyClientCommunication.png"></p><p>Netty 的 IO <strong><em>线程 NioEventLoop 由于聚合了多路复用器 Selector</em></strong>，可以同时并发处理成百上千个客户端 Channel，由于读写操作都是非阻塞的，这就可以充分提升 IO 线程的运行效率，避免由于频繁 IO 阻塞导致的线程挂起。</p><h5 id="8-1-2-2-异步通讯-NIO"><a href="#8-1-2-2-异步通讯-NIO" class="headerlink" title="8.1.2.2 异步通讯 NIO"></a>8.1.2.2 异步通讯 NIO</h5><p><strong><em>由于 Netty 采用了异步通信模式，一个 IO 线程可以并发处理 N 个客户端连接和读写操作</em></strong>，这从根本上解决了传统同步阻塞 IO 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</p><h5 id="8-1-2-3-零拷贝（DIRECT-BUFFERS-使用堆外直接内存）"><a href="#8-1-2-3-零拷贝（DIRECT-BUFFERS-使用堆外直接内存）" class="headerlink" title="8.1.2.3 零拷贝（DIRECT BUFFERS 使用堆外直接内存）"></a>8.1.2.3 零拷贝（DIRECT BUFFERS 使用堆外直接内存）</h5><ol><li><p><strong><em>Netty 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝</em></strong>。如果使用传统的堆内存（HEAP BUFFERS）进行 Socket 读写，JVM 会将堆内存 Buffer 拷贝一份到直接内存中，然后才写入 Socket 中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。</p></li><li><p><strong><em>Netty 提供了组合 Buffer 对象，可以聚合多个 ByteBuffer 对象，用户可以像操作一个 Buffer 那样方便的对组合 Buffer 进行操作，避免了传统通过内存拷贝的方式将几个小Buffer 合并成一个大的Buffer</em></strong>。</p></li><li><p>Netty的文件传输采用了**<em>transferTo方法**</em>，它可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环 write 方式导致的内存拷贝问题</p></li></ol><h5 id="8-1-2-4-内存池（基于内存池的缓冲区重用机制）"><a href="#8-1-2-4-内存池（基于内存池的缓冲区重用机制）" class="headerlink" title="8.1.2.4 内存池（基于内存池的缓冲区重用机制）"></a>8.1.2.4 内存池（基于内存池的缓冲区重用机制）</h5><p>随着 JVM 虚拟机和 JIT 即时编译技术的发展，对象的分配和回收是个非常轻量级的工作。但是对于缓冲区 Buffer，情况却稍有不同，特别是对于堆外直接内存的分配和回收，是一件耗时的操作。为了尽量重用缓冲区，Netty 提供了基于内存池的缓冲区重用机制。</p><h5 id="8-1-2-5-高效的-Reactor-线程模型"><a href="#8-1-2-5-高效的-Reactor-线程模型" class="headerlink" title="8.1.2.5 高效的 Reactor 线程模型"></a>8.1.2.5 高效的 Reactor 线程模型</h5><p>常用的 Reactor 线程模型有三种，Reactor 单线程模型, Reactor 多线程模型, 主从 Reactor 多线程模型。</p><p><strong>Reactor 单线程模型</strong></p><p>Reactor 单线程模型，指的是所有的 IO 操作都在同一个 NIO 线程上面完成，NIO 线程的职责如下：</p><ol><li><p>作为 NIO 服务端，接收客户端的 TCP 连接；</p></li><li><p>作为 NIO 客户端，向服务端发起 TCP 连接；</p></li><li><p>读取通信对端的请求或者应答消息；</p></li><li><p>向通信对端发送消息请求或者应答消息。</p></li></ol><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/ReactorSingleThreadedModel.png"></p><p>由于 Reactor 模式使用的是异步非阻塞 IO，所有的 IO 操作都不会导致阻塞，理论上一个线程可以独立处理所有 IO 相关的操作。从架构层面看，一个 NIO 线程确实可以完成其承担的职责。例如，通过Acceptor 接收客户端的 TCP 连接请求消息，链路建立成功之后，通过 Dispatch 将对应的 ByteBuffer派发到指定的 Handler 上进行消息解码。用户 Handler 可以通过 NIO 线程将消息发送给客户端。</p><p><strong>Reactor 多线程模型</strong></p><p>Rector 多线程模型与单线程模型最大的区别就是有一组 NIO 线程处理 IO 操作。 有专门一个*<strong>NIO 线程-Acceptor 线程用于监听服务端***，接收客户端的 TCP 连接请求； *</strong>网络 IO 操作-读、写等由一个 NIO 线程池负责***，线程池可以采用标准的 JDK 线程池实现，它包含一个任务队列和 N个可用的线程，由这些 NIO 线程负责消息的读取、解码、编码和发送；</p><p><img src="C:/Users/asus/AppData/Roaming/Typora/typora-user-images/image-20210301161547951.png"></p><p><strong>主从 Reactor 多线程模型</strong></p><p>服务端用于接收客户端连接的不再是个 1 个单独的 NIO 线程，而是一个独立的 NIO 线程池。Acceptor 接收到客户端 TCP 连接请求处理完成后（可能包含接入认证等），将新创建的SocketChannel 注册到 IO 线程池（sub reactor 线程池）的某个 IO 线程上，由它负责SocketChannel 的读写和编解码工作。**<em>Acceptor 线程池仅仅只用于客户端的登陆、握手和安全认证，一旦链路建立成功，就将链路注册到后端 subReactor 线程池的 IO 线程上，由 IO 线程负责后续的 IO 操作**</em>。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/master-slaveReactor.png"></p><h5 id="8-1-2-6-无锁设计、线程绑定"><a href="#8-1-2-6-无锁设计、线程绑定" class="headerlink" title="8.1.2.6 无锁设计、线程绑定"></a>8.1.2.6 无锁设计、线程绑定</h5><p>Netty 采用了串行无锁化设计，在 IO 线程内部进行串行操作，避免多线程竞争导致的性能下降。表面上看，串行化设计似乎 CPU 利用率不高，并发程度不够。但是，通过调整 NIO 线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列-多个工作线程模型性能更优。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/NioEventLoop.png"></p><p>Netty 的 NioEventLoop 读取到消息之后，直接调用 ChannelPipeline 的fireChannelRead(Object msg)，只要用户不主动切换线程，一直会由 NioEventLoop 调用到用户的 Handler，期间不进行线程切换，这种串行化处理方式避免了多线程操作导致的锁的竞争，从性能角度看是最优的。</p><h5 id="8-1-2-7-高性能的序列化框架"><a href="#8-1-2-7-高性能的序列化框架" class="headerlink" title="8.1.2.7 高性能的序列化框架"></a>8.1.2.7 高性能的序列化框架</h5><p>Netty 默认提供了对 Google Protobuf 的支持，通过扩展 Netty 的编解码接口，用户可以实现其它的高性能序列化框架，例如 Thrift 的压缩二进制编解码框架。</p><ol><li>SO_RCVBUF 和 SO_SNDBUF：**<em>通常建议值为 128K 或者 256K**</em>。</li></ol><p><strong>小包封大包，防止网络阻塞</strong></p><ol start="2"><li>SO_TCPNODELAY：**<em>NAGLE 算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻塞网络**</em>，从而提高网络应用效率。但是对于时延敏感的应用场景需要关闭该优化算法。</li></ol><p><strong>软中断 Hash 值和 CPU 绑定</strong></p><ol start="3"><li>软中断：开启 RPS 后可以实现软中断，提升网络吞吐量。*<strong>RPS 根据数据包的源地址，目的地址以及目的和源端口，计算出一个 hash 值，然后根据这个 hash 值来选择软中断运行的 cpu**<em>，从上层来看，</em></strong>也就是说将每个连接和 cpu 绑定，并通过这个 hash 值，来均衡软中断在多个 cpu 上***，提升网络并行处理性能。</li></ol><h4 id="8-1-3-Netty-RPC-实现"><a href="#8-1-3-Netty-RPC-实现" class="headerlink" title="8.1.3 Netty RPC 实现"></a>8.1.3 Netty RPC 实现</h4><h5 id="8-1-3-1-概念"><a href="#8-1-3-1-概念" class="headerlink" title="8.1.3.1 概念"></a>8.1.3.1 概念</h5><p>RPC，即 Remote Procedure Call（远程过程调用），调用远程计算机上的服务，就像调用本地服务一样。RPC 可以很好的解耦系统，如 WebService 就是一种基于 Http 协议的 RPC。这个 RPC 整体框架如下：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/WebServiceRPC.png"></p><h5 id="8-1-3-2-关键技术"><a href="#8-1-3-2-关键技术" class="headerlink" title="8.1.3.2 关键技术"></a>8.1.3.2 关键技术</h5><ol><li><p>服务发布与订阅：服务端使用 Zookeeper 注册服务地址，客户端从 Zookeeper 获取可用的服务地址。</p></li><li><p>通信：使用 Netty 作为通信框架。</p></li><li><p>Spring：使用 Spring 配置服务，加载 Bean，扫描注解。</p></li><li><p>动态代理：客户端使用代理模式透明化服务调用。</p></li><li><p>消息编解码：使用 Protostuff 序列化和反序列化消息。</p></li></ol><h5 id="8-1-3-3-核心流程"><a href="#8-1-3-3-核心流程" class="headerlink" title="8.1.3.3 核心流程"></a>8.1.3.3 核心流程</h5><ol><li><p>服务消费方（client）调用以本地调用方式调用服务；</p></li><li><p>client stub 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</p></li><li><p>client stub 找到服务地址，并将消息发送到服务端；</p></li><li><p>server stub 收到消息后进行解码；</p></li><li><p>server stub 根据解码结果调用本地的服务；</p></li><li><p>本地服务执行并将结果返回给 server stub；</p></li><li><p>server stub 将返回结果打包成消息并发送至消费方；</p></li><li><p>client stub 接收到消息，并进行解码；</p></li><li><p>服务消费方得到最终结果。</p><p><strong><em>RPC 的目标就是要 2~8 这些步骤都封装起来</em></strong>，让用户对这些细节透明。**<em>JAVA 一般使用动态代理方式实现远程调用**</em>。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/RPCCoreProcesses.png"></p></li></ol><h5 id="8-1-3-4-消息编解码"><a href="#8-1-3-4-消息编解码" class="headerlink" title="8.1.3.4 消息编解码"></a>8.1.3.4 消息编解码</h5><p><strong><em>息数据结构（接口名称+方法名+参数类型和参数值+超时时间+ requestID）</em></strong></p><pre><code> 客户端的请求消息结构一般需要包括以下内容：</code></pre><ol><li><p>接口名称：在我们的例子里接口名是“HelloWorldService”，如果不传，服务端就不知道调用哪个接口了；</p></li><li><p>方法名：一个接口内可能有很多方法，如果不传方法名服务端也就不知道调用哪个方法；</p></li><li><p>参数类型和参数值：参数类型有很多，比如有 bool、int、long、double、string、map、list，甚至如 struct（class）；以及相应的参数值；</p></li><li><p>超时时间：</p></li><li><p>requestID，标识唯一请求 id，在下面一节会详细描述 requestID 的用处。</p></li><li><p>服务端返回的消息 ： 一般包括以下内容。返回值+状态 code+requestID</p></li></ol><p><strong><em>序列化</em></strong></p><p>​    目前互联网公司广泛使用 Protobuf、Thrift、Avro 等成熟的序列化解决方案    来搭建 RPC 框架，这些都是久经考验的解决方案。</p><h5 id="8-1-3-5-通讯过程"><a href="#8-1-3-5-通讯过程" class="headerlink" title="8.1.3.5 通讯过程"></a>8.1.3.5 通讯过程</h5><p><strong>核心问题（线程暂停、消息乱序)</strong></p><pre><code>     如果使用 netty 的话，***一般会用 channel.writeAndFlush()方法来发送    消息二    进制串，这个方法调用后对于整个远程调用(从发出请求到接收到结    果)来说是    一个异步的，即对于当前线程来说，将请求发送出来后，线程就    可以往后执    行了，至于服务端的结果，是服务端处理完成后，再以消息的    形式发送给客    户端的***。于是这里出现以下两个问题：</code></pre><ol><li><p>怎么让当前线程“暂停”，等结果回来后，再向后执行？</p></li><li><p>如果有多个线程同时进行远程方法调用，这时建立在 client server 之间的 socket 连接上会有很多双方发送的消息传递，前后顺序也可能是随机的，server 处理完结果后，将结果消息发送给 client，client 收到很多消息，怎么知道哪个消息结果是原先哪个线程调用的？如下图所示，线程 A 和线程 B 同时向 client socket 发送请求 requestA 和 requestB，socket 先后将 requestB 和 requestA 发送至 server，而 server 可能将 responseB 先返回，尽管 requestB 请求到达时间更晚。我们需要一种机制保证 responseA 丢给ThreadA，responseB 丢给 ThreadB。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/NettyCoreProblem.png"></p></li></ol><p><strong>通讯流程</strong></p><p><strong>requestID 生成-AtomicLong</strong></p><ol><li>client 线程每次通过 socket 调用一次远程接口前，**<em>生成一个唯一的 ID，即 requestID（requestID 必需保证在一个 Socket 连接里面是唯一的）**</em>，一般常常使用 AtomicLong从 0 开始累计数字生成唯一 ID；</li></ol><p><strong>存放回调对象 callback 到全局 ConcurrentHashMap</strong></p><ol start="2"><li><strong><em>将 处 理 结 果 的 回 调 对 象 callback ， 存 放 到 全 局 ConcurrentHashMap 里 面put(requestID, callback)</em></strong>；</li></ol><p><strong>synchronized 获取回调对象 callback 的锁并自旋 wait</strong></p><ol start="3"><li>当线程调用 channel.writeAndFlush()发送消息后，紧接着执行 <strong><em>callback 的 get()方法试图获取远程返回的结果。在 get()内部，则使用 synchronized 获取回调对象 callback 的锁，再先检测是否已经获取到结果，如果没有，然后调用 callback 的 wait()方法，释放callback 上的锁，让当前线程处于等待状态</em></strong>。</li></ol><p><strong>监听消息的线程收到消息，找到 callback 上的锁并唤醒</strong></p><ol start="4"><li>服务端接收到请求并处理后，将 response 结果（此结果中包含了前面的 requestID）发送给客户端，**<em>客户端 socket 连接上专门监听消息的线程收到消息，分析结果，取到requestID ， 再 从 前 面 的 ConcurrentHashMap 里 面 get(requestID) ， 从 而 找 到callback 对象，再用 synchronized 获取 callback 上的锁，将方法调用结果设置到callback 对象里，再调用 callback.notifyAll()唤醒前面处于等待状态的线程**</em>。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public Object get() {synchronized (this) { // 旋锁while (true) { // 是否有结果了If （!isDone）{wait(); //没结果释放锁，让当前线程处于等待状态}else{//获取数据并处理}}  }}private void setDone(Response res) {this.res = res;isDone = true;synchronized (this) { //获取锁，因为前面 wait()已经释放了 callback 的锁了notifyAll(); // 唤醒处于等待的线程} }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="8-1-4-RMI-实现方式"><a href="#8-1-4-RMI-实现方式" class="headerlink" title="8.1.4 RMI 实现方式"></a>8.1.4 RMI 实现方式</h4><p> Java 远程方法调用，即 Java RMI（Java Remote Method Invocation）是 Java 编程语言里，一种用于实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使 Java 编程人员能够在网络环境中分布操作。RMI 全部的宗旨就是尽可能简化远程接口对象的使用。</p><h5 id="8-1-4-1-实现步骤"><a href="#8-1-4-1-实现步骤" class="headerlink" title="8.1.4.1 实现步骤"></a>8.1.4.1 实现步骤</h5><ol><li><p>编写远程服务接口，该接口必须继承 java.rmi.Remote 接口，方法必须抛出java.rmi.RemoteException 异常；</p></li><li><p>编写远程接口实现类，该实现类必须继承 java.rmi.server.UnicastRemoteObject 类；</p></li><li><p>运行 RMI 编译器（rmic），创建客户端 stub 类和服务端 skeleton 类;</p></li><li><p>启动一个 RMI 注册表，以便驻留这些服务;</p></li><li><p>在 RMI 注册表中注册服务；</p></li><li><p>客户端查找远程对象，并调用远程方法；</p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">//1：创建远程接口，继承 java.rmi.Remote 接口public interface GreetService extends java.rmi.Remote {String sayHello(String name) throws RemoteException;}//2：实现远程接口，继承 java.rmi.server.UnicastRemoteObject 类public class GreetServiceImpl extends java.rmi.server.UnicastRemoteObjectimplements GreetService {private static final long serialVersionUID = 3434060152387200042L;public GreetServiceImpl() throws RemoteException {super();}@Overridepublic String sayHello(String name) throws RemoteException {return "Hello " + name;} }//3：生成 Stub 和 Skeleton;//4：执行 rmiregistry 命令注册服务//5：启动服务LocateRegistry.createRegistry(1098);Naming.bind("rmi://10.108.1.138:1098/GreetService", new GreetServiceImpl());//6.客户端调用GreetService greetService = (GreetService) Naming.lookup("rmi://10.108.1.138:1098/GreetService");System.out.println(greetService.sayHello("Jobs"));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="8-1-5-Protoclol-Buffer"><a href="#8-1-5-Protoclol-Buffer" class="headerlink" title="8.1.5 Protoclol Buffer"></a>8.1.5 Protoclol Buffer</h4><p>protocol buffer 是 google 的一个开源项目,它是用于结构化数据串行化的灵活、高效、自动的方法，例如 XML，不过它比 xml 更小、更快、也更简单。你可以定义自己的数据结构，然后使用代码生成器生成的代码来读写这个数据结构。你甚至可以在无需重新部署程序的情况下更新数据结构。</p><h5 id="8-1-5-1-特点"><a href="#8-1-5-1-特点" class="headerlink" title="8.1.5.1 特点"></a>8.1.5.1 特点</h5><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/ProtocolBufferCharacteristics.png"></p><p>Protocol Buffer 的序列化 &amp; 反序列化简单 &amp; 速度快的原因是：</p><ol><li><p>编码 / 解码 方式简单（只需要简单的数学运算 = 位移等等）</p></li><li><p>采用 Protocol Buffer 自身的框架代码 和 编译器 共同完成Protocol Buffer 的数据压缩效果好（即序列化后的数据量体积小）的原因是：</p><p>a. 采用了独特的编码方式，如 Varint、Zigzag 编码方式等等</p><p>b. 采用 T - L - V 的数据存储方式：减少了分隔符的使用 &amp; 数据存储得紧凑</p></li></ol><h4 id="8-1-6-Thrift"><a href="#8-1-6-Thrift" class="headerlink" title="8.1.6 Thrift"></a>8.1.6 Thrift</h4><p>Apache Thrift 是 Facebook 实现的一种高效的、支持多种编程语言的远程服务调用的框架。本文将从Java 开发人员角度详细介绍 Apache Thrift 的架构、开发和部署，并且针对不同的传输协议和服务类型给出相应的 Java 实例，同时详细介绍 Thrift 异步客户端的实现，最后提出使用 Thrift 需要注意的事项。</p><p>目前流行的服务调用方式有很多种，例如基于 SOAP 消息格式的 Web Service，基于 JSON 消息格式的 RESTful 服务等。其中所用到的数据传输方式包括 XML，JSON 等，然而 XML 相对体积太大，传输效率低，JSON 体积较小，新颖，但还不够完善。本文将介绍由 Facebook 开发的远程服务调用框架Apache Thrift，*<strong>它采用接口描述语言定义并创建服务，支持可扩展的跨语言服务开发，所包含的代码生成引擎可以在多种语言中**<em>，如 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, Smalltalk 等创建高效的、无缝的服务，其传输数据采用二进制格式，</em></strong>相对 XML 和 JSON 体积更小，对于高并发、大数据量和多语言的环境更有优势***。本文将详细介绍 Thrift 的使用，并且提供丰富的实例代码加以解释说明，帮助使用者快速构建服务。</p><p>为什么要 Thrift： </p><p>1、多语言开发的需要 2、性能问题</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/Thrift.png"></p><h2 id="9-网络"><a href="#9-网络" class="headerlink" title="9. 网络"></a><strong>9. 网络</strong></h2><h4 id="9-1-1-网络-7-层架构"><a href="#9-1-1-网络-7-层架构" class="headerlink" title="9.1.1 网络 7 层架构"></a>9.1.1 网络 7 层架构</h4><p>7 层模型主要包括：</p><ol><li><p>物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由 1、0 转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的**<em>模数转换与数模转换**</em>）。这一层的数据叫做比特。 </p></li><li><p>数据链路层：主要将从物理层接收的数据进行 <strong><em>MAC 地址（网卡的地址）的封装与解封装</em></strong>。常把这一层的数据叫做帧。在这一层工作的**<em>设备是交换机**</em>，数据通过交换机来传输。 </p></li><li><p>网络层：主要将从下层接收到的数据进行 <strong><em>IP 地址（例 192.168.0.1)的封装与解封装</em></strong>。在这一层工作的设备是**<em>路由器**</em>，常把这一层的数据叫做数据包。</p></li><li><p>传输层：定义了一些*<strong>传输数据的协议和端口号**<em>（WWW 端口 80 等），如：</em></strong>TCP*<strong>（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），**<em>UDP</em></strong>（用户数据报协议，与 TCP 特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如 QQ 聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段进行传输，到达目的地址后在进行重组。常常把这一层数据叫做段。 </p></li><li><p>会话层：通过传输层（端口号：传输端口与接收端口）**<em>建立数据传输的通路**</em>。主要在你的系统之间发起会话或或者接受会话请求（设备之间需要互相认识可以是 IP 也可以是 MAC 或者是主机名） </p></li><li><p>表示层：主要是进行对接收的数据进行**<em>解释、加密与解密、压缩与解压缩**</em>等（也就是把计算机能够识别的东西转换成人能够能识别的东西（如图片、声音等）） </p></li><li><p>应用层 主要是一些终端的应用，比如说FTP（各种文件下载），WEB（IE浏览），QQ之类的（你就把它理解成我们在电脑屏幕上可以看到的东西．就 是终端应用）。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/Network7LayerArchitecture.png"></p></li></ol><h4 id="9-1-2-TCP-IP-原理"><a href="#9-1-2-TCP-IP-原理" class="headerlink" title="9.1.2 TCP/IP 原理"></a>9.1.2 TCP/IP 原理</h4><p>TCP/IP 协议不是 TCP 和 IP 这两个协议的合称，而是指因特网整个 TCP/IP 协议族。从协议分层模型方面来讲，TCP/IP 由四个层次组成：网络接口层、网络层、传输层、应用层。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/TCP/IPPrinciple.png"></p><h5 id="9-1-2-1-网络访问层-Network-Access-Layer"><a href="#9-1-2-1-网络访问层-Network-Access-Layer" class="headerlink" title="9.1.2.1 网络访问层(Network Access Layer)"></a>9.1.2.1 网络访问层(Network Access Layer)</h5><ol><li>网络访问层(Network Access Layer)在 TCP/IP 参考模型中并没有详细描述，**<em>只是指出主机必须使用某种协议与网络相连**</em>。</li></ol><h5 id="9-1-2-2-网络层-Internet-Layer"><a href="#9-1-2-2-网络层-Internet-Layer" class="headerlink" title="9.1.2.2 网络层(Internet Layer)"></a>9.1.2.2 网络层(Internet Layer)</h5><ol start="2"><li>网络层(Internet Layer)是整个体系结构的关键部分，其功能是使主机可以把分组发往任何网络，并使分组独立地传向目标。这些分组可能经由不同的网络，到达的顺序和发送的顺序也可能不同。高层如果需要顺序收发，那么就必须自行处理对分组的排序。**<em>互联网层使用因特网协议(IP，Internet Protocol)**</em>。</li></ol><h5 id="9-1-2-3-传输层-Tramsport-Layer-TCP-UDP"><a href="#9-1-2-3-传输层-Tramsport-Layer-TCP-UDP" class="headerlink" title="9.1.2.3 传输层(Tramsport Layer-TCP/UDP)"></a>9.1.2.3 传输层(Tramsport Layer-TCP/UDP)</h5><ol start="3"><li>传输层(Tramsport Layer)使源端和目的端机器上的对等实体可以进行会话。*<strong>在这一层定义了两个端到端的协议**<em>：传输控制协议(TCP，Transmission Control Protocol)和用户数据报协议(UDP，User Datagram Protocol)。</em></strong>TCP*** 是面向连接的协议，它提供可靠的报文传输和对上层应用的连接服务。为此，除了基本的数据传输外，它还有可靠性保证、流量控制、多路复用、优先权和安全性控制等功能。**<em>UDP**</em> 是面向无连接的不可靠传输的协议，主要用于不需要 TCP 的排序和流量控制等功能的应用程序。</li></ol><h5 id="9-1-2-4-应用层-Application-Layer"><a href="#9-1-2-4-应用层-Application-Layer" class="headerlink" title="9.1.2.4 应用层(Application Layer)"></a>9.1.2.4 应用层(Application Layer)</h5><ol start="4"><li>应用层(Application Layer)包含所有的高层协议，包括：**<em>虚拟终端协议(TELNET，TELecommunications NETwork)、文件传输协议(FTP，File Transfer Protocol)、电子邮件传输协议(SMTP，Simple Mail Transfer Protocol)、域名服务(DNS，Domain Name Service)、网上新闻传输协议(NNTP，Net News Transfer Protocol)和超文本传送协议(HTTP，HyperText Transfer Protocol)等**</em>。</li></ol><h4 id="9-1-3-TCP-三次握手-四次挥手"><a href="#9-1-3-TCP-三次握手-四次挥手" class="headerlink" title="9.1.3 TCP 三次握手/四次挥手"></a>9.1.3 TCP 三次握手/四次挥手</h4><p>TCP 在传输之前会进行三次沟通，一般称为“三次握手”，传完数据断开的时候要进行四次沟通，一般称为“四次挥手”。</p><h5 id="9-1-3-1-数据包说明"><a href="#9-1-3-1-数据包说明" class="headerlink" title="9.1.3.1 数据包说明"></a>9.1.3.1 数据包说明</h5><ol><li><p>源端口号（ 16 位）：它（连同源主机 IP 地址）标识源主机的一个应用进程。</p></li><li><p>目的端口号（ 16 位）：它（连同目的主机 IP 地址）标识目的主机的一个应用进程。这两个值**<em>加上 IP 报头中的源主机 IP 地址和目的主机 IP 地址唯一确定一个 TCP 连接**</em>。</p></li><li><p>顺序号 seq（ 32 位）：*<strong>用来标识从 TCP 源端向 TCP 目的端发送的数据字节流，它表示在这个报文段中的第一个数据字节的顺序号**<em>。如果将字节流看作在两个应用程序间的单向流动，则</em></strong>TCP 用顺序号对每个字节进行计数*<strong>。序号是 32bit 的无符号数，**<em>序号到达 2 的 32 次方 － 1 后又从 0 开始。当建立一个新的连接时， SYN 标志变 1</em></strong> ，顺序号字段包含由这个主机选择的该连接的初始顺序号 ISN （ Initial Sequence Number ）。</p></li><li><p>确认号 ack（ 32 位）：*<strong>包含发送确认的一端所期望收到的下一个顺序号**<em>。因此，确认序号应当是上次已成功收到数据字节顺序号加 1 。</em></strong>只有 ACK 标志为 1 时确认序号字段才有效***。 TCP 为应用层提供全双工服务，这意味数据能在两个方向上独立地进行传输。因此，连接的每一端必须保持每个方向上的传输数据顺序号。</p></li><li><p>TCP 报头长度（ 4 位）：给出报头中 32bit 字的数目，**<em>它实际上指明数据从哪里开始**</em>。需要这个值是因为任选字段的长度是可变的。这个字段占 4bit ，因此 TCP 最多有 60 字节的首部。然而，没有任选字段，正常的长度是 20 字节。</p></li><li><p>保留位（ 6 位）：保留给将来使用，目前必须置为 0 。</p></li><li><p>控制位（ control flags ， 6 位）：在 TCP 报头中有 6 个标志比特，它们中的多个可同时被设置为 1 。依次为：</p></li></ol><ul><li>URG ：为 1 表示紧急指针有效，为 0 则忽略紧急指针值。</li><li>ACK ：为 1 表示确认号有效，为 0 表示报文中不包含确认信息，忽略确认号字段。</li><li>PSH ：为 1 表示是带有 PUSH 标志的数据，**<em>指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满**</em>。 </li><li>RST ：**<em>用于复位由于主机崩溃或其他原因而出现错误的连接**</em>。它还可以用于拒绝非法的报文段和拒绝连接请求。一般情况下，如果收到一个 RST 为 1 的报文，那么一定发生了某些问题。</li><li>SYN ：同步序号，**<em>为 1 表示连接请求**</em>，用于建立连接和使顺序号同步（ synchronize ）。</li><li>FIN ：**<em>用于释放连接**</em>，为 1 表示发送方已经没有数据发送了，即关闭本方数据流。</li></ul><ol start="8"><li><p>窗口大小（ 16 位）：数据字节数，表示从确认号开始，本报文的源方可以接收的字节数，即源方接收窗口大小。窗口大小是一个 16bit 字段，因而窗口大小最大为 65535 字节。</p></li><li><p>校验和（ 16 位）：此校验和是对整个的 TCP 报文段，*<strong>包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得**<em>。这是一个强制性的字段，一定是由发送端计算和存储，</em></strong>并由接收端进行验证***。</p></li><li><p>紧急指针（ 16 位）：只有当 URG 标志置 1 时紧急指针才有效。**<em>TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式**</em>。</p></li><li><p>选项：最常见的可选字段是最长报文大小，又称为 MSS(Maximum Segment Size) 。每个连接方通常都在通信的第一个报文段（为建立连接而设置 SYN 标志的那个段）中指明这个选项，**<em>它指明本端所能接收的最大长度的报文段**</em>。选项长度不一定是 32 位字的整数倍，所以要加填充位，使得报头长度成为整字数。</p></li><li><p>数据： TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/TCPHandshakePacketDescription.png"></p></li></ol><h5 id="9-1-3-2-三次握手"><a href="#9-1-3-2-三次握手" class="headerlink" title="9.1.3.2 三次握手"></a>9.1.3.2 三次握手</h5><p>第一次握手：主机 A 发送位码为 <strong><em>syn＝1</em></strong>,随机产生**<em>seq number=1234567**</em>的数据包到服务器，主机 B 由 SYN=1 知道，A 要求建立联机；</p><p>第二次握手：主机 B 收到请求后要确认联机信息，向 A 发 送 ack number=(<strong><em>主 机 A 的seq+1),syn=1,ack=1,随机产生 seq=7654321 的包</em></strong>;</p><p>第三次握手：*<strong>主机 A 收到后检查 ack number 是否正确**<em>，即第一次发送的 seq number+1,以及位码ack 是否为 1，若正确，</em></strong>主机 A 会再发送 ack number=(主机 B 的 seq+1),ack=1，主机 B 收到后确认seq 值与 ack=1 则连接建立成功***。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/TCPThree-wayHandshake.png"></p><h5 id="9-1-3-3-四次挥手"><a href="#9-1-3-3-四次挥手" class="headerlink" title="9.1.3.3 四次挥手"></a>9.1.3.3 四次挥手</h5><p>TCP 建立连接要进行三次握手，而断开连接要进行四次。这是由于 TCP 的半关闭造成的。因为 TCP 连接是全双工的(即数据可在两个方向上同时传递)所以进行关闭时每个方向上都要单独进行关闭。这个单方向的关闭就叫半关闭。当一方完成它的数据发送任务，就发送一个 FIN 来向另一方通告将要终止这个方向的连接。</p><p>1） 关闭客户端到服务器的连接：首先客户端 A 发送一个 FIN，用来关闭客    户到服务器的数据传送，然后等待服务器的确认。其中终止标志位 FIN=1，    序列号 seq=u</p><p>2） 服务器收到这个 FIN，它发回一个 ACK，确认号 ack 为收到的序号加 1。</p><p>3） 关闭服务器到客户端的连接：也是发送一个 FIN 给客户端。</p><p>4） 客户段收到 FIN 后，并发回一个 ACK 报文确认，并将确认序号 seq 设置    为收到序号加 1。首先进行关闭的一方将执行主动关闭，而另一方执行被动    关闭。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/TCPFour-wayHandshake.png"></p><p>主机 A 发送 FIN 后，进入终止等待状态， 服务器 B 收到主机 A 连接释放报文段后，就立即给主机 A 发送确认，然后服务器 B 就进入 close-wait 状态，此时 TCP 服务器进程就通知高层应用进程，因而从 A 到 B 的连接就释放了。此时是“半关闭”状态。即 A 不可以发送给B，但是 B 可以发送给 A。此时，若 B 没有数据报要发送给 A 了，其应用进程就通知 TCP 释放连接，然后发送给 A 连接释放报文段，并等待确认。A 发送确认后，进入 time-wait，注意，此时 TCP 连接还没有释放掉，然后经过时间等待计时器设置的 2MSL 后，A 才进入到close 状态。</p><h4 id="9-1-4-HTTP-原理"><a href="#9-1-4-HTTP-原理" class="headerlink" title="9.1.4 HTTP 原理"></a>9.1.4 HTTP 原理</h4><p>HTTP 是一个无状态的协议。无状态是指客户机（Web 浏览器）和服务器之间不需要建立持久的连接，这意味着当一个客户端向服务器端发出请求，然后服务器返回响应(response)，连接就被关闭了，在服务器端不保留连接的有关信息.HTTP 遵循请求(Request)/应答(Response)模型。客户机（浏览器）向服务器发送请求，服务器处理请求并返回适当的应答。所有 HTTP 连接都被构造成一套请求和应答。</p><h5 id="9-1-4-1-传输流程"><a href="#9-1-4-1-传输流程" class="headerlink" title="9.1.4.1 传输流程"></a>9.1.4.1 传输流程</h5><p><strong><em>1：地址解析</em></strong></p><p>如用客户端浏览器请求这个页面：<a href="http://localhost.com:8080/index.htm">http://localhost.com:8080/index.htm</a> 从中分解出协议名、主机名、端口、对象路径等部分，对于我们的这个地址，解析得到的结果如下：</p><p> 协议名：http</p><p> 主机名：localhost.com</p><p> 端口：8080</p><p> 对象路径：/index.htm</p><p> 在这一步，需要域名系统 DNS 解析域名 localhost.com,得主机的 IP 地址。</p><p><strong><em>2：封装 HTTP 请求数据包</em></strong></p><p>把以上部分结合本机自己的信息，封装成一个 HTTP 请求数据包</p><p><strong><em>3：封装成 TCP 包并建立连接</em></strong></p><p> 封装成 TCP 包，建立 TCP 连接（TCP 的三次握手）</p><p><strong><em>4：客户机发送请求命</em></strong></p><p>客户机发送请求命令：建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和可内容。</p><p><strong><em>5：服务器响应</em></strong></p><p>服务器接到请求后，给予相应的响应信息，**<em>其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容**</em>。 </p><p><strong><em>6：服务器关闭 TCP 连接</em></strong></p><p> 服务器关闭 TCP 连接：一般情况下，一旦 Web 服务器向浏览器发送了请求数据，它就要关闭 TCP 连接，然后如果浏览器或者服务器在其头信息加入了这行代码 <strong><em>Connection:keep-alive，TCP 连接在发送后将仍然保持打开状态</em></strong>，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/TCPTransferProcess.png"></p><h5 id="9-1-4-2-HTTP-状态"><a href="#9-1-4-2-HTTP-状态" class="headerlink" title="9.1.4.2 HTTP 状态"></a>9.1.4.2 HTTP 状态</h5><p><strong>状态码</strong>                   <strong>原因短语</strong></p><p>​              <strong>消息响应</strong></p><p>100                        Continue(继续)</p><p>101                        Switching Protocol(切换协议)</p><p>​             <strong>成功响应</strong></p><p>200                       OK(成功)</p><p>201                       Created(已创建)</p><p>202                       Accepted(已创建)</p><p>203                       Non-Authoritative Information(未授权信息)</p><p>204                       No Content(无内容)</p><p>205                       Reset Content(重置内容)</p><p>206                       Partial Content(部分内容)</p><p>​              <strong>重定向</strong></p><p>300                      Multiple Choice(多种选择)</p><p>301                      Moved Permanently(永久移动)</p><p>302                      Found(临时移动)</p><p>303                      See Other(查看其他位置)</p><p>304                      Not Modified(未修改)</p><p>305                      Use Proxy(使用代理)</p><p>306                     <em>unused</em>(未使用)</p><p>307                     Temporary Redirect(临时重定向)</p><p>308                     Permanent Redirect(永久重定向)</p><p>​            <strong>客户端错误</strong></p><p>400                     Bad Request(错误请求)</p><p>401                     Unauthorized(未授权)</p><p>402                     Payment Required(需要付款)</p><p>403                     Forbidden(禁止访问)</p><p>404                     Not Found(未找到)</p><p>405                     Method Not Allowed(不允许使用该方法)</p><p>406                     Not Acceptable(无法接受)</p><p>407                     Proxy Authentication Required(要求代理身份验证)</p><p>408                     Request Timeout(请求超时)</p><p>409                     Conflict(冲突)</p><p>410                     Gone(已失效)</p><p>411                     Length Required(需要内容长度头)</p><p>412                     Precondition Failed(预处理失败)</p><p>413                     Request Entity Too Large(请求实体过长)</p><p>414                     Request-URI Too Long(请求网址过长)</p><p>415                     Unsupported Media Type(媒体类型不支持)</p><p>416                     Requested Range Not Satisfiable(请求范围不合要求)</p><p>417                     Expectation Failed(预期结果失败)</p><p>​           <strong>服务器端错误</strong></p><p>500                     Internal Server Error(内部服务器错误)</p><p>501                     Implemented(未实现)</p><p>502                     Bad Gateway(网关错误)</p><p>503                     Service Unavailable(服务不可用)</p><p>504                     Gateway Timeout (网关超时)</p><p>505                     HTTP Version Not Supported(HTTP 版本不受支持)</p><h5 id="9-1-4-3-HTTPS"><a href="#9-1-4-3-HTTPS" class="headerlink" title="9.1.4.3 HTTPS"></a>9.1.4.3 HTTPS</h5><p>HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP 通道，简单讲是 HTTP 的安全版。即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL。其所用的端口号是 443。 过程大致如下：</p><p><strong><em>建立连接获取证书</em></strong></p><p>1） SSL 客户端通过 TCP 和服务器建立连接之后（443 端口），并且在一般的 tcp 连接协商（握手）过程中请求证书。即客户端发出一个消息给服务器，这个消息里面包含了自己可实现的算法列表和其它一些需要的消息，SSL 的服务器端会回应一个数据包，这里面确定了这次通信所需要的算法，然后服务器向客户端返回证书。（证书里面包含了服务器信息：域名。申请证书的公司，公共秘钥）。</p><p><strong><em>证书验证</em></strong></p><p>2） Client 在收到服务器返回的证书后，判断签发这个证书的公共签发机构，并使用这个机构的公共秘钥确认签名是否有效，客户端还会确保证书中列出的域名就是它正在连接的域名。</p><p><strong><em>数据加密和传输</em></strong></p><p>3） 如果确认证书有效，那么生成对称秘钥并使用服务器的公共秘钥进行加密。然后发送给服务器，服务器使用它的私钥对它进行解密，这样两台计算机可以开始进行对称加密进行通信。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/DataEncrypted.png"></p><h4 id="9-1-5-CDN-原理"><a href="#9-1-5-CDN-原理" class="headerlink" title="9.1.5 CDN 原理"></a>9.1.5 CDN 原理</h4><p>CND 一般包含分发服务系统、负载均衡系统和管理系统</p><h5 id="9-1-5-1-分发服务系统"><a href="#9-1-5-1-分发服务系统" class="headerlink" title="9.1.5.1 分发服务系统"></a>9.1.5.1 分发服务系统</h5><p>其基本的工作单元就是各个 Cache 服务器。负责直接响应用户请求，将内容快速分发到用户；同时还负责内容更新，保证和源站内容的同步。</p><p>根据内容类型和服务种类的不同，分发服务系统分为多个子服务系统，如：**<em>网页加速服务、流媒体加速服务、应用加速服务等**</em>。每个子服务系统都是一个分布式的服务集群，由功能类似、地域接近的分布部署的 Cache 集群组成。</p><p><strong><em>在承担内容同步、更新和响应用户请求之外，分发服务系统还需要向上层的管理调度系统反馈各个Cache 设备的健康状况、响应情况、内容缓存状况等，以便管理调度系统能够根据设定的策略决定由哪个 Cache 设备来响应用户的请求</em></strong>。</p><h5 id="9-1-5-2-负载均衡系统"><a href="#9-1-5-2-负载均衡系统" class="headerlink" title="9.1.5.2 负载均衡系统"></a>9.1.5.2 负载均衡系统</h5><p>负载均衡系统是整个 CDN 系统的中枢。负责对所有的用户请求进行调度，确定提供给用户的最终访问地址。</p><p>使用分级实现。最基本的两极调度体系包括全局负载均衡（GSLB）和本地负载均衡（SLB）。</p><p>GSLB 根据用户地址和用户请求的内容，**<em>主要根据就近性原则，确定向用户服务的节点。一般通过 DNS解析或者应用层重定向（Http 3XX 重定向）的方式实现**</em>。</p><p>SLB 主要负责节点内部的负载均衡。当用户请求从 GSLB 调度到 SLB 时，SLB 会根据节点内各个Cache 设备的工作状况和内容分布情况等对用户请求重定向。**<em>SLB 的实现有四层调度（LVS）、七层调度（Nginx）和链路负载调度等**</em>。</p><h5 id="9-1-5-3-管理系统"><a href="#9-1-5-3-管理系统" class="headerlink" title="9.1.5.3 管理系统"></a>9.1.5.3 管理系统</h5><p>分为运营管理和网络管理子系统。</p><p>网络管理系统实现对 CDN 系统的设备管理、拓扑管理、链路监控和故障管理，为管理员提供对全网资源的可视化的集中管理，通常用 web 方式实现。</p><p>运营管理是对 CDN 系统的业务管理，负责处理业务层面的与外界系统交互所必须的一些收集、整理、交付工作。**<em>包括用户管理、产品管理、计费管理、统计分析等**</em>。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/CDNPrinciple.png"></p><h2 id="10-日志"><a href="#10-日志" class="headerlink" title="10. 日志"></a><strong>10. 日志</strong></h2><h4 id="10-1-1-Slf4j"><a href="#10-1-1-Slf4j" class="headerlink" title="10.1.1 Slf4j"></a>10.1.1 Slf4j</h4><p>slf4j 的全称是 Simple Loging Facade For Java，即它仅仅是一个为 Java 程序提供日志输出的统一接口，并不是一个具体的日志实现方案，就比如 JDBC 一样，只是一种规则而已。所以单独的 slf4j 是不能工作的，必须搭配其他具体的日志实现方案，比如 apache 的 org.apache.log4j.Logger，jdk 自带的 java.util.logging.Logger 等。</p><h4 id="10-1-2-Log4j"><a href="#10-1-2-Log4j" class="headerlink" title="10.1.2 Log4j"></a>10.1.2 Log4j</h4><p>Log4j 是 Apache 的一个开源项目，通过使用 Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI 组件，甚至是套接口服务器、NT 的事件记录器、UNIX Syslog 守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。</p><p>Log4j 由三个重要的组成构成：日志记录器(Loggers)，输出端(Appenders)和日志格式化器(Layout)。</p><p>1.Logger：控制要启用或禁用哪些日志记录语句，并对日志信息进行级别限制</p><p>2.Appenders : 指定了日志将打印到控制台还是文件中</p><p>3.Layout : 控制日志信息的显示格式</p><p>Log4j 中将要输出的 Log 信息定义了 5 种级别，依次为 DEBUG、INFO、WARN、ERROR 和 FATAL，当输出时，只有级别高过配置中规定的 级别的信息才能真正的输出，这样就很方便的来配置不同情况下要输出的内容，而不需要更改代码。</p><h4 id="10-1-3-LogBack"><a href="#10-1-3-LogBack" class="headerlink" title="10.1.3 LogBack"></a>10.1.3 LogBack</h4><p>简单地说，Logback 是一个 Java 领域的日志框架。它被认为是 Log4J 的继承人。</p><p>Logback 主要由三个模块组成：**<em>logback-core，logback-classic，logback-access**</em>。</p><p>logback-core 是其它模块的基础设施，其它模块基于它构建，显然，logback-core 提供了一些关键的通用机制。</p><p>logback-classic 的地位和作用等同于 Log4J，它也被认为是 Log4J 的一个改进版，并且它实现了简单日志门面 SLF4J。</p><p>logback-access 主要作为一个与 Servlet 容器交互的模块，比如说 tomcat 或者 jetty，提供一些与HTTP 访问相关的功能。</p><h5 id="10-1-3-1-Logback-优点"><a href="#10-1-3-1-Logback-优点" class="headerlink" title="10.1.3.1 Logback 优点"></a>10.1.3.1 Logback 优点</h5><ul><li>同样的代码路径，Logback 执行更快</li><li>更充分的测试</li><li>原生实现了 SLF4J API（Log4J 还需要有一个中间转换层）</li><li>内容更丰富的文档</li><li>支持 XML 或者 Groovy 方式配置</li><li>配置文件自动热加载</li><li>从 IO 错误中优雅恢复</li><li>自动删除日志归档</li><li>自动压缩日志成为归档文件</li><li>支持 Prudent 模式，使多个 JVM 进程能记录同一个日志文件</li><li>支持配置文件中加入条件判断来适应不同的环境</li><li>更强大的过滤器</li><li>支持 SiftingAppender（可筛选 Appender） </li><li>异常栈信息带有包信息</li></ul><h4 id="10-1-4-ELK"><a href="#10-1-4-ELK" class="headerlink" title="10.1.4 ELK"></a>10.1.4 ELK</h4><p>ELK 是软件集合 Elasticsearch、Logstash、Kibana 的简称，由这三个软件及其相关的组件可以打造大规模日志实时处理系统。</p><ul><li><p>Elasticsearch 是一个基于 Lucene 的、支持全文索引的分布式存储和索引引擎，主要负责将日志索引并存储起来，方便业务方检索查询。</p></li><li><p>Logstash 是一个日志收集、过滤、转发的中间件，主要负责将各条业务线的各类日志统一收集、过滤后，转发给 Elasticsearch 进行下一步处理。</p></li><li><p>Kibana 是一个可视化工具，主要负责查询 Elasticsearch 的数据并以可视化的方式展现给业务方，比如各类饼图、直方图、区域图等。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/ELK.png"></p></li></ul><h2 id="11-Zookeeper"><a href="#11-Zookeeper" class="headerlink" title="11. Zookeeper"></a><strong>11. Zookeeper</strong></h2><h4 id="11-1-1-Zookeeper-概念"><a href="#11-1-1-Zookeeper-概念" class="headerlink" title="11.1.1 Zookeeper 概念"></a>11.1.1 Zookeeper 概念</h4><p>Zookeeper 是一个分布式协调服务，可用于服务发现，分布式锁，分布式领导选举，配置管理等。</p><p>Zookeeper 提供了一个类似于 Linux 文件系统的树形结构（可认为是轻量级的内存文件系统，但只适合存少量信息，完全不适合存储大量文件或者大文件），同时提供了对于每个节点的监控与通知机制。</p><p><strong><em>Zookeeper 角色</em></strong></p><p>Zookeeper 集群是一个基于主从复制的高可用集群，每个服务器承担如下三种角色中的一种。</p><h5 id="11-1-1-1-Leader"><a href="#11-1-1-1-Leader" class="headerlink" title="11.1.1.1 Leader"></a>11.1.1.1 Leader</h5><ol><li><p>一个 Zookeeper 集群同一时间只会有一个实际工作的 Leader，它会发起并维护与各 Follwer及 Observer 间的心跳。</p></li><li><p><strong><em>所有的写操作必须要通过 Leader 完成再由 Leader 将写操作广播给其它服务器。只要有超过半数节点（不包括 observeer 节点）写入成功，该写请求就会被提交（类 2PC 协议）</em></strong>。</p></li></ol><h5 id="11-1-1-2-Follower"><a href="#11-1-1-2-Follower" class="headerlink" title="11.1.1.2 Follower"></a>11.1.1.2 Follower</h5><ol><li><p>一个 Zookeeper 集群可能同时存在多个 Follower，它会响应 Leader 的心跳，</p></li><li><p><strong><em>Follower 可直接处理并返回客户端的读请求，同时会将写请求转发给 Leader 处理</em></strong>，</p></li><li><p><strong><em>并且负责在 Leader 处理写请求时对请求进行投票</em></strong>。</p></li></ol><h5 id="11-1-1-3-Observer"><a href="#11-1-1-3-Observer" class="headerlink" title="11.1.1.3 Observer"></a>11.1.1.3 Observer</h5><p>角色与 Follower 类似，但是无投票权。Zookeeper 需保证高可用和强一致性，为了支持更多的客户端，需要增加更多 Server；**<em>Server 增多，投票阶段延迟增大，影响性能；引入 Observer，Observer 不参与投票； Observers 接受客户端的连接，并将写请求转发给 leader 节点**</em>； 加入更多 Observer 节点，提高伸缩性，同时不影响吞吐率。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/ZookeeperEnsemble.png"></p><h5 id="11-1-1-4-ZAB-协议"><a href="#11-1-1-4-ZAB-协议" class="headerlink" title="11.1.1.4 ZAB 协议"></a>11.1.1.4 ZAB 协议</h5><p><strong><em>事务编号 Zxid（事务请求计数器+ epoch）</em></strong> </p><p>在 ZAB ( ZooKeeper Atomic Broadcast , ZooKeeper 原子消息广播协议） 协议的事务编号 Zxid 设计中，Zxid 是一个 64 位的数字，其中低 32 位是一个简单的单调递增的计数器，*<strong>针对客户端每一个事务请求，计数器加 1**<em>；而高 32 位则代表 Leader 周期 epoch 的编号，</em></strong>每个当选产生一个新的 Leader 服务器，就会从这个 Leader 服务器上取出其本地日志中最大事务的 ZXID，并从中读取epoch 值，然后加 1，以此作为新的 epoch***，并将低 32 位从 0 开始计数。</p><p>Zxid（Transaction id）类似于 RDBMS 中的事务 ID，用于标识一次更新操作的 Proposal（提议）ID。为了保证顺序性，该 zkid 必须单调递增。</p><p><strong><em>epoch</em></strong></p><p>epoch：可以理解为当前集群所处的年代或者周期，每个 leader 就像皇帝，都有自己的年号，所以每次改朝换代，leader 变更之后，都会在前一个年代的基础上加 1。这样就算**<em>旧的 leader 崩溃恢复之后，也没有人听他的了，因为 follower 只听从当前年代的 leader 的命令**</em>。</p><p><strong><em>Zab 协议有两种模式-恢复模式（选主）、广播模式（同步）</em></strong></p><p>Zab 协议有两种模式，它们分别是**<em>恢复模式（选主）和广播模式（同步）**</em>。当服务启动或者在领导者崩溃后，Zab 就进入了恢复模式，当领导者被选举出来，且大多数 Server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 Server 具有相同的系统状态。</p><p><strong><em>ZAB 协议 4 阶段</em></strong></p><p>​    <strong><em>Leader election（选举阶段-选出准 Leader）</em></strong></p><ol><li><p>Leader election（选举阶段）：节点在一开始都处于选举阶段，只要有一个节点得到超半数节点的票数，它就可以当选准 leader。只有到达 广播阶段（broadcast） 准 leader 才会成为真正的 leader。这一阶段的目的是就是为了选出一个**<em>准 leader**</em>，然后进入下一个阶段。</p><p><strong><em>Discovery（发现阶段-接受提议、生成 epoch、接受 epoch）</em></strong></p></li><li><p>Discovery（发现阶段）：在这个阶段，*<strong>followers 跟准 leader 进行通信，同步 followers 最近接收的事务提议**<em>。这个一阶段的</em></strong>主要目的是发现当前大多数节点接收的最新提议*<strong>，并且**<em>准 leader 生成新的 epoch，让 followers 接受，更新它们的 accepted Epoch</em></strong></p><p>一个 follower 只会连接一个 leader，**<em>如果有一个节点 f 认为另一个 follower p 是 leader，f 在尝试连接 p 时会被拒绝，f 被拒绝之后，就会进入重新选举阶段**</em>。</p><p><strong><em>Synchronization（同步阶段-同步 follower 副本）</em></strong></p></li><li><p>Synchronization（同步阶段）：同步阶段主要是利用 <strong><em>leader 前一阶段获得的最新提议历史，同步集群中所有的副本。只有当 大多数节点都同步完成，准 leader 才会成为真正的 leader</em></strong>。follower 只会接收 zxid 比自己的 lastZxid 大的提议。</p><p><strong><em>Broadcast（广播阶段-leader 消息广播）</em></strong></p></li><li><p>Broadcast（广播阶段）：到了这个阶段，**<em>Zookeeper 集群才能正式对外提供事务服务，并且 leader 可以进行消息广播**</em>。同时如果有新的节点加入，还需要对新节点进行同步。</p></li></ol><p>ZAB 提交事务并不像 2PC 一样需要全部 follower 都 ACK，**<em>只需要得到超过半数的节点的 ACK 就可以了**</em>。</p><p><strong><em>ZAB 协议 JAVA 实现（FLE-发现阶段和同步合并为 Recovery Phase（恢复阶段））</em></strong></p><p>协议的 Java 版本实现跟上面的定义有些不同，选举阶段使用的是 Fast Leader Election（FLE），它包含了 选举的发现职责。因为 FLE 会选举拥有最新提议历史的节点作为 leader，这样就省去了发现最新提议的步骤。实际的实现将 发现阶段 和 同步合并为 Recovery Phase（恢复阶段）。所以，ZAB 的实现只有三个阶段：Fast Leader Election；Recovery Phase；Broadcast Phase。</p><h5 id="11-1-1-5-投票机制"><a href="#11-1-1-5-投票机制" class="headerlink" title="11.1.1.5 投票机制"></a>11.1.1.5 投票机制</h5><p><strong><em>每个 sever 首先给自己投票，然后用自己的选票和其他 sever 选票对比，权重大的胜出，使用权重较大的更新自身选票箱</em></strong>。具体选举过程如下：</p><ol><li><p>每个 Server 启动以后**<em>都询问其它的 Server 它要投票给谁**</em>。对于其他 server 的询问，server 每次根据自己的状态都回复自己推荐的 leader 的 id 和上一次处理事务的 zxid（系统启动时每个 server 都会推荐自己）</p></li><li><p>收到所有 Server 回复以后，就**<em>计算出 zxid 最大的哪个 Server**</em>，并将这个 Server 相关信息设置成下一次要投票的 Server。</p></li><li><p>计算这过程中**<em>获得票数最多的的 sever 为获胜者**</em>，如果获胜者的票数超过半数，则改server 被选为 leader。否则，继续这个过程，直到 leader 被选举出来 </p></li><li><p>leader 就会开始等待 server 连接</p></li><li><p>Follower 连接 leader，将最大的 zxid 发送给 leader</p></li><li><p>Leader 根据 follower 的 zxid 确定同步点，至此选举阶段完成。</p></li><li><p>选举阶段完成 Leader 同步后通知 follower 已经成为 uptodate 状态</p></li><li><p>Follower 收到 uptodate 消息后，又可以重新接受 client 的请求进行服务了</p></li></ol><p>目前有 5 台服务器，每台服务器均没有数据，它们的编号分别是 1,2,3,4,5,按编号依次启动，它们的选择举过程如下：</p><ol><li><p>服务器 1 启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反馈信息，服务器 1 的状态一直属于 Looking。</p></li><li><p>服务器 2 启动，给自己投票，同时与之前启动的服务器 1 交换结果，由于服务器 2 的编号大所以服务器 2 胜出，但此时投票数没有大于半数，所以两个服务器的状态依然是LOOKING。</p></li><li><p>服务器 3 启动，给自己投票，同时与之前启动的服务器 1,2 交换信息，由于服务器 3 的编号最大所以服务器 3 胜出，此时投票数正好大于半数，所以服务器 3 成为领导者，服务器1,2 成为小弟。</p></li><li><p>服务器 4 启动，给自己投票，同时与之前启动的服务器 1,2,3 交换信息，尽管服务器 4 的编号大，但之前服务器 3 已经胜出，所以服务器 4 只能成为小弟。</p></li><li><p>服务器 5 启动，后面的逻辑同服务器 4 成为小弟。</p></li></ol><h4 id="11-1-2-Zookeeper-工作原理（原子广播）"><a href="#11-1-2-Zookeeper-工作原理（原子广播）" class="headerlink" title="11.1.2 Zookeeper 工作原理（原子广播）"></a>11.1.2 Zookeeper 工作原理（原子广播）</h4><ol><li><p><strong><em>Zookeeper 的核心是原子广播</em></strong>，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 Zab 协议。Zab 协议有两种模式，它们分别是恢复模式和广播模式。</p></li><li><p>当服务启动或者在领导者崩溃后，Zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 的完成了和 leader 的状态同步以后，恢复模式就结束了。</p></li><li><p>状态同步保证了 leader 和 server 具有相同的系统状态</p></li><li><p><strong><em>一旦 leader 已经和多数的 follower 进行了状态同步后，他就可以开始广播消息了</em></strong>，即进入广播状态。这时候当一个 server 加入 zookeeper 服务中，它会在恢复模式下启动，发现 leader，并和 leader 进行状态同步。待到同步结束，它也参与消息广播。Zookeeper服务一直维持在 Broadcast 状态，直到 leader 崩溃了或者 leader 失去了大部分的followers 支持。</p></li><li><p>广播模式需要保证 proposal 被按顺序处理，因此 zk 采用了递增的事务 id 号(zxid)来保证。所有的提议(proposal)都在被提出的时候加上了 zxid。</p></li><li><p>实现中 zxid 是一个 64 为的数字，它高 32 位是 epoch 用来标识 leader 关系是否改变，每次一个 leader 被选出来，它都会有一个新的 epoch。低 32 位是个递增计数。</p></li><li><p>当 leader 崩溃或者 leader 失去大多数的 follower，这时候 zk 进入恢复模式，恢复模式需要重新选举出一个新的 leader，让所有的 server 都恢复到一个正确的状态。</p></li></ol><h4 id="11-1-3-Znode-有四种形式的目录节点"><a href="#11-1-3-Znode-有四种形式的目录节点" class="headerlink" title="11.1.3 Znode 有四种形式的目录节点"></a>11.1.3 Znode 有四种形式的目录节点</h4><ol><li><p>PERSISTENT：持久的节点。</p></li><li><p>EPHEMERAL：暂时的节点。</p></li><li><p>PERSISTENT_SEQUENTIAL：持久化顺序编号目录节点。</p></li><li><p>EPHEMERAL_SEQUENTIAL：暂时化顺序编号目录节点。</p></li></ol><h2 id="12-Kafka"><a href="#12-Kafka" class="headerlink" title="12. Kafka"></a><strong>12. Kafka</strong></h2><h4 id="12-1-1-Kafka-概念"><a href="#12-1-1-Kafka-概念" class="headerlink" title="12.1.1 Kafka 概念"></a>12.1.1 Kafka 概念</h4><p>Kafka 是一种高吞吐量、分布式、基于发布/订阅的消息系统，最初由 LinkedIn 公司开发，使用Scala 语言编写，目前是 Apache 的开源项目。</p><ol><li><p>broker：Kafka 服务器，负责消息存储和转发</p></li><li><p>topic：消息类别，Kafka 按照 topic 来分类消息</p></li><li><p>partition：topic 的分区，一个 topic 可以包含多个 partition，topic 消息保存在各个partition 上</p></li><li><p>offset：消息在日志中的位置，可以理解是消息在 partition 上的偏移量，也是代表该消息的唯一序号</p></li><li><p>Producer：消息生产者</p></li><li><p>Consumer：消息消费者</p></li><li><p>Consumer Group：消费者分组，每个 Consumer 必须属于一个 group</p></li><li><p>Zookeeper：保存着集群 broker、topic、partition 等 meta 数据；另外，还负责 broker 故障发现，partition leader 选举，负载均衡等功能。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/Kafka.png"></p></li></ol><h4 id="12-1-2-Kafka-数据存储设计"><a href="#12-1-2-Kafka-数据存储设计" class="headerlink" title="12.1.2 Kafka 数据存储设计"></a>12.1.2 Kafka 数据存储设计</h4><h5 id="12-1-2-1-partition-的数据文件（offset，MessageSize，data）"><a href="#12-1-2-1-partition-的数据文件（offset，MessageSize，data）" class="headerlink" title="12.1.2.1 partition 的数据文件（offset，MessageSize，data）"></a>12.1.2.1 partition 的数据文件（offset，MessageSize，data）</h5><p>partition 中的每条 Message 包含了以下三个属性：offset，MessageSize，data，其中 <strong><em>offset 表 示 Message 在这个 partition 中的偏移量，offset 不是该 Message 在 partition 数据文件中的实际存储位置，而是逻辑上一个值</em></strong>，它唯一确定了 partition 中的一条 Message，可以认为 offset 是partition 中 Message 的 id；MessageSize 表示消息内容 data 的大小；data 为 Message 的具体内容。</p><h5 id="12-1-2-2-数据文件分段-segment（顺序读写、分段命令、二分查找）"><a href="#12-1-2-2-数据文件分段-segment（顺序读写、分段命令、二分查找）" class="headerlink" title="12.1.2.2 数据文件分段 segment（顺序读写、分段命令、二分查找）"></a>12.1.2.2 数据文件分段 segment（顺序读写、分段命令、二分查找）</h5><p>partition 物理上由多个 segment 文件组成，每个 segment 大小相等，顺序读写。每个 segment数据文件以该段中最小的 offset 命名，文件扩展名为.log。这样在查找指定 offset 的 Message 的时候，用二分查找就可以定位到该 Message 在哪个 segment 数据文件中。</p><h5 id="12-1-2-3-数据文件索引（分段索引、稀疏存储）"><a href="#12-1-2-3-数据文件索引（分段索引、稀疏存储）" class="headerlink" title="12.1.2.3 数据文件索引（分段索引、稀疏存储）"></a>12.1.2.3 数据文件索引（分段索引、稀疏存储）</h5><p>Kafka 为每个分段后的数据文件建立了索引文件，文件名与数据文件的名字是一样的，只是文件扩展名为.index。index 文件中并没有为数据文件中的每条 Message 建立索引，而是采用了稀疏存储的方式，每隔一定字节的数据建立一条索引。这样避免了索引文件占用过多的空间，从而可以将索引文件保留在内存中。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/KafkaDataFileIndex.png"></p><h4 id="12-1-3-生产者设计"><a href="#12-1-3-生产者设计" class="headerlink" title="12.1.3 生产者设计"></a>12.1.3 生产者设计</h4><h5 id="12-1-3-1-负载均衡（partition-会均衡分布到不同-broker-上）"><a href="#12-1-3-1-负载均衡（partition-会均衡分布到不同-broker-上）" class="headerlink" title="12.1.3.1 负载均衡（partition 会均衡分布到不同 broker 上）"></a>12.1.3.1 负载均衡（partition 会均衡分布到不同 broker 上）</h5><p>由于消息 topic 由多个 partition 组成，**<em>且 partition 会均衡分布到不同 broker 上，因此，为了有效利用 broker 集群的性能，提高消息的吞吐量**</em>，producer 可以通过随机或者 hash 等方式，将消息平均发送到多个 partition 上，以实现负载均衡。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/LoadBalancing.png"></p><h5 id="12-1-3-2-批量发送"><a href="#12-1-3-2-批量发送" class="headerlink" title="12.1.3.2 批量发送"></a>12.1.3.2 批量发送</h5><p>是提高消息吞吐量重要的方式，Producer 端可以在内存中合并多条消息后，**<em>以一次请求的方式发送了批量的消息给 broker**</em>，从而大大减少 broker 存储消息的 IO 操作次数。但也一定程度上影响了消息的实时性，相当于以时延代价，换取更好的吞吐量。</p><h5 id="12-1-3-3-压缩（GZIP-或-Snappy）"><a href="#12-1-3-3-压缩（GZIP-或-Snappy）" class="headerlink" title="12.1.3.3 压缩（GZIP 或 Snappy）"></a>12.1.3.3 压缩（GZIP 或 Snappy）</h5><p>Producer 端可以通过 GZIP 或 Snappy 格式对消息集合进行压缩。Producer 端进行压缩之后，在Consumer 端需进行解压。压缩的好处就是减少传输的数据量，减轻对网络传输的压力，在对大数据处理上，瓶颈往往体现在网络上而不是 CPU（压缩和解压会耗掉部分 CPU 资源）。</p><h4 id="12-1-4-消费者设计"><a href="#12-1-4-消费者设计" class="headerlink" title="12.1.4 消费者设计"></a>12.1.4 消费者设计</h4><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/KafkaConsumerDesignPattern.png"></p><h5 id="12-1-4-1-Consumer-Group"><a href="#12-1-4-1-Consumer-Group" class="headerlink" title="12.1.4.1 Consumer Group"></a>12.1.4.1 Consumer Group</h5><p>同一 Consumer Group 中的多个 Consumer 实例，不同时消费同一个 partition，等效于队列模式。partition 内消息是有序的，Consumer 通过 pull 方式消费消息。Kafka 不删除已消费的消息对于 partition，顺序读写磁盘数据，以时间复杂度 O(1)方式提供消息持久化能力。</p><h2 id="13-RabbitMQ"><a href="#13-RabbitMQ" class="headerlink" title="13. RabbitMQ"></a><strong>13. RabbitMQ</strong></h2><h4 id="13-1-1-概念"><a href="#13-1-1-概念" class="headerlink" title="13.1.1 概念"></a>13.1.1 概念</h4><p>RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。</p><p><strong><em>AMQP ：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准</em></strong>，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。</p><p><strong><em>RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗</em></strong>。具体特点包括：</p><ol><li><p><strong><em>可靠性（Reliability）</em></strong>：RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。</p></li><li><p>灵活的路由（Flexible Routing）：在消息进入队列之前，通过 Exchange 来路由消息的。对于典型的路由功能，RabbitMQ 已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个 Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。</p></li><li><p>消息集群（Clustering）：多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。</p></li><li><p>高可用（Highly Available Queues）：队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。</p></li><li><p>多种协议（Multi-protocol）：RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。</p></li><li><p>多语言客户端（Many Clients）：RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等等。</p></li><li><p><strong><em>管理界面（Management UI）</em></strong>:RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方面。</p></li><li><p><strong><em>跟踪机制（Tracing）</em></strong>:如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。</p></li><li><p>插件机制（Plugin System）:RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。</p></li></ol><h4 id="13-1-2-RabbitMQ-架构"><a href="#13-1-2-RabbitMQ-架构" class="headerlink" title="13.1.2 RabbitMQ 架构"></a>13.1.2 RabbitMQ 架构</h4><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/RabbitMQArchitecture.png"></p><h5 id="13-1-2-1-Message"><a href="#13-1-2-1-Message" class="headerlink" title="13.1.2.1 Message"></a>13.1.2.1 Message</h5><p>消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括 routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。</p><h5 id="13-1-2-2-Publisher"><a href="#13-1-2-2-Publisher" class="headerlink" title="13.1.2.2 Publisher"></a>13.1.2.2 Publisher</h5><ol><li>消息的生产者，也是一个向交换器发布消息的客户端应用程序。</li></ol><h5 id="13-1-2-3-Exchange（将消息路由给队列-）"><a href="#13-1-2-3-Exchange（将消息路由给队列-）" class="headerlink" title="13.1.2.3 Exchange（将消息路由给队列 ）"></a>13.1.2.3 Exchange（将消息路由给队列 ）</h5><ol start="2"><li>交换器，**<em>用来接收生产者发送的消息并将这些消息路由给服务器中的队列**</em>。</li></ol><h5 id="13-1-2-4-Binding（消息队列和交换器之间的关联）"><a href="#13-1-2-4-Binding（消息队列和交换器之间的关联）" class="headerlink" title="13.1.2.4 Binding（消息队列和交换器之间的关联）"></a>13.1.2.4 Binding（消息队列和交换器之间的关联）</h5><ol start="3"><li>绑定，**<em>用于消息队列和交换器之间的关联**</em>。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</li></ol><h5 id="13-1-2-5-Queue"><a href="#13-1-2-5-Queue" class="headerlink" title="13.1.2.5 Queue"></a>13.1.2.5 Queue</h5><ol start="4"><li>消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。**<em>一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走**</em>。</li></ol><h5 id="13-1-2-6-Connection"><a href="#13-1-2-6-Connection" class="headerlink" title="13.1.2.6 Connection"></a>13.1.2.6 Connection</h5><ol start="5"><li>网络连接，比如一个 TCP 连接。</li></ol><h5 id="13-1-2-7-Channel"><a href="#13-1-2-7-Channel" class="headerlink" title="13.1.2.7 Channel"></a>13.1.2.7 Channel</h5><ol start="6"><li>信道，**<em>多路复用连接中的一条独立的双向数据流通道**</em>。信道是建立在真实的 TCP 连接内地虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</li></ol><h5 id="13-1-2-8-Consumer"><a href="#13-1-2-8-Consumer" class="headerlink" title="13.1.2.8 Consumer"></a>13.1.2.8 Consumer</h5><ol start="7"><li>消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。</li></ol><h5 id="13-1-2-9-Virtual-Host"><a href="#13-1-2-9-Virtual-Host" class="headerlink" title="13.1.2.9 Virtual Host"></a>13.1.2.9 Virtual Host</h5><ol start="8"><li>虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。</li></ol><h5 id="13-1-2-10-Broker"><a href="#13-1-2-10-Broker" class="headerlink" title="13.1.2.10  Broker"></a>13.1.2.10  Broker</h5><ol start="9"><li>表示消息队列服务器实体。</li></ol><h4 id="13-1-3-Exchange-类型"><a href="#13-1-3-Exchange-类型" class="headerlink" title="13.1.3 Exchange 类型"></a>13.1.3 Exchange 类型</h4><p>Exchange 分发消息时根据类型的不同分发策略有区别，**<em>目前共四种类型：direct、fanout、topic、headers 。headers 匹配 AMQP 消息的 header 而不是路由键**</em>，此外 headers 交换器和direct 交换器完全一致，但性能差很多，目前几乎用不到了，所以直接看另外三种类型：</p><h5 id="13-1-3-1-Direct-键（routing-key）分布："><a href="#13-1-3-1-Direct-键（routing-key）分布：" class="headerlink" title="13.1.3.1 Direct 键（routing key）分布："></a>13.1.3.1 Direct 键（routing key）分布：</h5><ol><li><p>Direct：消息中的**<em>路由键（routing key）如果和 Binding 中的 binding key 一致**</em>，交换器就将消息发到对应的队列中。它是完全匹配、单播的模式。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/DirectKey.png"></p></li></ol><h5 id="13-1-3-2-Fanout（广播分发）"><a href="#13-1-3-2-Fanout（广播分发）" class="headerlink" title="13.1.3.2  Fanout（广播分发）"></a>13.1.3.2  Fanout（广播分发）</h5><ol start="2"><li><p>Fanout：每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去。很像子网广播，每台子网内的主机都获得了一份复制的消息。fanout 类型转发消息是最快的。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/FanoutExchange.png"></p></li></ol><h5 id="13-1-3-3-topic-交换器（模式匹配）"><a href="#13-1-3-3-topic-交换器（模式匹配）" class="headerlink" title="13.1.3.3 topic 交换器（模式匹配）"></a>13.1.3.3 topic 交换器（模式匹配）</h5><ol start="3"><li><p>topic 交换器：topic 交换器通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。它同样也会识别两个通配符：符号“#”和符号“”。#匹配 0 个或多个单词，匹配不多不少一个单词。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/TopicExchange.png"></p></li></ol><h2 id="14-Hbase"><a href="#14-Hbase" class="headerlink" title="14. Hbase"></a><strong>14. Hbase</strong></h2><h4 id="14-1-1-概念"><a href="#14-1-1-概念" class="headerlink" title="14.1.1 概念"></a>14.1.1 概念</h4><p>base 是分布式、面向列的开源数据库（其实准确的说是面向列族）。HDFS 为 Hbase 提供可靠的底层数据存储服务，MapReduce 为 Hbase 提供高性能的计算能力，Zookeeper 为 Hbase 提供稳定服务和 Failover 机制，因此我们说 Hbase 是一个通过大量廉价的机器解决海量数据的高速存储和读取的分布式数据库解决方案。</p><h4 id="14-1-2-列式存储"><a href="#14-1-2-列式存储" class="headerlink" title="14.1.2 列式存储"></a>14.1.2 列式存储</h4><p>列方式所带来的重要好处之一就是，由于查询中的选择规则是通过列来定义的，因此整个数据库是自动索引化的。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/ColumnarStorage.png"></p><p>这里的列式存储其实说的是列族存储，Hbase 是根据列族来存储数据的。列族下面可以有非常多的列，列族在创建表的时候就必须指定。为了加深对 Hbase 列族的理解，下面是一个简单的关系型数据库的表和 Hbase 数据库的表：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/HbaseDatabase.png"></p><h4 id="14-1-3-Hbase-核心概念"><a href="#14-1-3-Hbase-核心概念" class="headerlink" title="14.1.3 Hbase 核心概念"></a>14.1.3 Hbase 核心概念</h4><h5 id="14-1-3-1-Column-Family-列族"><a href="#14-1-3-1-Column-Family-列族" class="headerlink" title="14.1.3.1 Column Family 列族"></a>14.1.3.1 Column Family 列族</h5><p>Column Family 又叫列族，Hbase 通过列族划分数据的存储，列族下面可以包含任意多的列，实现灵活的数据存取。Hbase 表的创建的时候就必须指定列族。就像关系型数据库创建的时候必须指定具体的列是一样的。Hbase 的列族不是越多越好，官方推荐的是列族最好小于或者等于 3。我们使用的场景一般是 1 个列族。</p><h5 id="14-1-3-2-Rowkey（-Rowkey-查询，Rowkey-范围扫描，全表扫描-）"><a href="#14-1-3-2-Rowkey（-Rowkey-查询，Rowkey-范围扫描，全表扫描-）" class="headerlink" title="14.1.3.2 Rowkey（**Rowkey 查询，Rowkey 范围扫描，全表扫描**）"></a>14.1.3.2 Rowkey（**<em>Rowkey 查询，Rowkey 范围扫描，全表扫描**</em>）</h5><p>Rowkey 的概念和 mysql 中的主键是完全一样的，Hbase 使用 Rowkey 来唯一的区分某一行的数据。**<em>Hbase 只支持 3 中查询方式：基于 Rowkey 的单行查询，基于 Rowkey 的范围扫描，全表扫描**</em>。</p><h5 id="14-1-3-3-Region-分区"><a href="#14-1-3-3-Region-分区" class="headerlink" title="14.1.3.3 Region 分区"></a>14.1.3.3 Region 分区</h5><ul><li><strong>Region</strong>：Region 的概念和关系型数据库的分区或者分片差不多。Hbase 会将一个大表的数据**<em>基于 Rowkey 的不同范围分配到不通的 Region 中**</em>，每个 Region 负责一定范围的数据访问和存储。这样即使是一张巨大的表，由于被切割到不通的 region，访问起来的时延也很低。</li></ul><h5 id="14-1-3-4-TimeStamp-多版本"><a href="#14-1-3-4-TimeStamp-多版本" class="headerlink" title="14.1.3.4 TimeStamp 多版本"></a>14.1.3.4 TimeStamp 多版本</h5><ul><li>TimeStamp 是实现 Hbase 多版本的关键。在 Hbase 中使用不同的 timestame 来标识相同rowkey 行对应的不通版本的数据。在写入数据的时候，如果用户没有指定对应的timestamp，Hbase 会自动添加一个 timestamp，timestamp 和服务器时间保持一致。在Hbase 中，相同 rowkey 的数据按照 timestamp 倒序排列。默认查询的是最新的版本，用户可同指定 timestamp 的值来读取旧版本的数据。</li></ul><h4 id="14-1-4-Hbase-核心架构"><a href="#14-1-4-Hbase-核心架构" class="headerlink" title="14.1.4 Hbase 核心架构"></a>14.1.4 Hbase 核心架构</h4><p><strong><em>Hbase 是由 Client、Zookeeper、Master、HRegionServer、HDFS</em></strong> 等几个组建组成。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/HbaseCoreArchitecture.png"></p><h5 id="14-1-4-1-Client："><a href="#14-1-4-1-Client：" class="headerlink" title="14.1.4.1 Client："></a>14.1.4.1 Client：</h5><ul><li> Client 包含了访问 Hbase 的接口，另外 Client 还维护了对应的 cache 来加速 Hbase 的访问，比如 cache 的.META.元数据的信息。</li></ul><h5 id="14-1-4-2-Zookeeper："><a href="#14-1-4-2-Zookeeper：" class="headerlink" title="14.1.4.2 Zookeeper："></a>14.1.4.2 Zookeeper：</h5><ul><li> Hbase 通过 Zookeeper 来做 master 的高可用、RegionServer 的监控、元数据的入口以及集群配置的维护等工作。具体工作如下：</li></ul><ol><li><p>通过 Zoopkeeper 来保证集群中只有 1 个 master 在运行，如果 master 异常，会通过竞争机制产生新的 master 提供服务</p></li><li><p>通过 Zoopkeeper 来监控 RegionServer 的状态，当 RegionSevrer 有异常的时候，通过回调的形式通知 Master RegionServer 上下限的信息</p></li><li><p><strong><em>通过 Zoopkeeper 存储元数据的统一入口地址</em></strong>。</p></li></ol><h5 id="14-1-4-3-Hmaster"><a href="#14-1-4-3-Hmaster" class="headerlink" title="14.1.4.3 Hmaster"></a>14.1.4.3 Hmaster</h5><ul><li> master 节点的主要职责如下：</li></ul><ol><li><p>为 RegionServer 分配 Region</p></li><li><p>维护整个集群的负载均衡</p></li><li><p>维护集群的元数据信息发现失效的 Region，并将失效的 Region 分配到正常RegionServer 上当 RegionSever 失效的时候，协调对应 Hlog 的拆分</p></li></ol><h5 id="14-1-4-4-HregionServer"><a href="#14-1-4-4-HregionServer" class="headerlink" title="14.1.4.4 HregionServer"></a>14.1.4.4 HregionServer</h5><ul><li> HregionServer 直接对接用户的读写请求，是真正的“干活”的节点。它的功能概括如下：</li></ul><ol><li><p>管理 master 为其分配的 Region</p></li><li><p>处理来自客户端的读写请求</p></li><li><p>负责和底层 HDFS 的交互，存储数据到 HDFS</p></li><li><p>负责 Region 变大以后的拆分</p></li><li><p>负责 Storefile 的合并工作</p></li></ol><h5 id="14-1-4-5-Region-寻址方式（通过-zookeeper-META）"><a href="#14-1-4-5-Region-寻址方式（通过-zookeeper-META）" class="headerlink" title="14.1.4.5 Region 寻址方式（通过 zookeeper .META）"></a>14.1.4.5 Region 寻址方式（通过 zookeeper .META）</h5><p>第 1 步：Client 请求 ZK 获取.META.所在的 RegionServer 的地址。</p><p>第 2 步：Client 请求.META.所在的 RegionServer 获取访问数据所在的 RegionServer 地址，client 会将.META.的相关信息 cache 下来，以便下一次快速访问。</p><p>第 3 步：Client 请求数据所在的 RegionServer，获取所需要的数据。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/RegionAddressingMode.png"></p><h5 id="14-1-4-6-HDFS"><a href="#14-1-4-6-HDFS" class="headerlink" title="14.1.4.6 HDFS"></a>14.1.4.6 HDFS</h5><ul><li> HDFS 为 Hbase 提供最终的底层数据存储服务，同时为 Hbase 提供高可用（Hlog 存储在HDFS）的支持。</li></ul><h4 id="14-1-5-Hbase-的写逻辑"><a href="#14-1-5-Hbase-的写逻辑" class="headerlink" title="14.1.5 Hbase 的写逻辑"></a>14.1.5 Hbase 的写逻辑</h4><h5 id="14-1-5-1-Hbase-的写入流程"><a href="#14-1-5-1-Hbase-的写入流程" class="headerlink" title="14.1.5.1 Hbase 的写入流程"></a>14.1.5.1 Hbase 的写入流程</h5><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/HbaseWritingProcess.png"></p><p>从上图可以看出氛围 3 步骤：</p><p><strong><em>获取 RegionServer</em></strong></p><p>第 1 步：Client 获取数据写入的 Region 所在的 RegionServer</p><p><strong><em>请求写 Hlog</em></strong></p><p>第 2 步：请求写 Hlog, Hlog 存储在 HDFS，当 RegionServer 出现异常，需要使用 Hlog 来恢复数据。</p><p><strong><em>请求写 MemStore</em></strong></p><p>第 3 步：请求写 MemStore,只有当写 Hlog 和写 MemStore 都成功了才算请求写入完成。**<em>MemStore 后续会逐渐刷到 HDFS 中**</em>。</p><h5 id="14-1-5-2-MemStore-刷盘"><a href="#14-1-5-2-MemStore-刷盘" class="headerlink" title="14.1.5.2 MemStore 刷盘"></a>14.1.5.2 MemStore 刷盘</h5><p>为了提高 Hbase 的写入性能，当写请求写入 MemStore 后，不会立即刷盘。而是会等到一定的时候进行刷盘的操作。具体是哪些场景会触发刷盘的操作呢？总结成如下的几个场景：</p><p><strong><em>全局内存控制</em></strong></p><ol><li>这个全局的参数是控制内存整体的使用情况，当所有 memstore 占整个 heap 的最大比例的时候，会触发刷盘的操作。这个参数是hbase.regionserver.global.memstore.upperLimit，默认为整个 heap 内存的 40%。但这并不意味着全局内存触发的刷盘操作会将所有的 MemStore 都进行输盘，而是通过另外一个参数 hbase.regionserver.global.memstore.lowerLimit 来控制，默认是整个heap 内存的 35%。当 flush 到所有 memstore 占整个 heap 内存的比率为 35%的时候，就停止刷盘。这么做主要是为了减少刷盘对业务带来的影响，实现平滑系统负载的目的。</li></ol><p><strong><em>MemStore 达到上限</em></strong></p><ol start="2"><li>当 MemStore 的大小达到 hbase.hregion.memstore.flush.size 大小的时候会触发刷盘，默认 128M 大小</li></ol><p><strong><em>RegionServer 的 Hlog 数量达到上限</em></strong></p><ol start="3"><li>前面说到 Hlog 为了保证 Hbase 数据的一致性，那么如果 Hlog 太多的话，会导致故障恢复的时间太长，因此 Hbase 会对 Hlog 的最大个数做限制。当达到 Hlog 的最大个数的时候，会强制刷盘。这个参数是 hase.regionserver.max.logs，默认是 32 个。</li></ol><p><strong><em>手工触发</em></strong></p><ol start="4"><li>可以通过 hbase shell 或者 java api 手工触发 flush 的操作。</li></ol><p><strong><em>关闭 RegionServer 触发</em></strong></p><ol start="5"><li>在正常关闭 RegionServer 会触发刷盘的操作，全部数据刷盘后就不需要再使用 Hlog 恢复数据。</li></ol><p><strong><em>Region 使用 HLOG 恢复完数据后触发</em></strong></p><ol start="6"><li>当 RegionServer 出现故障的时候，其上面的 Region 会迁移到其他正常的RegionServer 上，在恢复完 Region 的数据后，会触发刷盘，当刷盘完成后才会提供给业务访问。</li></ol><h4 id="14-1-6-HBase-vs-Cassandra"><a href="#14-1-6-HBase-vs-Cassandra" class="headerlink" title="14.1.6 HBase vs Cassandra"></a>14.1.6 HBase vs Cassandra</h4><table><thead><tr><th></th><th align="center"><strong>HBase</strong></th><th align="center"><strong>Cassandra</strong></th></tr></thead><tbody><tr><td>语言</td><td align="center">Java</td><td align="center">Java</td></tr><tr><td>出发点</td><td align="center">BigTable</td><td align="center">BigTable and Dynamo</td></tr><tr><td>License</td><td align="center">Apache</td><td align="center">Apache</td></tr><tr><td>Protocol</td><td align="center">HTTP/REST (also Thrift)</td><td align="center">Custom, binary (Thrift)</td></tr><tr><td>数据分布</td><td align="center">表划分为多个 region 存在不同 region server 上</td><td align="center">改进的一致性哈希（虚拟节点）</td></tr><tr><td>存储目标</td><td align="center">大文件</td><td align="center">小文件</td></tr><tr><td>一致性</td><td align="center">强一致性</td><td align="center">最终一致性，Quorum NRW 策略</td></tr><tr><td>架构</td><td align="center">master/slave</td><td align="center">p2p</td></tr><tr><td>高可用性</td><td align="center">NameNode 是 HDFS 的单点故障点</td><td align="center">P2P 和去中心化设计，不会出现单点故障</td></tr><tr><td>伸缩性</td><td align="center">Region Server 扩容，通过将自身发布到Master，Master 均匀分布 Region</td><td align="center">扩容需在 Hash Ring 上多个节点间调整数据分布</td></tr><tr><td>读写性能</td><td align="center">数据读写定位可能要通过最多 6 次的网络 RPC，性能较低。</td><td align="center">数据读写定位非常快</td></tr><tr><td>数据冲突处理</td><td align="center">乐观并发控制（optimistic concurrency  control）</td><td align="center">向量时钟</td></tr><tr><td>临时故障处理</td><td align="center">Region Server 宕机，重做 HLog</td><td align="center">数据回传机制：某节点宕机，hash 到该节点的新数据自动路由到下一节点做 hinted handoff，源节点恢复后，推送回源节点。</td></tr><tr><td>永久故障恢复</td><td align="center">Region Server 恢复，master 重新给其分配 region</td><td align="center">Merkle 哈希树，通过 Gossip 协议同步 Merkle Tree，维护集群节点间的数据一致性</td></tr><tr><td>成员通信及错误检测</td><td align="center">Zookeeper</td><td align="center">基于 Gossip</td></tr><tr><td>CAP</td><td align="center">1，强一致性，0 数据丢失。2，可用性低。3，扩容方便</td><td align="center">1，弱一致性，数据可能丢失。2，可用性高。3，扩容方便</td></tr></tbody></table><h2 id="15-MongoDB"><a href="#15-MongoDB" class="headerlink" title="15. MongoDB"></a><strong>15. MongoDB</strong></h2><h4 id="15-1-1-概念"><a href="#15-1-1-概念" class="headerlink" title="15.1.1 概念"></a>15.1.1 概念</h4><p>MongoDB 是由 C++语言编写的，是一个基于分布式文件存储的开源数据库系统。**<em>在高负载的情况下，添加更多的节点，可以保证服务器性能**</em>。MongoDB 旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</p><p>MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/MongoDBStorageMethod.png"></p><h4 id="15-1-2-特点"><a href="#15-1-2-特点" class="headerlink" title="15.1.2 特点"></a>15.1.2 特点</h4><ul><li> MongoDB 是一个**<em>面向文档存储的数据库**</em>，操作起来比较简单和容易。</li></ul><ul><li> 你可以在 MongoDB 记录中**<em>设置任何属性的索引**</em> (如：FirstName=”Sameer”,Address=”8 Gandhi Road”)来实现更快的排序。</li></ul><ul><li> 你可以通过本地或者网络创建数据镜像，这使得 MongoDB 有更强的扩展性。</li></ul><ul><li> 如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以**<em>分布在计算机网络中的其他节点上这就是所谓的分片**</em>。 </li></ul><ul><li> Mongo 支持丰富的查询表达式。查询指令使用 JSON 形式的标记，可轻易查询文档中内嵌的对象及数组。</li></ul><ul><li> MongoDb 使用 <strong><em>update()命令可以实现替换完成的文档</em></strong>（数据）或者一些指定的数据字段 。 </li></ul><ul><li> Mongodb 中的 Map/reduce 主要是用来对数据进行批量处理和聚合操作。</li></ul><ul><li> Map 和 Reduce。Map 函数调用 emit(key,value)遍历集合中所有的记录，将 key 与 value 传 给 Reduce 函数进行处理。</li></ul><ul><li> Map 函数和 Reduce 函数是使用 Javascript 编写的，并可以通过 db.runCommand 或 mapreduce 命令来执行 MapReduce 操作。</li></ul><ul><li> <strong><em>GridFS 是 MongoDB 中的一个内置功能，可以用于存放大量小文件</em></strong>。 </li></ul><ul><li> MongoDB 允许在服务端执行脚本，**<em>可以用 Javascript 编写某个函数，直接在服务端执行**</em>，也可以把函数的定义存储在服务端，下次直接调用即可。</li></ul><h2 id="16-Cassandra"><a href="#16-Cassandra" class="headerlink" title="16. Cassandra"></a><strong>16. Cassandra</strong></h2><h4 id="16-1-1-概念"><a href="#16-1-1-概念" class="headerlink" title="16.1.1 概念"></a>16.1.1 概念</h4><p>Apache Cassandra 是高度可扩展的，高性能的分布式 NoSQL 数据库。 Cassandra 旨在处理许多商品服务器上的大量数据，提供高可用性而无需担心单点故障。</p><p>Cassandra 具有能够处理大量数据的分布式架构。 数据放置在具有多个复制因子的不同机器上，以获得高可用性，而无需担心单点故障。</p><h4 id="16-1-2-数据模型"><a href="#16-1-2-数据模型" class="headerlink" title="16.1.2 数据模型"></a>16.1.2 数据模型</h4><p><strong><em>Key Space（对应 SQL 数据库中的 database）</em></strong></p><ol><li>一个 Key Space 中可包含若干个 CF，如同 SQL 数据库中一个 database 可包含多个 table</li></ol><p><strong><em>Key（对应 SQL 数据库中的主键）</em></strong></p><ol start="2"><li>在 Cassandra 中，每一行数据记录是以 key/value 的形式存储的，其中 key 是唯一标识。</li></ol><p><strong><em>column（对应 SQL 数据库中的列）</em></strong></p><ol start="3"><li>Cassandra 中每个 <strong><em>key/value 对中的 value 又称为 column</em></strong>，它是一个三元组，即：name，value 和 timestamp，其中 name 需要是唯一的。</li></ol><p><strong><em>super column（SQL 数据库不支持）</em></strong></p><ol start="4"><li>cassandra 允许 key/value 中的 <strong><em>value 是一个 map(key/value_list)</em></strong>，即某个 column 有多个子列。</li></ol><p><strong><em>Standard Column Family（相对应 SQL 数据库中的 table）</em></strong></p><ol start="5"><li><strong><em>每个 CF 由一系列 row 组成，每个 row 包含一个 key 以及其对应的若干 column</em></strong>。</li></ol><p><strong><em>Super Column Family（SQL 数据库不支持）</em></strong></p><ol start="6"><li><strong><em>每个 SCF 由一系列 row 组成</em></strong>，每个 row 包含一个 key 以及其对应的若干 super column。</li></ol><h4 id="16-1-3-Cassandra-一致-Hash-和虚拟节点"><a href="#16-1-3-Cassandra-一致-Hash-和虚拟节点" class="headerlink" title="16.1.3 Cassandra 一致 Hash 和虚拟节点"></a>16.1.3 Cassandra 一致 Hash 和虚拟节点</h4><p><strong><em>一致性 Hash（多米诺 down 机）</em></strong></p><p>为每个节点分配一个 token，根据这个 token 值来决定节点在集群中的位置以及这个节点所存储的数据范围。</p><p><strong><em>虚拟节点（down 机多节点托管）</em></strong></p><p>由于这种方式会造成数据分布不均的问题，**<em>在 Cassandra1.2 以后采用了虚拟节点的思想：不需要为每个节点分配 token，把圆环分成更多部分，让每个节点负责多个部分的数据，这样一个节点移除后，它所负责的多个 token 会托管给多个节点处理，这种思想解决了数据分布不均的问题**</em>。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/VirtualNode.png"></p><p>如图所示，**<em>上面部分是标准一致性哈希**</em>，每个节点负责圆环中连续的一段，如果 Node2 突然down 掉，Node2 负责的数据托管给 Node1，即 Node1 负责 EFAB 四段，如果 Node1 里面有很多热点用户产生的数据导致 Node1 已经有点撑不住了，恰巧 B 也是热点用户产生的数据，这样一来 Node1 可能会接着 down 机，Node1down 机，Node6 还 hold 住吗？</p><p><strong><em>下面部分是虚拟节点实现，每个节点不再负责连续部分，且圆环被分为更多的部分。如果 Node2突然 down 掉，Node2 负责的数据不全是托管给 Node1，而是托管给多个节点。而且也保持了一致性哈希的特点</em></strong>。</p><h4 id="16-1-4-Gossip-协议"><a href="#16-1-4-Gossip-协议" class="headerlink" title="16.1.4 Gossip 协议"></a>16.1.4 Gossip 协议</h4><p>Gossip 算法如其名，灵感来自办公室八卦，只要一个人八卦一下，在有限的时间内所有的人都会知道该八卦的信息，这种方式也与病毒传播类似，因此 Gossip 有众多的别名“闲话算法”、 “疫情传播算法”、“病毒感染算法”、“谣言传播算法”。 Gossip 的特点：在一个有界网络中，每个节点都随机地与其他节点通信，经过一番杂乱无章的通信，最终所有节点的状态都会达成一致。因为 Gossip 不要求节点知道所有其他节点，**<em>因此又具有去中心化的特点**</em>，节点之间完全对等，不需要任何的中心节点。实际上 Gossip 可以用于众多能接受“最终一致性”的领域：失败检测、路由同步、Pub/Sub、动态负载均衡。</p><p><strong><em>Gossip 节点的通信方式及收敛性</em></strong></p><p><strong><em>Gossip 两个节点（A、B）之间存在三种通信方式（push、pull、push&amp;pull）</em></strong></p><ol><li><p>push: <strong><em>A 节点将数据(key,value,version)及对应的版本号推送给 B 节点，B 节点更新 A 中比自己新的数据</em></strong>。</p></li><li><p>pull：A 仅将数据 key,version 推送给 B，B 将本地比 A 新的数据（Key,value,version）推送给 A，A 更新本地。</p></li><li><p>push/pull：与 pull 类似，只是多了一步，A 再将本地比 B 新的数据推送给 B，B 更新本地。如果把两个节点数据同步一次定义为一个周期，则在一个周期内，push 需通信 1 次，pull 需 2 次，push/pull 则需 3 次，从效果上来讲，push/pull 最好，理论上一个周期内可以使两个节点完全一致。直观上也感觉，push/pull 的收敛速度是最快的。</p></li></ol><p><strong><em>gossip 的协议和 seed list（防止集群分列）</em></strong></p><p>cassandra 使用称为 gossip 的协议来发现加入 C 集群中的其他节点的位置和状态信息。*<strong>gossip 进程每秒都在进行，并与至多三个节点交换状态信息**<em>。节点交换他们自己和所知道的信息，于是所有的节点很快就能学习到整个集群中的其他节点的信息。gossip 信息有一个相关的版本号，于是在一次 gossip 信息交换中，旧的信息会被新的信息覆盖重写。要阻止分区进行 gossip 交流，那么在集群中的所有节点中使用相同的 seed list，</em></strong>种子节点的指定除了启动起 gossip 进程外，没有其他的目的***。种子节点不是一个单点故障，他们在集群操作中也没有其他的特殊目的，除了引导节点以外</p><h4 id="16-1-5-数据复制"><a href="#16-1-5-数据复制" class="headerlink" title="16.1.5 数据复制"></a>16.1.5 数据复制</h4><p><strong><em>Partitioners（计算 primary key token 的 hash 函数）</em></strong> </p><p>在 Cassandra 中，table 的每行由唯一的 primarykey 标识，**<em>partitioner 实际上为一 hash 函数用以计算 primary key 的 token**</em>。Cassandra 依据这个 token 值在集群中放置对应的行</p><p><strong><em>两种可用的复制策略：</em></strong></p><p><strong><em>SimpleStrategy：仅用于单数据中心</em></strong></p><p>将第一个 replica 放在由 partitioner 确定的节点中，其余的 replicas 放在上述节点顺时针方向的后续节点中。</p><p><strong><em>NetworkTopologyStrategy：可用于较复杂的多数据中心。</em></strong></p><p>可以指定在每个数据中心分别存储多少份 replicas。</p><p>复制策略在创建 keyspace 时指定，如</p><pre class="line-numbers language-none"><code class="language-none">CREATE KEYSPACE Excelsior WITH REPLICATION = { 'class' : 'SimpleStrategy','replication_factor' : 3 }; CREATE KEYSPACE Excalibur WITH REPLICATION = {'class' :'NetworkTopologyStrategy', 'dc1' : 3, 'dc2' : 2};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="16-1-6-数据写请求和协调者"><a href="#16-1-6-数据写请求和协调者" class="headerlink" title="16.1.6  数据写请求和协调者"></a>16.1.6  数据写请求和协调者</h4><p><strong><em>协调者(coordinator)</em></strong></p><p><strong><em>协调者(coordinator)将 write 请求发送到拥有对应 row 的所有 replica 节点</em></strong>，只要节点可用便获取并执行写请求。**<em>写一致性级别(write consistency level)确定要有多少个 replica 节点必须返回成功的确认信息。成功意味着数据被正确写入了 commit log 和 memtable**</em>。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/Coordinator.png"></p><p>其中 dc1、dc2 这些数据中心名称要与 snitch 中配置的名称一致.上面的拓扑策略表示在 dc1 配置3 个副本,在 dc2 配置 2 个副本。</p><h4 id="16-1-7-数据读请求和后台修复"><a href="#16-1-7-数据读请求和后台修复" class="headerlink" title="16.1.7 数据读请求和后台修复"></a>16.1.7 数据读请求和后台修复</h4><ol><li><p>协调者首先与一致性级别确定的所有 replica 联系，**<em>被联系的节点返回请求的数据**</em>。</p></li><li><p>若多个节点被联系，*<strong>则来自各 replica 的 row 会在内存中作比较，若不一致，则协调者使用含最新数据的 replica 向 client 返回结果**<em>。那么比较操作过程中</em></strong>只需要传递时间戳就可以,因为要比较的只是哪个副本数据是最新的***。</p></li><li><p><strong><em>协调者在后台联系和比较来自其余拥有对应 row 的 replica 的数据，若不一致，会向过时的replica 发写请求用最新的数据进行更新 read repair</em></strong>。</p></li></ol><h4 id="16-1-8-数据存储（CommitLog、MemTable、SSTable）"><a href="#16-1-8-数据存储（CommitLog、MemTable、SSTable）" class="headerlink" title="16.1.8 数据存储（CommitLog、MemTable、SSTable）"></a>16.1.8 数据存储（CommitLog、MemTable、SSTable）</h4><p>写请求分别到 CommitLog 和 MemTable, 并且 MemTable 的数据会刷写到磁盘 SSTable 上. 除了写数据,还有索引也会保存到磁盘上.</p><p>先将数据写到磁盘中的 commitlog，同时追加到中内存中的数据结构 memtable 。这个时候就会返回客户端状态 ， memtable 内 容 超 出 指 定 容 量 后 会 被 放 进 将 被 刷 入 磁 盘 的 队 列(memtable_flush_queue_size 配置队列长度)。若将被刷入磁盘的数据超出了队列长度，将内存数据刷进磁盘中的 SSTable,之后 commit log 被清空。</p><p><strong><em>SSTable 文件构成（BloomFilter、index、data、static）</em></strong></p><p>SSTable 文件有 <strong><em>fileer</em></strong>（判断数据 key 是否存在，这里使用了 BloomFilter 提高效率），**<em>index**</em>（寻找对应 column 值所在 data 文件位置）文件，data（存储真实数据）文件，static（存储和统计column 和 row 大小）文件。</p><h4 id="16-1-9-二级索引（对要索引的-value-摘要，生成-RowKey）"><a href="#16-1-9-二级索引（对要索引的-value-摘要，生成-RowKey）" class="headerlink" title="16.1.9 二级索引（对要索引的 value 摘要，生成 RowKey）"></a>16.1.9 二级索引（对要索引的 value 摘要，生成 RowKey）</h4><p>在 Cassandra 中，数据都是以 Key-value 的形式保存的。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/Cassandra.png"></p><p>KeysIndex 所创建的二级索引也被保存在一张 ColumnFamily 中。**<em>在插入数据时，对需要进行索引的 value进行摘要，生成独一无二的key，将其作为 RowKey保存在索引的 ColumnFamily 中**</em>；同时在 RowKey 上添加一个 Column，将插入数据的 RowKey 作为 name 域的值，value 域则赋空值，timestamp 域则赋为插入数据的时间戳。</p><p>如果有相同的 value 被索引了，则会在索引 ColumnFamily 中相同的 RowKey 后再添加新的Column。如果有新的 value 被索引，则会在索引 ColumnFamily 中添加新的 RowKey 以及对新的 Column。</p><p>当对 value 进行查询时，只需计算该 value 的 RowKey，在索引 ColumnFamily 中的查找该RowKey，对其 Columns 进行遍历就能得到该 value 所有数据的 RowKey。</p><h4 id="16-1-10-数据读写"><a href="#16-1-10-数据读写" class="headerlink" title="16.1.10 数据读写"></a>16.1.10 数据读写</h4><p><strong><em>数据写入和更新（数据追加）</em></strong></p><p>Cassandra 的设计思路与这些系统不同，无论是 insert 还是 remove 操作，**<em>都是在已有的数据后面进行追加，而不修改已有的数据**</em>。这种设计称为 Log structured 存储，顾名思义就是系统中的数据是以日志的形式存在的，所以只会将新的数据追加到已有数据的后面。Log structured 存储系统有两个主要优点：</p><p><strong>数据的写和删除效率极高</strong></p><ul><li> 传统的存储系统需要更新元信息和数据，**<em>因此磁盘的磁头需要反复移动**</em>，这是一个比较耗时的操作，而 Log structured 的系统则是顺序写，可以充分利用文件系统的 cache，所以效率很高。</li></ul><p><strong><em>错误恢复简单</em></strong></p><ul><li> 由于数据本身就是以日志形式保存，老的数据不会被覆盖，所以在设计 journal 的时候不需要考虑 undo，简化了错误恢复。</li></ul><p><strong><em>读的复杂度高</em></strong></p><ul><li> 但是，Log structured 的存储系统也引入了一个重要的问题：读的复杂度和性能。**<em>理论上说，读操作需要从后往前扫描数据，以找到某个记录的最新版本**</em>。相比传统的存储系统，这是比较耗时的。</li></ul><p>参考：<a href="https://blog.csdn.net/fs1360472174/article/details/55005335">https://blog.csdn.net/fs1360472174/article/details/55005335</a></p><p><strong><em>数据删除（column 的墓碑）</em></strong></p><p>如果一次删除操作在一个节点上失败了（总共 3 个节点，副本为 3， RF=3).整个删除操作仍然被认为成功的（因为有两个节点应答成功，使用 CL.QUORUM 一致性）。接下来如果读发生在该节点上就会变的不明确，因为结果返回是空，还是返回数据，没有办法确定哪一种是正确的。</p><p>Cassandra 总是认为返回数据是对的，那就会发生删除的数据又出现了的事情，这些数据可以叫”僵尸”，并且他们的表现是不可预见的。</p><p><strong><em>墓碑</em></strong></p><p><strong><em>删除一个 column 其实只是插入一个关于这个 column 的墓（tombstone），并不直接删除原有的 column</em></strong>。该墓碑被作为对该 CF 的一次修改记录在 Memtable 和 SSTable 中。墓碑的内容是删除请求被执行的时间，该时间是接受客户端请求的存储节点在执行该请求时的本地时间（local delete time），称为本地删除时间。需要注意区分本地删除时间和时间戳，每个 CF 修改记录都有一个时间戳，这个时间戳可以理解为该 column 的修改时间，是由客户端给定的。</p><p><strong><em>垃圾回收 compaction</em></strong></p><p>由于被删除的 column 并不会立即被从磁盘中删除，所以系统占用的磁盘空间会越来越大，这就需要有一种垃圾回收的机制，定期删除被标记了墓碑的 column。垃圾回收是在 compaction 的过程中完成的。</p><p><strong><em>数据读取（memtable+SStables）</em></strong> </p><p>为了满足读 cassandra 读取的数据是 <strong><em>memtable 中的数据和 SStables 中数据的合并结果</em></strong>。读取SSTables 中的数据就是查找到具体的哪些的 SSTables 以及数据在这些 SSTables 中的偏移量(SSTables 是按主键排序后的数据块)。首先如果 <strong><em>row cache enable</em></strong> 了话，会检测缓存。缓存命中直接返回数据，没有则查找 <strong><em>Bloom filter</em></strong>，查找可能的 SSTable。然后有一层 <strong><em>Partition key cache</em></strong>， 找 partition key 的位置。如果有根据找到的 partition 去压缩偏移量映射表找具体的数据块。如果缓存没有，则要经过 <strong><em>Partition summary,Partition index</em></strong> 去找 partition key。然后经过压缩偏移量映射表找具体的数据块。</p><ol><li><p>检查 memtable</p></li><li><p>如果 enabled 了,检查 row cache</p></li><li><p>检查 Bloom filter</p></li><li><p>如果 enable 了,检查 partition key 缓存</p></li><li><p>如果在 partition key 缓存中找到了 partition key,直接去 compression offset 命中，如果没有，检查 partition summary</p></li><li><p>根据 compression offset map 找到数据位置</p></li><li><p>从磁盘的 SSTable 中取出数据</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/MemtableSStables.png"></p></li></ol><p><strong><em>行缓存和键缓存请求流程图</em></strong></p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/FlowChartOfRowCacheAndKeyCacheRequest.png"></p><p><strong>MemTable：</strong>如果 memtable 有目标分区数据，这个数据会被读出来并且和从 SSTables 中读出来的数据进行合并。SSTable 的数据访问如下面所示的步骤。</p><p><strong><em>Row Cache（SSTables 中频繁被访问的数据）</em></strong> </p><p><strong><em>在 Cassandra2.2+，它们被存储在堆外内存，使用全新的实现避免造成垃圾回收对 JVM 造成压力</em></strong>。存在在 row cache 的子集数据可以在特定的一段时间内配置一定大小的内存。row cache 使用LRU(least-recently-userd)进行回收在申请内存。*<strong>存储在 row cache 中的数据是 SSTables 中频繁被访问的数据**<em>。存储到row cache中后，数据就可以被后续的查询访问。</em></strong>row cache不是写更新。如果写某行了，这行的缓存就会失效，并且不会被继续缓存，直到这行被读到。类似的，如果一个partition更新了，整个partition的cache都会被移除，但目标的数据在row cache中找不到，就会去检查 Bloom filter***。</p><p><strong><em>Bloom Filter（查找数据可能对应的 SSTable）</em></strong></p><p>首先，Cassandra 检查 Bloom filter 去发现哪个 SSTables 中有可能有请求的分区数据。*<strong>Bloom filter 是存储在堆外内存。每个 SSTable 都有一个关联的 Bloom filter**<em>。一个 Bloom filter 可以立一个 SSTable 没有包含的特定的分区数据。同样也可以找到分区数据存在 SSTable 中的可能性。它可以加速查找 partition key 的查找过程。然而，因为 Bloom filter 是一个概率函数，所以可能会得到错误的结果，并不是所有的 SSTables 都可以被 Bloom filter 识别出是否有数据。</em></strong>如果Bloom filter 不能够查找到 SSTable，Cassandra 会检查 partition key cache***。Bloom filter 大小增长很适宜，每 10 亿数据 1~2GB。在极端情况下，可以一个分区一行。都可以很轻松的将数十亿的 entries 存储在单个机器上。Bloom filter 是可以调节的，如果你愿意用内存来换取性能。</p><p><strong><em>Partition Key Cache（查找数据可能对应的 Partition key）</em></strong></p><p>partition key 缓存如果开启了，将 partition index 存储在堆外内存。key cache 使用一小块可配置大小的内存。在读的过程中，*<strong>每个”hit”保存一个检索。如果在 key cache 中找到了 partition key。就直接到 compression offset map 中招对应的块**<em>。partition key cache 热启动后工作的更好，相比较冷启动，有很大的性能提升。如果一个节点上的内存非常受限制，可能的话，需要限制保存在 key cache 中的 partition key 数目。</em></strong>如果一个在 key cache 中没有找到 partition key。就会去partition summary中去找***。partition key cache 大小是可以配置的，意义就是存储在key cache 中的 partition keys 数目。</p><p><strong><em>Partition Summary（内存中存储一些 partition index 的样本）</em></strong></p><p>partition summary 是存储在堆外内存的结构，**<em>存储一些 partition index 的样本**</em>。如果一个partition index 包含所有的 partition keys。鉴于一个 partition summary 从每 X 个 keys 中取样，然后将每 X 个 key map 到 index 文件中。例如，如果一个 partition summary 设置了 20keys进行取样。它就会存储 SSTable file 开始的一个 key,20th 个 key，以此类推。尽管并不知道partition key 的具体位置，partition summary 可以缩短找到 partition 数据位置。当找到了partition key 值可能的范围后，就会去找 partition index。通过配置取样频率，你可以用内存来换取性能，当 partition summary 包含的数据越多，使用的内存越多。可以通过表定义的 index interval 属性来改变样本频率。固定大小的内存可以通过 index_summary_capacity_in_mb 属性来设置，默认是堆大小的 5%。</p><p><strong><em>Partition Index（磁盘中）</em></strong></p><p>partition index 驻扎在磁盘中，索引所有 partition keys 和偏移量的映射。如果 partition summary 已经查到 partition keys 的范围，现在的检索就是根据这个范围值来检索目标 partition key。需要进行单次检索和顺序读。根据找到的信息。然后去 compression offset map 中去找磁盘中有这个数据的块。如果 partition index 必须要被检索，则需要检索两次磁盘去找到目标数据。</p><p><strong><em>Compression offset map（磁盘中）</em></strong></p><p><strong><em>compression offset map 存储磁盘数据准确位置的指针</em></strong>。存储在堆外内存，可以被 partition key cache 或者 partition index 访问。一旦 compression offset map 识别出来磁盘中的数据位置，就会从正确的 SStable(s)中取出数据。查询就会收到结果集。</p><h2 id="17-设计模式"><a href="#17-设计模式" class="headerlink" title="17. 设计模式"></a><strong>17. 设计模式</strong></h2><h4 id="17-1-1-设计原则"><a href="#17-1-1-设计原则" class="headerlink" title="17.1.1 设计原则"></a>17.1.1 设计原则</h4><h4 id="17-1-2-工厂方法模式"><a href="#17-1-2-工厂方法模式" class="headerlink" title="17.1.2 工厂方法模式"></a>17.1.2 工厂方法模式</h4><h4 id="17-1-3-抽象工厂模式"><a href="#17-1-3-抽象工厂模式" class="headerlink" title="17.1.3 抽象工厂模式"></a>17.1.3 抽象工厂模式</h4><h4 id="17-1-4-单例模式"><a href="#17-1-4-单例模式" class="headerlink" title="17.1.4 单例模式"></a>17.1.4 单例模式</h4><h4 id="17-1-5-建造者模式"><a href="#17-1-5-建造者模式" class="headerlink" title="17.1.5 建造者模式"></a>17.1.5 建造者模式</h4><h4 id="17-1-6-原型模式"><a href="#17-1-6-原型模式" class="headerlink" title="17.1.6 原型模式"></a>17.1.6 原型模式</h4><h4 id="17-1-7-适配器模"><a href="#17-1-7-适配器模" class="headerlink" title="17.1.7 适配器模"></a>17.1.7 适配器模</h4><h4 id="17-1-8-装饰器模式"><a href="#17-1-8-装饰器模式" class="headerlink" title="17.1.8 装饰器模式"></a>17.1.8 装饰器模式</h4><h4 id="17-1-9-代理模式"><a href="#17-1-9-代理模式" class="headerlink" title="17.1.9 代理模式"></a>17.1.9 代理模式</h4><h4 id="17-1-10-外观模式"><a href="#17-1-10-外观模式" class="headerlink" title="17.1.10 外观模式"></a>17.1.10 外观模式</h4><h4 id="17-1-11-桥接模式"><a href="#17-1-11-桥接模式" class="headerlink" title="17.1.11 桥接模式"></a>17.1.11 桥接模式</h4><h4 id="17-1-12-组合模式"><a href="#17-1-12-组合模式" class="headerlink" title="17.1.12 组合模式"></a>17.1.12 组合模式</h4><h4 id="17-1-13-享元模式"><a href="#17-1-13-享元模式" class="headerlink" title="17.1.13 享元模式"></a>17.1.13 享元模式</h4><h4 id="17-1-14-策略模式"><a href="#17-1-14-策略模式" class="headerlink" title="17.1.14 策略模式"></a>17.1.14 策略模式</h4><h4 id="17-1-15-模板方法模式"><a href="#17-1-15-模板方法模式" class="headerlink" title="17.1.15 模板方法模式"></a>17.1.15 模板方法模式</h4><h4 id="17-1-16-观察者模式"><a href="#17-1-16-观察者模式" class="headerlink" title="17.1.16 观察者模式"></a>17.1.16 观察者模式</h4><h4 id="17-1-17-迭代子模式"><a href="#17-1-17-迭代子模式" class="headerlink" title="17.1.17 迭代子模式"></a>17.1.17 迭代子模式</h4><h4 id="17-1-18-责任链模式"><a href="#17-1-18-责任链模式" class="headerlink" title="17.1.18 责任链模式"></a>17.1.18 责任链模式</h4><h4 id="17-1-19-命令模式"><a href="#17-1-19-命令模式" class="headerlink" title="17.1.19 命令模式"></a>17.1.19 命令模式</h4><h4 id="17-1-20-备忘录模式"><a href="#17-1-20-备忘录模式" class="headerlink" title="17.1.20 备忘录模式"></a>17.1.20 备忘录模式</h4><h4 id="17-1-21-状态模式"><a href="#17-1-21-状态模式" class="headerlink" title="17.1.21 状态模式"></a>17.1.21 状态模式</h4><h4 id="17-1-22-访问者模式"><a href="#17-1-22-访问者模式" class="headerlink" title="17.1.22 访问者模式"></a>17.1.22 访问者模式</h4><h4 id="17-1-23-中介者模式"><a href="#17-1-23-中介者模式" class="headerlink" title="17.1.23 中介者模式"></a>17.1.23 中介者模式</h4><h4 id="17-1-24-解释器模式"><a href="#17-1-24-解释器模式" class="headerlink" title="17.1.24 解释器模式"></a>17.1.24 解释器模式</h4><h2 id="18-负载均衡"><a href="#18-负载均衡" class="headerlink" title="18. 负载均衡"></a><strong>18. 负载均衡</strong></h2><p>负载均衡 建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。</p><h4 id="18-1-1-四层负载均衡-vs-七层负载均衡"><a href="#18-1-1-四层负载均衡-vs-七层负载均衡" class="headerlink" title="18.1.1 四层负载均衡 vs 七层负载均衡"></a>18.1.1 四层负载均衡 vs 七层负载均衡</h4><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/LoadBalancingVS.png"></p><h5 id="18-1-1-1-四层负载均衡（目标地址和端口交换）"><a href="#18-1-1-1-四层负载均衡（目标地址和端口交换）" class="headerlink" title="18.1.1.1 四层负载均衡（目标地址和端口交换）"></a>18.1.1.1 四层负载均衡（目标地址和端口交换）</h5><p>主要通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。</p><p>以常见的 TCP 为例，*<strong>负载均衡设备在接收到第一个来自客户端的 SYN 请求时，即通过上述方式选择一个最佳的服务器，并对报文中目标 IP 地址进行修改(改为后端服务器 IP），直接转发给该服务器**<em>。TCP 的连接建立，</em></strong>即三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类似路由器的转发动作***。在某些部署情况下，为保证服务器回包可以正确返回给负载均衡设备，在转发报文的同时可能还会对报文原来的源地址进行修改。实现四层负载均衡的软件有：</p><p><strong><em>F5：硬件负载均衡器，功能很好，但是成本很高。</em></strong></p><p><strong><em>lvs：重量级的四层负载软件。</em></strong></p><p><strong><em>nginx：轻量级的四层负载软件，带缓存功能，正则表达式较灵活。</em></strong></p><p><strong><em>haproxy：模拟四层转发，较灵活。</em></strong></p><h5 id="18-1-1-2-七层负载均衡（内容交换）"><a href="#18-1-1-2-七层负载均衡（内容交换）" class="headerlink" title="18.1.1.2 七层负载均衡（内容交换）"></a>18.1.1.2 七层负载均衡（内容交换）</h5><p>所谓七层负载均衡，也**<em>称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器**</em>。</p><p>七层应用负载的好处，是使得整个网络更智能化。例如访问一个网站的用户流量，**<em>可以通过七层的方式，将对图片类的请求转发到特定的图片服务器并可以使用缓存技术；将对文字类的请求可以转发到特定的文字服务器并可以使用压缩技术**</em>。实现七层负载均衡的软件有：</p><p><strong><em>haproxy：天生负载均衡技能，全面支持七层代理，会话保持，标记，路径转移；</em></strong></p><p><strong><em>nginx：只在 http 协议和 mail 协议上功能比较好，性能与 haproxy 差不多；</em></strong></p><p><strong><em>apache：功能较差</em></strong></p><p><strong><em>Mysql proxy：功能尚可。</em></strong></p><h4 id="18-1-2-负载均衡算法-策略"><a href="#18-1-2-负载均衡算法-策略" class="headerlink" title="18.1.2 负载均衡算法/策略"></a>18.1.2 负载均衡算法/策略</h4><h5 id="18-1-2-1-轮循均衡（Round-Robin）"><a href="#18-1-2-1-轮循均衡（Round-Robin）" class="headerlink" title="18.1.2.1 轮循均衡（Round Robin）"></a>18.1.2.1 轮循均衡（Round Robin）</h5><p>每一次来自网络的**<em>请求轮流分配给内部中的服务器**</em>，从 1 至 N 然后重新开始。此种均衡算法适合于服务器组中的所有服务器都有相同的软硬件配置并且平均服务请求相对均衡的情况。</p><h5 id="18-1-2-2-权重轮循均衡（Weighted-Round-Robin）"><a href="#18-1-2-2-权重轮循均衡（Weighted-Round-Robin）" class="headerlink" title="18.1.2.2 权重轮循均衡（Weighted Round Robin）"></a>18.1.2.2 权重轮循均衡（Weighted Round Robin）</h5><p>根据*<strong>服务器的不同处理能力，给每个服务器分配不同的权值**<em>，使其能够接受相应权值数的服务请求。例如：服务器 A 的权值被设计成 1，B 的权值是 3，C 的权值是 6，则</em></strong>服务器 A、B、C 将分别接受到 10%、30％、60％的服务请求***。此种均衡算法能确保高性能的服务器得到更多的使用率，避免低性能的服务器负载过重。</p><h5 id="18-1-2-3-随机均衡（Random）"><a href="#18-1-2-3-随机均衡（Random）" class="headerlink" title="18.1.2.3 随机均衡（Random）"></a>18.1.2.3 随机均衡（Random）</h5><p>把来自网络的请求随机分配给内部中的多个服务器。</p><h5 id="18-1-2-4-权重随机均衡（Weighted-Random）"><a href="#18-1-2-4-权重随机均衡（Weighted-Random）" class="headerlink" title="18.1.2.4. 权重随机均衡（Weighted Random）"></a>18.1.2.4. 权重随机均衡（Weighted Random）</h5><p>此种均衡算法类似于权重轮循算法，不过在处理请求分担时是个随机选择的过程。</p><h5 id="18-1-2-5-响应速度均衡（Response-Time-探测时间）"><a href="#18-1-2-5-响应速度均衡（Response-Time-探测时间）" class="headerlink" title="18.1.2.5 响应速度均衡（Response Time 探测时间）"></a>18.1.2.5 响应速度均衡（Response Time 探测时间）</h5><p><strong><em>负载均衡设备对内部各服务器发出一个探测请求（例如 Ping），然后根据内部中各服务器对探测请求的最快响应时间来决定哪一台服务器来响应客户端的服务请求</em></strong>。此种均衡算法能较好的反映服务器的当前运行状态，但这最快响应时间仅仅指的是负载均衡设备与服务器间的最快响应时间，而不是客户端与服务器间的最快响应时间。</p><h5 id="18-1-2-6-最少连接数均衡（Least-Connection）"><a href="#18-1-2-6-最少连接数均衡（Least-Connection）" class="headerlink" title="18.1.2.6 最少连接数均衡（Least Connection）"></a>18.1.2.6 最少连接数均衡（Least Connection）</h5><p>最少连接数均衡算法对内部中需负载的每一台服务器都有一个数据记录，记录当前该服务器正在处理的连接数量，当有新的服务连接请求时，将把当前请求分配给连接数最少的服务器，使均衡更加符合实际情况，负载更加均衡。此种均衡算法适合长时处理的请求服务，如 FTP。</p><h5 id="18-1-2-7-处理能力均衡（CPU、内存）"><a href="#18-1-2-7-处理能力均衡（CPU、内存）" class="headerlink" title="18.1.2.7 处理能力均衡（CPU、内存）"></a>18.1.2.7 处理能力均衡（CPU、内存）</h5><p>此种均衡算法将把服务请求分配给**<em>内部中处理负荷（根据服务器 CPU 型号、CPU 数量、内存大小及当前连接数等换算而成）最轻的服务器，由于考虑到了内部服务器的处理能力及当前网络运行状况，所以此种均衡算法相对来说更加精确**</em>，尤其适合运用到第七层（应用层）负载均衡的情况下。</p><h5 id="18-1-2-8-DNS-响应均衡（Flash-DNS）"><a href="#18-1-2-8-DNS-响应均衡（Flash-DNS）" class="headerlink" title="18.1.2.8 DNS 响应均衡（Flash DNS）"></a>18.1.2.8 DNS 响应均衡（Flash DNS）</h5><p>在此均衡算法下，分处在不同地理位置的负载均衡设备收到同一个客户端的域名解析请求，并在同一时间内把此域名解析成各自相对应服务器的 IP 地址并返回给客户端，**<em>则客户端将以最先收到的域名解析 IP 地址来继续请求服务，而忽略其它的 IP 地址响应**</em>。在种均衡策略适合应用在全局负载均衡的情况下，对本地负载均衡是没有意义的。</p><h5 id="18-1-2-9-哈希算法"><a href="#18-1-2-9-哈希算法" class="headerlink" title="18.1.2.9 哈希算法"></a>18.1.2.9 哈希算法</h5><p>一致性哈希一致性 Hash，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</p><h5 id="18-1-2-10-IP-地址散列（保证客户端服务器对应关系稳定）"><a href="#18-1-2-10-IP-地址散列（保证客户端服务器对应关系稳定）" class="headerlink" title="18.1.2.10 IP 地址散列（保证客户端服务器对应关系稳定）"></a>18.1.2.10 IP 地址散列（保证客户端服务器对应关系稳定）</h5><p>通过管理发送方 IP 和目的地 IP 地址的散列，将来自同一发送方的分组(或发送至同一目的地的分组)统一转发到相同服务器的算法。当客户端有一系列业务需要处理而必须和一个服务器反复通信时，该算法能够以流(会话)为单位，**<em>保证来自相同客户端的通信能够一直在同一服务器中进行处理**</em>。</p><h5 id="18-1-2-11-URL-散列"><a href="#18-1-2-11-URL-散列" class="headerlink" title="18.1.2.11 URL 散列"></a>18.1.2.11 URL 散列</h5><p>通过管理客户端请求 URL 信息的散列，将发送至相同 URL 的请求转发至同一服务器的算法。</p><h4 id="18-1-3-LVS"><a href="#18-1-3-LVS" class="headerlink" title="18.1.3 LVS"></a>18.1.3 LVS</h4><h5 id="18-1-3-1-LVS-原理"><a href="#18-1-3-1-LVS-原理" class="headerlink" title="18.1.3.1 LVS 原理"></a>18.1.3.1 LVS 原理</h5><p><strong><em>IPVS</em></strong></p><p>LVS 的 IP 负载均衡技术是通过 IPVS 模块来实现的，IPVS 是 LVS 集群系统的核心软件，它的主要作用是：安装在 Director Server 上，同时在 Director Server 上虚拟出一个 IP 地址，用户必须通过这个虚拟的 IP 地址访问服务器。这个虚拟 IP 一般称为 LVS 的 VIP，即 Virtual IP。访问的请求首先经过 VIP 到达负载调度器，然后由负载调度器从 Real Server 列表中选取一个服务节点响应用户的请求。 在用户的请求到达负载调度器后，调度器如何将请求发送到提供服务的 Real Server 节点，而 Real Server 节点如何返回数据给用户，是 IPVS 实现的重点技术。</p><p>ipvs ： 工作于内核空间，主要用于使用户定义的策略生效</p><p>ipvsadm : 工作于用户空间，主要用于用户定义和管理集群服务的工具</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/DirectorServer.png"></p><p><strong><em>ipvs 工作于内核空间的 INPUT 链上</em></strong>，当收到用户请求某集群服务时，经过 PREROUTING 链，经检查本机路由表，送往 INPUT 链；在进入 netfilter 的 INPUT 链时，ipvs 强行将请求报文通过ipvsadm 定义的集群服务策略的路径改为 FORWORD 链，将报文转发至后端真实提供服务的主机。</p><h5 id="18-1-3-2-LVS-NAT-模式"><a href="#18-1-3-2-LVS-NAT-模式" class="headerlink" title="18.1.3.2 LVS NAT 模式"></a>18.1.3.2 LVS NAT 模式</h5><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/LVS-NATMode.png"></p><p>①.客户端将请求发往前端的负载均衡器，请求报文源地址是 CIP(客户端 IP),后面统称为 CIP)，目标地址为 VIP(负载均衡器前端地址，后面统称为 VIP)。 </p><p>②.负载均衡器收到报文后，发现请求的是在规则里面存在的地址，那么它将**<em>客户端请求报文的目标地址改为了后端服务器的 RIP 地址并将报文根据算法发送出去**</em>。 </p><p>③.报文送到 Real Server 后，由于报文的目标地址是自己，所以会响应该请求，**<em>并将响应报文返还给 LVS**</em>。 </p><p>④.然后 lvs 将此报文的源地址修改为本机并发送给客户端。</p><p>注意：在 NAT 模式中，**<em>Real Server 的网关必须指向 LVS**</em>，否则报文无法送达客户端</p><p><strong><em>特点：</em></strong></p><p>1、NAT 技术将请求的报文和响应的报文都需要通过 LB 进行地址改写，因此网站访问量比较大的时候 LB 负载均衡调度器有比较大的瓶颈，一般要求最多之能 10-20 台节点。</p><p>2、**<em>只需要在 LB 上配置一个公网 IP 地址就可以了**</em>。 </p><p>3、每台内部的 realserver 服务器的网关地址必须是调度器 LB 的内网地址。</p><p>4、NAT 模式支持对 IP 地址和端口进行转换。**<em>即用户请求的端口和真实服务器的端口可以不一致**</em>。</p><p><strong><em>优点：</em></strong></p><p>集群中的物理服务器可以使用任何支持 TCP/IP 操作系统，只有负载均衡器需要一个合法的 IP 地址。</p><p><strong><em>缺点：</em></strong></p><p>扩展性有限。当服务器节点（普通 PC 服务器）增长过多时,负载均衡器将成为整个系统的瓶颈，因为所有的请求包和应答包的流向都经过负载均衡器。当服务器节点过多时，大量的数据包都交汇在负载均衡器那，速度就会变慢！</p><h5 id="18-1-3-3-LVS-DR-模式（局域网改写-mac-地址）"><a href="#18-1-3-3-LVS-DR-模式（局域网改写-mac-地址）" class="headerlink" title="18.1.3.3 LVS DR 模式（局域网改写 mac 地址）"></a>18.1.3.3 LVS DR 模式（局域网改写 mac 地址）</h5><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/LVS-DRMode.png"></p><p>①.客户端将请求发往前端的负载均衡器，请求报文源地址是 CIP，目标地址为 VIP。 </p><p>②.负载均衡器收到报文后，发现请求的是在规则里面存在的地址，那么它**<em>将客户端请求报文的源MAC 地址改为自己 DIP 的 MAC 地址，目标 MAC 改为了 RIP 的 MAC 地址**</em>，并将此包发送给 RS。 </p><p>③.RS 发现请求报文中的目的 MAC 是自己，就会将次报文接收下来，**<em>处理完请求报文后，将响应报文通过 lo 接口送给 eth0 网卡直接发送给客户端**</em>。</p><p>注意：**<em>需要设置 lo 接口的 VIP 不能响应本地网络内的 arp 请求**</em>。</p><p><strong><em>总结：</em></strong></p><p>1、通过在调度器 LB 上**<em>修改数据包的目的 MAC 地址实现转发。注意源地址仍然是 CIP，目的地址仍然是 VIP 地址**</em>。 </p><p>2、**<em>请求的报文经过调度器，而 RS 响应处理后的报文无需经过调度器 LB，因此并发访问量大时使用效率很高**</em>（和 NAT 模式比）</p><p>3、因为 DR 模式是**<em>通过 MAC 地址改写机制实现转发，因此所有 RS 节点和调度器 LB 只能在一个局域网里面**</em></p><p>4、RS 主机需要绑定 VIP 地址在 LO 接口（掩码 32 位）上，并且需要配置 ARP 抑制。</p><p>5、RS 节点的默认网关不需要配置成 LB，而是直接配置为上级路由的网关，能让 RS 直接出网就可以。</p><p>6、由于 DR 模式的调度器仅做 MAC 地址的改写，所以调度器 LB 就不能改写目标端口，那么 RS 服务器就得使用和 VIP <strong><em>相同的端口提供服务</em></strong>。 </p><p>7、直接对外的业务比如 WEB 等，**<em>RS 的 IP 最好是使用公网 IP**</em>。对外的服务，比如数据库等最好</p><p>使用内网 IP。</p><p><strong><em>优点：</em></strong></p><p>和 TUN（隧道模式）一样，负载均衡器也只是分发请求，应答包通过单独的路由方法返回给客户端。与 VS-TUN 相比，**<em>VS-DR 这种实现方式不需要隧道结构**</em>，因此可以使用大多数操作系统做为物理服务器。</p><p>DR 模式的效率很高，但是配置稍微复杂一点，因此对于访问量不是特别大的公司可以用haproxy/nginx取代。日1000-2000W PV或者并发请求1万一下都可以考虑用haproxy/nginx。</p><p><strong><em>缺点：</em></strong></p><p><strong><em>所有 RS 节点和调度器 LB 只能在一个局域网里面</em></strong></p><h5 id="18-1-3-4-LVS-TUN-模式（IP-封装、跨网段）"><a href="#18-1-3-4-LVS-TUN-模式（IP-封装、跨网段）" class="headerlink" title="18.1.3.4 LVS TUN 模式（IP 封装、跨网段）"></a>18.1.3.4 LVS TUN 模式（IP 封装、跨网段）</h5><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/LVS-TUNMode.png"></p><p>①.客户端将请求发往前端的负载均衡器，请求报文源地址是 CIP，目标地址为 VIP。 </p><p>②.负载均衡器收到报文后，发现请求的是在规则里面存在的地址，那么它将**<em>在客户端请求报文的首部再封装一层 IP 报文,将源地址改为 DIP，目标地址改为 RIP**</em>,并将此包发送给 RS。 </p><p>③.RS 收到请求报文后，会首先拆开第一层封装,然后**<em>发现里面还有一层 IP 首部的目标地址是自己 lo 接口上的 VIP**</em>，所以会处理次请求报文，并将响应报文通过 lo 接口送给 eth0 网卡直接发送给客户端。</p><p>注意：需要设置 lo 接口的 VIP 不能在共网上出现。</p><p><strong><em>总结：</em></strong></p><p>1.TUNNEL 模式**<em>必须在所有的 realserver 机器上面绑定 VIP 的 IP 地址**</em></p><p>2.TUNNEL 模式的 vip ——&gt;realserver 的包通信通过 TUNNEL 模式，**<em>不管是内网和外网都能通信，所以不需要 lvs vip 跟 realserver 在同一个网段内**</em>。</p><p>3.TUNNEL 模式 realserver 会把 packet 直接发给 client 不会给 lvs 了。</p><p>4.TUNNEL 模式走的隧道模式，所以运维起来比较难，所以一般不用。</p><p><strong><em>优点：</em></strong></p><p>负载均衡器只负责将请求包分发给后端节点服务器，而 RS 将应答包直接发给用户。所以，减少了负载均衡器的大量数据流动，负载均衡器不再是系统的瓶颈，就能处理很巨大的请求量，这种方式，一台负载均衡器能够为很多 RS 进行分发。而且跑在公网上就能进行不同地域的分发。</p><p><strong><em>缺点：</em></strong></p><p><strong><em>隧道模式的 RS 节点需要合法 IP，这种方式需要所有的服务器支持”IP Tunneling”(IP Encapsulation)协议，服务器可能只局限在部分 Linux 系统上</em></strong>。</p><h5 id="18-1-3-5-LVS-FULLNAT-模式"><a href="#18-1-3-5-LVS-FULLNAT-模式" class="headerlink" title="18.1.3.5 LVS FULLNAT 模式"></a>18.1.3.5 LVS FULLNAT 模式</h5><p>无论是 DR 还是 NAT 模式，不可避免的都有一个问题：LVS 和 RS 必须在同一个 VLAN 下，否则LVS 无法作为 RS 的网关。这引发的两个问题是：</p><p>1、同一个 VLAN 的限制导致运维不方便，跨 VLAN 的 RS 无法接入。</p><p>2、LVS 的水平扩展受到制约。当 RS 水平扩容时，总有一天其上的单点 LVS 会成为瓶颈。**<em>Full-NAT 由此而生，解决的是 LVS 和 RS 跨 VLAN 的问题**</em>，而跨 VLAN 问题解决后，LVS 和 RS 不再存在 VLAN 上的从属关系，可以做到多个 LVS 对应多个 RS，解决水平扩容的问题。Full-NAT 相比 NAT 的主要改进是，在 SNAT/DNAT 的基础上，加上另一种转换，转换过程如下：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/LVS-FULLNATMode.png"></p><ol><li><p>在包从 LVS 转到 RS 的过程中，**<em>源地址从客户端 IP 被替换成了 LVS 的内网 IP**</em>。内网 IP 之间可以通过多个交换机跨 VLAN 通信。目标地址从 VIP 修改为 RS IP.</p></li><li><p>当 RS 处理完接受到的包，处理完成后返回时，将目标地址修改为 LVS ip，原地址修改为 RS IP，**<em>最终将这个包返回给 LVS 的内网 IP**</em>，这一步也不受限于 VLAN。</p></li><li><p>LVS 收到包后，**<em>在 NAT 模式修改源地址的基础上，再把 RS 发来的包中的目标地址从 LVS 内 网 IP 改为客户端的 IP**</em>,并将原地址修改为 VIP。</p></li></ol><p>Full-NAT 主要的思想是把网关和其下机器的通信，改为了普通的网络通信，从而解决了跨 VLAN 的问题。采用这种方式，LVS 和 RS 的部署在 VLAN 上将不再有任何限制，大大提高了运维部署的便利性。</p><p><strong><em>总结</em></strong></p><ol><li><p>FULL NAT 模式不需要 LBIP 和 realserver ip 在同一个网段；</p></li><li><p>full nat 因为要更新 sorce ip 所以性能正常比 nat 模式下降 10%</p></li></ol><h4 id="18-1-4-Keepalive"><a href="#18-1-4-Keepalive" class="headerlink" title="18.1.4 Keepalive"></a>18.1.4 Keepalive</h4><p>keepalive 起初是为 LVS 设计的，专门用来*<strong>监控 lvs 各个服务节点的状态***，后来加入了 vrrp 的功能，因此除了 lvs，也可以作为其他服务（nginx，haproxy）的高可用软件。VRRP 是 virtual router redundancy protocal（虚拟路由器冗余协议）的缩写。VRRP 的出现就是为了解决静态路由出现的单点故障，它能够保证网络可以不间断的稳定的运行。所以 keepalive 一方面具有 LVS cluster node *</strong>healthcheck*** 功能，另一方面也具有 <strong><em>LVS director failover</em></strong>。</p><h4 id="18-1-5-Nginx-反向代理负载均衡"><a href="#18-1-5-Nginx-反向代理负载均衡" class="headerlink" title="18.1.5 Nginx 反向代理负载均衡"></a>18.1.5 Nginx 反向代理负载均衡</h4><p>普通的负载均衡软件，如 LVS，*<strong>其实现的功能只是对请求数据包的转发、传递**<em>，从负载均衡下的节点服务器来看，接收到的请求还是来自访问负载均衡器的客户端的真实用户；而反向代理就不一样了，</em></strong>反向代理服务器在接收访问用户请求后，会代理用户 重新发起请求代理下的节点服务器***，最后把数据返回给客户端用户。在节点服务器看来，访问的节点服务器的客户端用户就是反向代理服务器，而非真实的网站访问用户。</p><h4 id="18-1-6-upstream-module-和健康检测"><a href="#18-1-6-upstream-module-和健康检测" class="headerlink" title="18.1.6 upstream_module 和健康检测"></a>18.1.6 upstream_module 和健康检测</h4><p><strong><em>ngx_http_upstream_module 是负载均衡模块，可以实现网站的负载均衡功能即节点的健康检查</em></strong>，upstream 模块允许 Nginx 定义一组或多组节点服务器组，使用时可通过 proxy_pass 代理方式把网站的请求发送到事先定义好的对应 Upstream 组 的名字上。</p><table><thead><tr><th align="center">upstream 模块内参数</th><th>参数说明</th></tr></thead><tbody><tr><td align="center">weight</td><td>服务器权重</td></tr><tr><td align="center">max_fails</td><td>Nginx 尝试连接后端主机失败的此时，这是值是配合 proxy_next_upstream、fastcgi_next_upstream 和 memcached_next_upstream 这三个参数来使用的。当 Nginx接收后端服务器返回这三个参数定义的状态码时，会将这个请求转发给正常工作的的后端服务器。如 404、503、503,max_files=1</td></tr><tr><td align="center">fail_timeout</td><td>max_fails 和 fail_timeout 一般会关联使用，如果某台 server 在 fail_timeout 时间内出现了max_fails 次连接失败，那么 Nginx 会认为其已经挂掉，从而在 fail_timeout 时间内不再去请求它，fail_timeout 默认是 10s，max_fails 默认是 1，即默认情况只要是发生错误就认为服务器挂了，如果将 max_fails 设置为 0，则表示取消这项检查</td></tr><tr><td align="center">backup</td><td>表示当前 server 是备用服务器，只有其它非 backup 后端服务器都挂掉了或很忙才会分配请求给它</td></tr><tr><td align="center">down</td><td>标志服务器永远不可用，可配合 ip_hash 使用</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">upstream lvsServer{server 191.168.1.11 weight=5 ;server 191.168.1.22:82;server example.com:8080 max_fails=2 fail_timeout=10s backup;#域名的话需要解析的哦，内网记得 hosts}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="18-1-6-1-proxy-pass-请求转发"><a href="#18-1-6-1-proxy-pass-请求转发" class="headerlink" title="18.1.6.1 proxy_pass 请求转发"></a>18.1.6.1 proxy_pass 请求转发</h5><p>proxy_pass 指令属于 ngx_http_proxy_module 模块，此模块可以将请求转发到另一台服务器，在实际的反向代理工作中，**<em>会通过 location 功能匹配指定的 URI，然后把接收到服务匹配 URI 的请求通过 proyx_pass 抛给定义好的 upstream 节点池**</em>。</p><pre class="line-numbers language-none"><code class="language-none">location /download/ {proxy_pass http://download/vedio/;}#这是前端代理节点的设置#交给后端 upstream 为 download 的节点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>proxy 模块参数</th><th>说明</th></tr></thead><tbody><tr><td>proxy_next_upstream</td><td>什么情况下将请求传递到下一个 upstream</td></tr><tr><td>proxy_limite_rate</td><td>限制从后端服务器读取响应的速率</td></tr><tr><td>proyx_set_header</td><td>设置 http 请求 header 传给后端服务器节点，如：可实现让代理后端的服务器节点获取访问客户端的这是 ip</td></tr><tr><td>client_body_buffer_size</td><td>客户端请求主体缓冲区大小</td></tr><tr><td>proxy_connect_timeout</td><td>代理与后端节点服务器连接的超时时间</td></tr><tr><td>proxy_send_timeout</td><td>后端节点数据回传的超时时间</td></tr><tr><td>proxy_read_timeout</td><td>设置 Nginx 从代理的后端服务器获取信息的时间，表示连接成功建立后，Nginx 等待后端服务器的响应时间</td></tr><tr><td>proxy_buffer_size</td><td>设置缓冲区大小</td></tr><tr><td>proxy_buffers</td><td>设置缓冲区的数量和大小</td></tr><tr><td>proyx_busy_buffers_size</td><td>用于设置系统很忙时可以使用的 proxy_buffers 大小，推荐为proxy_buffers*2</td></tr><tr><td>proxy_temp_file_write_size</td><td>指定 proxy 缓存临时文件的大小</td></tr></tbody></table><h4 id="18-1-7-HAProxy"><a href="#18-1-7-HAProxy" class="headerlink" title="18.1.7 HAProxy"></a>18.1.7 HAProxy</h4><h2 id="19-数据库"><a href="#19-数据库" class="headerlink" title="19. 数据库"></a><strong>19. 数据库</strong></h2><h4 id="19-1-1-存储引擎"><a href="#19-1-1-存储引擎" class="headerlink" title="19.1.1 存储引擎"></a>19.1.1 存储引擎</h4><h5 id="19-1-1-1-概念"><a href="#19-1-1-1-概念" class="headerlink" title="19.1.1.1 概念"></a>19.1.1.1 概念</h5><p>数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以 获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎。存储引擎主要有： 1. MyIsam , 2. InnoDB, 3. Memory, 4. Archive, 5. Federated 。</p><h5 id="19-1-1-2-InnoDB（B-树）"><a href="#19-1-1-2-InnoDB（B-树）" class="headerlink" title="19.1.1.2 InnoDB（B+树）"></a>19.1.1.2 InnoDB（B+树）</h5><p>InnoDB 底层存储结构为B+树， B树的每个节点对应innodb的一个page，page大小是固定的，一般设为 16k。其中非叶子节点只有键值，叶子节点包含完成数据。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/InnoDBTreeStructure.png"></p><p>适用场景：</p><p>1）经常更新的表，适合处理多重并发的更新请求。</p><p>2）支持事务。</p><p>3）可以从灾难中恢复（通过 bin-log 日志等）。</p><p>4）外键约束。只有他支持外键。</p><p>5）支持自动增加列属性 auto_increment。</p><h5 id="19-1-1-3-TokuDB（Fractal-Tree-节点带数据）"><a href="#19-1-1-3-TokuDB（Fractal-Tree-节点带数据）" class="headerlink" title="19.1.1.3 TokuDB（Fractal Tree-节点带数据）"></a>19.1.1.3 TokuDB（Fractal Tree-节点带数据）</h5><p>TokuDB 底层存储结构为 Fractal Tree,Fractal Tree 的结构与 B+树有些类似, 在 Fractal Tree中，**<em>每一个 child 指针除了需要指向一个 child 节点外，还会带有一个 Message Buffer ，这个Message Buffer 是一个 FIFO 的队列，用来缓存更新操作**</em>。</p><p>例如，一次插入操作只需要落在某节点的 Message Buffer 就可以马上返回了，并不需要搜索到叶子节点。这些缓存的更新会在查询时或后台异步合并应用到对应的节点中。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/TokuDBStructure.png"></p><p>TokuDB 在线添加索引，不影响读写操作, 非常快的写入性能， Fractal-tree 在事务实现上有优势。 他主要适用于访问频率不高的数据或历史数据归档。</p><h5 id="19-1-1-4-MyIASM"><a href="#19-1-1-4-MyIASM" class="headerlink" title="19.1.1.4 MyIASM"></a>19.1.1.4 MyIASM</h5><p>MyIASM是 MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当 INSERT(插入)或 UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。</p><p>ISAM 执行**<em>读取操作的速度很快**</em>，而且不占用大量的内存和存储资源。在设计之初就预想数据组织成有固定长度的记录，按顺序存储的。—ISAM 是一种静态索引结构。</p><p><strong><em>缺点是它不 支持事务处理</em></strong>。</p><h5 id="19-1-1-5-Memory"><a href="#19-1-1-5-Memory" class="headerlink" title="19.1.1.5 Memory"></a>19.1.1.5 Memory</h5><p>Memory（也叫 HEAP）堆内存：使用存在内存中的内容来创建表。每个 MEMORY 表只实际对应一个磁盘文件。MEMORY 类型的表访问非常得快，因为它的数据是放在内存中的，并且默认使用HASH 索引。但是一旦服务关闭，表中的数据就会丢失掉。 Memory <strong><em>同时支持散列索引和 B 树索引，B树索引可以使用部分查询和通配查询</em></strong>，也可以使用&lt;,&gt;和&gt;=等操作符方便数据挖掘，散列索引相等的比较快但是对于范围的比较慢很多。</p><h4 id="19-1-2-索引"><a href="#19-1-2-索引" class="headerlink" title="19.1.2 索引"></a>19.1.2 索引</h4><p>索引（Index）是帮助 MySQL 高效获取数据的数据结构。常见的查询算法,顺序查找,二分查找,二叉排序树查找,哈希散列法,分块查找,平衡多路搜索树 B 树（B-tree）</p><h5 id="19-1-2-1-常见索引原则有"><a href="#19-1-2-1-常见索引原则有" class="headerlink" title="19.1.2.1 常见索引原则有"></a>19.1.2.1 常见索引原则有</h5><p><strong>1.选择唯一性索引</strong></p><p>​    唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。</p><p><strong>2.为经常需要排序、分组和联合操作的字段建立索引：</strong> </p><p><strong>3.为常作为查询条件的字段建立索引。</strong> </p><p><strong>4.限制索引的数目：</strong></p><p>​    越多的索引，会使更新表变得很浪费时间。</p><p><strong>5.尽量使用数据量少的索引</strong></p><p>6.如果索引的值很长，那么查询的速度会受到影响。</p><p><strong>尽量使用前缀来索引</strong></p><p>7.如果索引字段的值很长，最好使用值的前缀来索引。</p><p><strong>8.删除不再使用或者很少使用的索引</strong></p><p><strong>9.最左前缀匹配原则，非常重要的原则。</strong></p><p><strong>10.尽量选择区分度高的列作为索引</strong></p><p>​    区分度的公式是表示字段不重复的比例</p><p><strong>11.索引列不能参与计算，保持列“干净”：带函数的查询不参与索引。</strong></p><p><strong>12.尽量的扩展索引，不要新建索引。</strong></p><h4 id="19-1-3-数据库三范式"><a href="#19-1-3-数据库三范式" class="headerlink" title="19.1.3 数据库三范式"></a>19.1.3 数据库三范式</h4><p>范式是具有最小冗余的表结构。3 范式具体如下：</p><h5 id="19-1-3-1-第一范式-1st-NF-－列都是不可再分"><a href="#19-1-3-1-第一范式-1st-NF-－列都是不可再分" class="headerlink" title="19.1.3.1 第一范式(1st NF －列都是不可再分)"></a>19.1.3.1 第一范式(1st NF －列都是不可再分)</h5><p>第一范式的目标是确保每列的原子性:如果每**<em>列都是不可再分**</em>的最小数据单元（也称为最小的原子单元），则满足第一范式（1NF）</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/1stNF.png"></p><h5 id="19-1-3-2-第二范式-2nd-NF－每个表只描述一件事情"><a href="#19-1-3-2-第二范式-2nd-NF－每个表只描述一件事情" class="headerlink" title="19.1.3.2 第二范式(2nd NF－每个表只描述一件事情)"></a>19.1.3.2 第二范式(2nd NF－每个表只描述一件事情)</h5><p>首先满足第一范式，并且表中非主键列不存在对主键的部分依赖。 第二范式要求**<em>每个表只描述一件事情**</em>。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/2ndNF.png"></p><h5 id="19-1-3-3-第三范式-3rd-NF－-不存在对非主键列的传递依赖"><a href="#19-1-3-3-第三范式-3rd-NF－-不存在对非主键列的传递依赖" class="headerlink" title="19.1.3.3 第三范式(3rd NF－ 不存在对非主键列的传递依赖)"></a>19.1.3.3 第三范式(3rd NF－ 不存在对非主键列的传递依赖)</h5><p> 第三范式定义是，满足第二范式，并且表中的列不存在对非主键列的传递依赖。除了主键订单编号外，顾客姓名依赖于非主键顾客编号。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/3rdNF.png"></p><h4 id="19-1-4-数据库事务"><a href="#19-1-4-数据库事务" class="headerlink" title="19.1.4  数据库事务"></a>19.1.4  数据库事务</h4><p>事务(TRANSACTION)是作为单个逻辑工作单元执行的一系列操作，这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行 。事务是一个不可分割的工作逻辑单元事务必须具备以下四个属性，简称 ACID 属性：</p><p><strong><em>原子性（Atomicity）</em></strong></p><ol><li>事务是一个完整的操作。事务的各步操作是不可分的（原子的）；要么都执行，要么都不执行。</li></ol><p><strong><em>一致性（Consistency）</em></strong></p><ol start="2"><li>当事务完成时，数据必须处于一致状态。</li></ol><p><strong><em>隔离性（Isolation）</em></strong></p><ol start="3"><li>对数据进行修改的所有并发事务是彼此隔离的，这表明事务必须是独立的，它不应以任何方式依赖于或影响其他事务。</li></ol><p><strong><em>永久性（Durability）</em></strong></p><ol start="4"><li>事务完成后，它对数据库的修改被永久保持，事务日志能够保持事务的永久性。</li></ol><h4 id="19-1-5-存储过程-特定功能的-SQL-语句集"><a href="#19-1-5-存储过程-特定功能的-SQL-语句集" class="headerlink" title="19.1.5 存储过程(特定功能的 SQL 语句集)"></a>19.1.5 存储过程(特定功能的 SQL 语句集)</h4><p>一组为了完成特定功能的 SQL 语句集，存储在数据库中，经过第一次编译后再次调用不需要再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过程是数据库中的一个重要对象。</p><p><strong>存储过程优化思路：</strong></p><ol><li><p>尽量利用一些 sql 语句来替代一些小循环，例如聚合函数，求平均函数等。</p></li><li><p>中间结果存放于临时表，加索引。</p></li><li><p>少使用游标。sql 是个集合语言，对于集合运算具有较高性能。而 cursors 是过程运算。比如对一个 100 万行的数据进行查询。游标需要读表 100 万次，而不使用游标则只需要少量几次读取。</p></li><li><p>事务越短越好。sqlserver 支持并发操作。如果事务过多过长，或者隔离级别过高，都会造成并发操作的阻塞，死锁。导致查询极慢，cpu 占用率极地。</p></li><li><p>使用 try-catch 处理错误异常。</p></li><li><p>查找语句尽量不要放在循环内。</p></li></ol><h4 id="19-1-6-触发器-一段能自动执行的程序"><a href="#19-1-6-触发器-一段能自动执行的程序" class="headerlink" title="19.1.6 触发器(一段能自动执行的程序)"></a>19.1.6 触发器(一段能自动执行的程序)</h4><p>触发器是一段能自动执行的程序，是一种特殊的存储过程，触发器和普通的存储过程的区别是：**<em>触发器是当对某一个表进行操作时触发。诸如：update、insert、delete 这些操作的时候，系统会自动调用执行该表上对应的触发器**</em>。SQL Server 2005 中触发器可以分为两类：DML 触发器和DDL 触发器，其中 DDL 触发器它们会影响多种数据定义语言语句而激发，这些语句有 create、alter、drop 语句。</p><h4 id="19-1-7-数据库并发策略"><a href="#19-1-7-数据库并发策略" class="headerlink" title="19.1.7 数据库并发策略"></a>19.1.7 数据库并发策略</h4><p>并发控制一般采用三种方法，分别是**<em>乐观锁和悲观锁以及时间戳**</em>。</p><h5 id="19-1-7-1-乐观锁"><a href="#19-1-7-1-乐观锁" class="headerlink" title="19.1.7.1 乐观锁"></a>19.1.7.1 乐观锁</h5><p>乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据；悲观锁就刚好相反，觉得自己读数据库的时候，别人可能刚好在写自己刚读的数据，其实就是持一种比较保守的态度；时间戳就是不加锁，通过时间戳来控制并发出现的问题。</p><h5 id="19-1-7-2-悲观锁"><a href="#19-1-7-2-悲观锁" class="headerlink" title="19.1.7.2 悲观锁"></a>19.1.7.2 悲观锁</h5><p>悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加锁，只有自己把数据读完了，才允许别人修改那部分数据，或者反过来说，就是**<em>自己修改某条数据的时候，不允许别人读取该数据**</em>，只有等自己的整个事务提交了，才释放自己加上的锁，才允许其他用户访问那部分数据。</p><h5 id="19-1-7-3-时间戳"><a href="#19-1-7-3-时间戳" class="headerlink" title="19.1.7.3 时间戳"></a>19.1.7.3 时间戳</h5><p>时间戳就是在数据库表中单独加一列时间戳，比如“TimeStamp”，**<em>每次读出来的时候，把该字段也读出来，当写回去的时候，把该字段加1，提交之前 ，跟数据库的该字段比较一次，如果比数据库的值大的话，就允许保存，否则不允许保存**</em>，这种处理方法虽然不使用数据库系统提供的锁机制，但是这种方法可以大大提高数据库处理的并发量。</p><p>以上悲观锁所说的加“锁”，其实分为几种锁，分别是：**<em>排它锁（写锁）和共享锁（读锁）**</em>。</p><h4 id="19-1-8-数据库锁"><a href="#19-1-8-数据库锁" class="headerlink" title="19.1.8 数据库锁"></a>19.1.8 数据库锁</h4><h5 id="19-1-8-1-行级锁"><a href="#19-1-8-1-行级锁" class="headerlink" title="19.1.8.1 行级锁"></a>19.1.8.1 行级锁</h5><p><strong><em>行级锁是一种排他锁，防止其他事务修改此行</em></strong>；在使用以下语句时，Oracle 会自动应用行级锁：</p><ol><li><p>INSERT、UPDATE、DELETE、SELECT … FOR UPDATE [OF columns] [WAIT n | NOWAIT];</p></li><li><p>SELECT … FOR UPDATE 语句允许用户一次锁定多条记录进行更新</p></li><li><p>使用 COMMIT 或 ROLLBACK 语句释放锁。</p></li></ol><h5 id="19-1-8-2-表级锁"><a href="#19-1-8-2-表级锁" class="headerlink" title="19.1.8.2 表级锁"></a>19.1.8.2 表级锁</h5><p>表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分 MySQL 引擎支持。最常使用的 MYISAM 与 INNODB 都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。</p><h5 id="19-1-8-3-页级锁"><a href="#19-1-8-3-页级锁" class="headerlink" title="19.1.8.3 页级锁"></a>19.1.8.3 页级锁</h5><p>页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB 支持页级锁</p><h4 id="19-1-9-基于-Redis-分布式锁"><a href="#19-1-9-基于-Redis-分布式锁" class="headerlink" title="19.1.9 基于 Redis 分布式锁"></a>19.1.9 基于 Redis 分布式锁</h4><ol><li><p><strong><em>获取锁的时候，使用 setnx</em></strong>（SETNX key val：当且仅当 key 不存在时，set 一个 key为 val 的字符串，返回 1；若 key 存在，则什么都不做，返回 0）加锁，锁的 value值为一个随机生成的 UUID，在释放锁的时候进行判断。并使用 expire 命令为锁添加一个超时时间，超过该时间则自动释放锁。</p></li><li><p>获取锁的时候调用 setnx，**<em>如果返回 0，则该锁正在被别人使用，返回 1 则成功获取锁**</em>。 还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</p></li><li><p>释放锁的时候，通过 UUID <strong><em>判断是不是该锁</em></strong>，若是该锁，**<em>则执行 delete 进行锁释放**</em>。</p></li></ol><h4 id="19-1-10-分区分表"><a href="#19-1-10-分区分表" class="headerlink" title="19.1.10 分区分表"></a>19.1.10 分区分表</h4><p>分库分表有垂直切分和水平切分两种。</p><p><strong><em>垂直切分(按照功能模块)</em></strong> </p><ul><li><p>将表按照功能模块、关系密切程度划分出来，部署到不同的库上。例如，我们会建立定义数据库 workDB、商品数据库 payDB、用户数据库 userDB、日志数据库 logDB 等，分别用于存储项目数据定义表、商品定义表、用户数据表、日志数据表等。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/VerticalSplit.png"></p></li></ul><p><strong><em>水平切分(按照规则划分存储)</em></strong> </p><ul><li><p>当一个表中的数据量过大时，我们可以把该表的数据按照某种规则，例如 userID 散列，进行划分，然后存储到多个结构相同的表，和不同的库上。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/HorizontalSplit.png"></p></li></ul><h4 id="19-1-11-两阶段提交协议"><a href="#19-1-11-两阶段提交协议" class="headerlink" title="19.1.11 两阶段提交协议"></a>19.1.11 两阶段提交协议</h4><p>分布式事务是指会涉及到操作多个数据库的事务,在分布式系统中，各个节点之间在物理上相互独立，通过网络进行沟通和协调。</p><p>XA 就是 X/Open DTP 定义的交易中间件与数据库之间的接口规范（即接口函数），交易中间件用它来通知数据库事务的开始、结束以及提交、回滚等。 XA 接口函数由数据库厂商提供。</p><p>二阶段提交(Two-phaseCommit)是指，在计算机网络以及数据库领域内，*<strong>为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种算法(Algorithm)**<em>。通常，二阶段提交也被称为是一种协议(Protocol))。在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的 ACID 特性，</em></strong>需要引入一个作为协调者的组件来统一掌控所有节点(称作参与者)的操作结果并最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)***。因此，二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</p><h5 id="19-1-11-1-准备阶段"><a href="#19-1-11-1-准备阶段" class="headerlink" title="19.1.11.1 准备阶段"></a>19.1.11.1 准备阶段</h5><p>事务协调者(事务管理器)给每个参与者(资源管理器)<strong><em>发送 Prepare 消息</em></strong>，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，**<em>写本地的 redo 和 undo 日志，但不提交**</em>，到达一种“万事俱备，只欠东风”的状态。</p><h5 id="19-1-11-2-提交阶段"><a href="#19-1-11-2-提交阶段" class="headerlink" title="19.1.11.2 提交阶段"></a>19.1.11.2 提交阶段</h5><p>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)</p><h5 id="19-1-11-3-缺点"><a href="#19-1-11-3-缺点" class="headerlink" title="19.1.11.3 缺点"></a>19.1.11.3 缺点</h5><p><strong><em>同步阻塞问题</em></strong></p><p>1、执行过程中，所有参与节点都是事务阻塞型的。</p><p><strong><em>单点故障</em></strong></p><p>2、由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。</p><p><strong><em>数据不一致（脑裂问题）</em></strong></p><p>3、在二阶段提交的阶段二中，当协调者向参与者**<em>发送 commit 请求之后，发生了局部网络异常**</em>或者在发送 commit 请求过程中协调者发生了故障，导致只有一部分参与者接受到了commit 请求。于是整个分布式系统便出现了数据部一致性的现象(脑裂现象)。</p><p><strong><em>二阶段无法解决的问题（数据状态不确定）</em></strong></p><p>4、协调者再发出 commit 消息之后宕机，*<strong>而唯一接收到这条消息的参与者同时也宕机了**<em>。那么即使协调者通过选举协议产生了新的协调者，</em></strong>这条事务的状态也是不确定的，没人知道事务是否被已经提交***。</p><h4 id="19-1-12-三阶段提交协议"><a href="#19-1-12-三阶段提交协议" class="headerlink" title="19.1.12 三阶段提交协议"></a>19.1.12 三阶段提交协议</h4><p>三阶段提交（ Three-phase commit ） ， 也 叫 三 阶 段 提 交 协 议 （ Three-phase commit protocol），是二阶段提交（2PC）的改进版本。</p><p>与两阶段提交不同的是，三阶段提交有两个改动点。</p><p>1、引入超时机制。同时在协调者和参与者中都引入超时机制。</p><p>2、在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。也就是说，除了引入超时机制之外，**<em>3PC 把 2PC 的准备阶段再次一分为二**</em>，这样三阶段提交就有 CanCommit、PreCommit、DoCommit 三个阶段。</p><h5 id="19-1-12-1-CanCommit-阶段"><a href="#19-1-12-1-CanCommit-阶段" class="headerlink" title="19.1.12.1 CanCommit 阶段"></a>19.1.12.1 CanCommit 阶段</h5><p><strong><em>协调者向参与者发送 commit 请求，参与者如果可以提交就返回 Yes 响应，否则返回 No 响应</em></strong>。</p><h5 id="19-1-12-2-PreCommit-阶段"><a href="#19-1-12-2-PreCommit-阶段" class="headerlink" title="19.1.12.2 PreCommit 阶段"></a>19.1.12.2 PreCommit 阶段</h5><p>协调者根据参与者的反应情况来决定是否可以继续进行，有以下两种可能。假如协调者从所有的参与者获得的反馈都是 Yes 响应，那么就会执行事务的预执行假如有任何一个参与者向协调者发送了 No 响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。</p><h5 id="19-1-12-3-doCommit-阶段"><a href="#19-1-12-3-doCommit-阶段" class="headerlink" title="19.1.12.3 doCommit 阶段"></a>19.1.12.3 doCommit 阶段</h5><p>该阶段进行真正的事务提交，主要包含 1.协调这发送提交请求 2.参与者提交事务 3.<strong><em>参与者响应反馈（ 事务提交完之后，向协调者发送 Ack 响应。）</em></strong>4.协调者确定完成事务。</p><h4 id="19-1-13-柔性事务"><a href="#19-1-13-柔性事务" class="headerlink" title="19.1.13 柔性事务"></a>19.1.13 柔性事务</h4><h5 id="19-1-13-1-柔性事务"><a href="#19-1-13-1-柔性事务" class="headerlink" title="19.1.13.1 柔性事务"></a>19.1.13.1 柔性事务</h5><p>在电商领域等互联网场景下，传统的事务在数据库性能和处理能力上都暴露出了瓶颈。在分布式领域基于 CAP 理论以及 BASE 理论，有人就提出了 柔性事务 的概念。CAP（一致性、可用性、分区容忍性）理论大家都理解很多次了，这里不再叙述。说一下 BASE 理论，它是在 CAP 理论的基础之上的延伸。包括 基本可用（Basically Available）、柔性状态（Soft State）、最终一致性（Eventual Consistency）。</p><p>通常所说的柔性事务分为：**<em>两阶段型、补偿型、异步确保型、最大努力通知型几种**</em>。</p><p><strong><em>两阶段型</em></strong></p><p>1、就是**<em>分布式事务两阶段提交，对应技术上的 XA、JTA/JTS**</em>。这是分布式环境下事务处理的典型模式。</p><p><strong><em>补偿型</em></strong></p><p>2、TCC 型事务（Try/Confirm/Cancel）可以归为补偿型。</p><p>WS-BusinessActivity 提供了一种基于补偿的 long-running 的事务处理模型。服务器 A 发起事务，服务器 B 参与事务，*<strong>服务器 A 的事务如果执行顺利，那么事务 A 就先行提交，如果事务 B 也执行顺利，则事务 B 也提交，整个事务就算完成***。但是如果事务 *</strong>B 执行失败，事务 B 本身回滚，这时事务 A 已经被提交，所以需要执行一个补偿操作，将已经提交的事务 A 执行的操作作反操作，恢复到未执行前事务 A 的状态***。这样的 SAGA 事务模型，是牺牲了一定的隔离性和一致性的，但是提高了 long-running 事务的可用性。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/TCCTransaction.png"></p><p><strong><em>异步确保型</em></strong></p><p>3、通过将一系列同步的事务操作变为基于消息执行的异步操作, 避免了分布式事务中的同步阻塞操作的影响。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/AsynchronousAssurance.png"></p><p><strong><em>最大努力通知型（多次尝试）</em></strong></p><p>4、这是分布式事务中要求最低的一种, 也可以通过消息中间件实现, 与前面异步确保型操作不同的一点是, 在消息由 MQ Server 投递到消费者之后, <strong><em>允许在达到最大重试次数之后正常结束事务</em></strong>。 </p><h4 id="19-1-14-CAP"><a href="#19-1-14-CAP" class="headerlink" title="19.1.14 CAP"></a>19.1.14 CAP</h4><p>CAP 原则又称 CAP 定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。</p><p><strong>一致性（C）：</strong></p><ol><li>在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</li></ol><p><strong>可用性（A）：</strong></p><ol start="2"><li>在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</li></ol><p><strong>分区容忍性（P）：</strong></p><ol start="3"><li>以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。</li></ol><h2 id="20-一致性算法"><a href="#20-一致性算法" class="headerlink" title="20. 一致性算法"></a><strong>20. 一致性算法</strong></h2><h4 id="20-1-1-Paxos"><a href="#20-1-1-Paxos" class="headerlink" title="20.1.1 Paxos"></a>20.1.1 Paxos</h4><p>Paxos 算法解决的问题是一个分布式系统如何就某个值（决议）达成一致。一个典型的场景是，在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点执行相同的操作序列，那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每一条指令上执行一个“一致性算法”以保证每个节点看到的指令一致。zookeeper 使用的 zab 算法是该算法的一个实现。 在 Paxos 算法中，有三种角色：Proposer，Acceptor，Learners</p><p><strong>Paxos 三种角色：Proposer，Acceptor，Learners</strong></p><p><strong><em>Proposer：</em></strong></p><p>只要 Proposer 发的提案被半数以上 Acceptor 接受，Proposer 就认为该提案里的 value 被选定了。</p><p><strong><em>Acceptor：</em></strong></p><p>只要 Acceptor 接受了某个提案，Acceptor 就认为该提案里的 value 被选定了。</p><p><strong><em>Learner：</em></strong></p><p><strong><em>Acceptor 告诉 Learner 哪个 value 被选定，Learner 就认为那个 value 被选定</em></strong>。</p><p><strong>Paxos 算法分为两个阶段。具体如下：</strong></p><p><strong><em>阶段一（准 leader 确定 ）：</em></strong></p><p>(a) Proposer 选择一个提案编号 N，然后向半数以上的 Acceptor 发送编号为 N 的 Prepare 请求。</p><p>(b) 如果一个 Acceptor 收到一个编号为 N 的 Prepare 请求，且 N 大于该 Acceptor 已经响应过的所有 Prepare 请求的编号，那么它就会将它已经接受过的编号最大的提案（如果有的话）作为响应反馈给 Proposer，同时该 Acceptor 承诺不再接受任何编号小于 N 的提案。</p><p><strong><em>阶段二（leader 确认）：</em></strong></p><p>(a) <strong><em>如果 Proposer 收到半数以上 Acceptor 对其发出的编号为 N 的 Prepare 请求的响应，那么它就会发送一个针对[N,V]提案的 Accept 请求给半数以上的 Acceptor</em></strong>。注意：V 就是收到的响应中编号最大的提案的 value，如果响应中不包含任何提案，那么 V 就由 Proposer 自己决定。</p><p>(b) 如果 Acceptor 收到一个针对编号为 N 的提案的 Accept 请求，只要该 Acceptor 没有对编号大于 N 的 Prepare 请求做出过响应，它就接受该提案。</p><h4 id="20-1-2-Zab"><a href="#20-1-2-Zab" class="headerlink" title="20.1.2 Zab"></a>20.1.2 Zab</h4><p> ZAB( ZooKeeper Atomic Broadcast , ZooKeeper 原子消息广播协议）协议包括两种基本的模式：崩溃恢复和消息广播.</p><ol><li><p>当整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断崩溃退出与重启等异常情况时，ZAB 就会进入恢复模式并选举产生新的 Leader 服务器。</p></li><li><p>当选举产生了新的 Leader 服务器，同时集群中已经有过半的机器与该 Leader 服务器完成了状态同步之后，ZAB 协议就会退出崩溃恢复模式，进入消息广播模式。</p></li><li><p>当有新的服务器加入到集群中去，如果此时集群中已经存在一个 Leader 服务器在负责进行消息广播，那么新加入的服务器会自动进入数据恢复模式，找到 Leader 服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。</p></li></ol><p>以上其实大致经历了三个步骤：</p><p><strong><em>1.崩溃恢复：主要就是 Leader 选举过程</em></strong></p><p><strong><em>2.数据同步：Leader 服务器与其他服务器进行数据同步</em></strong></p><p><strong><em>3.消息广播：Leader 服务器将数据发送给其他服务器</em></strong></p><p><strong><em>说明：zookeeper 章节对该协议有详细描述</em></strong>。</p><h4 id="20-1-3-Raft"><a href="#20-1-3-Raft" class="headerlink" title="20.1.3 Raft"></a>20.1.3 Raft</h4><p>与 Paxos 不同 Raft 强调的是易懂（Understandability），Raft 和 Paxos 一样只要保证 n/2+1 节点正常就能够提供服务；raft 把算法流程分为三个子问题：选举（Leader election）、日志复制（Log replication）、安全性（Safety）三个子问题。</p><h5 id="20-1-3-1-角色"><a href="#20-1-3-1-角色" class="headerlink" title="20.1.3.1 角色"></a>20.1.3.1 角色</h5><p> Raft 把集群中的节点分为三种状态：*<strong>Leader、 Follower 、Candidate**<em>，理所当然每种状态负责的任务也是不一样的，</em></strong>Raft 运行时提供服务的时候只存在 Leader 与 Follower 两种状态***；</p><p><strong><em>Leader（领导者-日志管理）</em></strong></p><p>负责日志的同步管理，处理来自客户端的请求，与 Follower 保持这 heartBeat 的联系；</p><p><strong><em>Follower（追随者-日志同步）</em></strong></p><p>刚启动时所有节点为Follower状态，响应Leader的日志同步请求，响应Candidate的请求，把请求到 Follower 的事务转发给 Leader；</p><p><strong><em>Candidate（候选者-负责选票）</em></strong></p><p>负责选举投票，Raft 刚启动时由一个节点从 Follower 转为 Candidate 发起选举，选举出Leader 后从 Candidate 转为 Leader 状态；</p><h5 id="20-1-3-2-Term（任期）"><a href="#20-1-3-2-Term（任期）" class="headerlink" title="20.1.3.2 Term（任期）"></a>20.1.3.2 Term（任期）</h5><p> 在 Raft 中使用了一个可以理解为周期（第几届、任期）的概念，用 Term 作为一个周期，每个 Term 都是一个连续递增的编号，每一轮选举都是一个 Term 周期，在一个 Term 中只能产生一个 Leader；当某节点收到的请求中 Term 比当前 Term 小时则拒绝该请求。</p><h5 id="20-1-3-3-选举（Election）"><a href="#20-1-3-3-选举（Election）" class="headerlink" title="20.1.3.3 选举（Election）"></a>20.1.3.3 选举（Election）</h5><p><strong><em>选举定时器</em></strong></p><p> Raft 的选举由定时器来触发，**<em>每个节点的选举定时器时间都是不一样的**</em>，开始时状态都为Follower 某个节点定时器触发选举后 Term 递增，状态由 Follower 转为 Candidate，向其他节点发起 RequestVote RPC 请求，这时候有三种可能的情况发生：</p><p> 1：该 RequestVote 请求接收到 n/2+1（过半数）个节点的投票，从 Candidate 转为 Leader，向其他节点发送 heartBeat 以保持 Leader 的正常运转。</p><p> 2：在此期间如果收到其他节点发送过来的 AppendEntries RPC 请求，如该节点的 Term 大则当前节点转为 Follower，否则保持 Candidate 拒绝该请求。</p><p> 3：Election timeout 发生则 Term 递增，重新发起选举</p><p> 在一个 Term 期间每个节点只能投票一次，**<em>所以当有多个 Candidate 存在时就会出现每个Candidate 发起的选举都存在接收到的投票数都不过半的问题，这时每个 Candidate 都将 Term递增、重启定时器并重新发起选举，由于每个节点中定时器的时间都是随机的，所以就不会多次存在有多个 Candidate 同时发起投票的问题**</em>。</p><p>在 Raft 中当接收到客户端的日志（事务请求）后先把该日志追加到本地的 Log 中，然后通过heartbeat 把该 Entry 同步给其他 Follower，Follower 接收到日志后记录日志然后向 Leader 发送ACK，当 Leader 收到大多数（n/2+1）Follower 的 ACK 信息后将该日志设置为已提交并追加到本地磁盘中，通知客户端并在下个 heartbeat 中 Leader 将通知所有的 Follower 将该日志存储在自己的本地磁盘中。</p><h5 id="20-1-3-4-安全性（Safety）"><a href="#20-1-3-4-安全性（Safety）" class="headerlink" title="20.1.3.4 安全性（Safety）"></a>20.1.3.4 安全性（Safety）</h5><p>安全性是用于保证每个节点都执行相同序列的安全机制如当某个 <strong><em>Follower 在当前 Leader commit Log 时变得不可用了，稍后可能该 Follower 又会倍选举为 Leader，这时新 Leader 可能会用新的Log 覆盖先前已 committed 的 Log</em></strong>，这就是导致节点执行不同序列；Safety 就是用于保证选举出来的 Leader 一定包含先前 commited Log 的机制；</p><p> 选举安全性（Election Safety）：每个 Term 只能选举出一个 Leader</p><p>Leader 完整性（Leader Completeness）：这里所说的*<strong>完整性是指 Leader 日志的完整性***，Raft 在选举阶段就使用 Term 的判断用于保证完整性：当请求投票的该 *</strong>Candidate 的 Term 较大或 Term 相同 Index 更大则投票***，该节点将容易变成 leader。</p><h5 id="20-1-3-5-raft-协议和-zab-协议区别"><a href="#20-1-3-5-raft-协议和-zab-协议区别" class="headerlink" title="20.1.3.5 raft 协议和 zab 协议区别"></a>20.1.3.5 raft 协议和 zab 协议区别</h5><p><strong>相同点</strong></p><ul><li> 采用 quorum 来确定整个系统的一致性,这个 quorum 一般实现是集群中半数以上的服务器, </li></ul><ul><li> zookeeper 里还提供了带权重的 quorum 实现. </li></ul><ul><li> 都由 leader 来发起写操作. </li></ul><ul><li> 都采用心跳检测存活性</li></ul><ul><li> leader election 都采用先到先得的投票方式</li></ul><p><strong>不同点</strong></p><ul><li> zab 用的是 epoch 和 count 的组合来唯一表示一个值, 而 raft 用的是 term 和 index</li></ul><ul><li> <strong><em>zab 的 follower 在投票给一个 leader 之前必须和 leader 的日志达成一致</em></strong>,而 raft 的 follower则简单地说是谁的 term 高就投票给谁</li></ul><ul><li> raft 协议的心跳是从 leader 到 follower, 而 zab 协议则相反</li></ul><ul><li> raft 协议数据只有单向地从 leader 到 follower(成为 leader 的条件之一就是拥有最新的 log), <strong><em>而 zab 协议在 discovery 阶段, 一个 prospective leader 需要将自己的 log 更新为 quorum 里面最新的 log</em></strong>,然后才好在 synchronization 阶段将 quorum 里的其他机器的 log 都同步到一致.</li></ul><h4 id="20-1-4-NWR"><a href="#20-1-4-NWR" class="headerlink" title="20.1.4 NWR"></a>20.1.4 NWR</h4><p><strong><em>N：在分布式存储系统中，有多少份备份数据</em></strong></p><p><strong><em>W：代表一次成功的更新操作要求至少有 w 份数据写入成功</em></strong></p><p><strong><em>R： 代表一次成功的读数据操作要求至少有 R 份数据成功读取</em></strong></p><p>NWR值的不同组合会产生不同的一致性效果，当W+R&gt;N 的时候，整个系统对于客户端来讲能保证强一致性。而如果 R+W&lt;=N，则无法保证数据的强一致性。以常见的 N=3、W=2、R=2 为例：N=3，表示，任何一个对象都必须有三个副本（Replica），W=2 表示，对数据的修改操作（Write）只需要在 3 个 Replica 中的 2 个上面完成就返回，R=2 表示，从三个对象中要读取到 2个数据对象，才能返回。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/NWR.png"></p><h4 id="20-1-5-Gossip"><a href="#20-1-5-Gossip" class="headerlink" title="20.1.5 Gossip"></a>20.1.5 Gossip</h4><p>Gossip 算法又被称为反熵（Anti-Entropy），熵是物理学上的一个概念，**<em>代表杂乱无章，而反熵就是在杂乱无章中寻求一致**</em>，这充分说明了 Gossip 的特点：在一个有界网络中，每个节点都随机地与其他节点通信，经过一番杂乱无章的通信，最终所有节点的状态都会达成一致。每个节点可能知道所有其他节点，也可能仅知道几个邻居节点，只要这些节可以通过网络连通，最终他们的状态都是一致的，当然这也是疫情传播的特点。</p><h4 id="20-1-6-一致性-Hash"><a href="#20-1-6-一致性-Hash" class="headerlink" title="20.1.6 一致性 Hash"></a>20.1.6 一致性 Hash</h4><p>一致性哈希算法(Consistent Hashing Algorithm)是一种分布式算法，常用于负载均衡。Memcached client 也选择这种算法，解决将 key-value 均匀分配到众多 Memcached server 上的问题。它可以取代传统的取模操作，解决了取模操作无法应对增删 Memcached Server 的问题(增删 server 会导致同一个 key,在 get 操作时分配不到数据真正存储的 server，命中率会急剧下降)。</p><h5 id="20-1-6-1-一致性-Hash-特性"><a href="#20-1-6-1-一致性-Hash-特性" class="headerlink" title="20.1.6.1 一致性 Hash 特性"></a>20.1.6.1 一致性 Hash 特性</h5><ul><li> 平衡性(Balance)：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。 </li></ul><ul><li> 单调性(Monotonicity)：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。容易看到，上面的简单求余算法hash(object)%N 难以满足单调性要求。</li></ul><ul><li> 平滑性(Smoothness)：平滑性是指缓存服务器的数目平滑改变和缓存对象的平滑改变是一致的。</li></ul><h5 id="20-1-6-2-一致性-Hash-原理"><a href="#20-1-6-2-一致性-Hash-原理" class="headerlink" title="20.1.6.2 一致性 Hash 原理"></a>20.1.6.2 <strong>一致性</strong> <strong>Hash</strong> <strong>原理</strong></h5><p><strong><em>1.建构环形 hash 空间：</em></strong></p><ol><li>考虑通常的 hash 算法都是将 value 映射到一个 32 为的 key 值，也即是 0~2^32-1 次方的数值空间；我们可以**<em>将这个空间想象成一个首（ 0 ）尾（ 2^32-1 ）相接的圆环**</em>。</li></ol><p><strong><em>2.把需要缓存的内容（对象）映射到 hash 空间</em></strong></p><ol start="2"><li>接下来考虑 4 个对象 object1~object4 ，通过 hash 函数计算出的 hash 值 key 在环上的分布</li></ol><p><strong><em>3.把服务器（节点）映射到 hash 空间</em></strong></p><ol start="3"><li>Consistent hashing 的基本思想就是将对象和 cache 都映射到同一个 hash 数值空间中，并且使用相同的 hash 算法。一般的方法可以使用 服务器(节点) 机器的 IP 地址或者机器名作为hash 输入。</li></ol><p><strong><em>4.把对象映射到服务节点</em></strong></p><ol start="4"><li><p>现在服务节点和对象都已经通过同一个 hash 算法映射到 hash 数值空间中了，**<em>首先确定对象hash 值在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器**</em>。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/ConsistentHashPrinciple.png"></p></li></ol><p><strong><em>考察 cache 的变动</em></strong></p><ol start="5"><li><p>通过 hash 然后求余的方法带来的最大问题就在于不能满足单调性，当 cache 有所变动时，cache 会失效。</p><p><strong>5.1 移除 cache</strong>：考虑假设 cache B 挂掉了，根据上面讲到的映射方法，这时受影响的将仅是那些沿 cache B 逆时针遍历直到下一个 cache （ cache C ）之间的对象。</p><p><strong>5.2 添加 cache</strong>：再考虑添加一台新的 cache D 的情况，这时受影响的将仅是那些沿 cache D 逆时针遍历直到下一个 cache 之间的对象，将这些对象重新映射到 cache D 上即可。</p></li></ol><p><strong><em>虚拟节点</em></strong></p><p>hash 算法并不是保证绝对的平衡，如果 cache 较少的话，对象并不能被均匀的映射到 cache 上，为了解决这种情况， consistent hashing 引入了“虚拟节点”的概念，它可以如下定义：**<em>虚拟节点（ virtual node ）是实际节点在 hash 空间的复制品（ replica ）**</em>，一实际个节点对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以 hash 值排列。</p><p>仍以仅部署 cache A 和 cache C 的情况为例。现在我们引入虚拟节点，并设置“复制个数”为 2 ，这就意味着一共会存在 4 个“虚拟节点”， cache A1, cache A2 代表了 cache A； cache C1, cache C2 代表了 cache C 。此时，对象到“虚拟节点”的映射关系为：objec1-&gt;cache A2 ； objec2-&gt;cache A1 ； objec3-&gt;cache C1 ； objec4-&gt;cache C2 ；因此对象 object1 和 object2 都被映射到了 cache A 上，而 object3 和 object4 映射到了 cache C 上；平衡性有了很大提高。</p><p>引入“虚拟节点”后，映射关系就从 { 对象 -&gt; 节点 } 转换到了 { 对象 -&gt; 虚拟节点 } 。查询物体所在 cache 时的映射关系如下图 所示。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/CacheMappingRelations.png"></p><h2 id="21-JAVA-算法"><a href="#21-JAVA-算法" class="headerlink" title="21. JAVA 算法"></a><strong>21. JAVA 算法</strong></h2><h4 id="21-1-1-二分查找"><a href="#21-1-1-二分查找" class="headerlink" title="21.1.1 二分查找"></a>21.1.1 二分查找</h4><p>又叫折半查找，要求待查找的序列有序。每次取中间位置的值与待查关键字比较，如果中间位置的值比待查关键字大，则在前半部分循环这个查找的过程，如果中间位置的值比待查关键字小，则在后半部分循环这个查找的过程。直到查找到了为止，否则序列中没有待查的关键字。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static int biSearch(int []array,int a){ int lo=0; int hi=array.length-1; int mid; while(lo&lt;=hi){ mid=(lo+hi)/2;//中间位置if(array[mid]==a){ return mid+1;}else if(array[mid]&lt;a){ //向右查找 lo=mid+1;}else{ //向左查找 hi=mid-1;  } } return -1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="21-1-2-冒泡排序算法"><a href="#21-1-2-冒泡排序算法" class="headerlink" title="21.1.2 冒泡排序算法"></a>21.1.2 冒泡排序算法</h4><p>（1）比较前后相邻的二个数据，如果前面数据大于后面的数据，就将这二个数据交换。</p><p>（2）这样对数组的第 0 个数据到 N-1 个数据进行一次遍历后，最大的一个数据就“沉”到数组第N-1 个位置。</p><p>（3）N=N-1，如果 N 不为 0 就重复前面二步，否则排序完成。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void bubbleSort1(int [] a, int n){ int i, j; for(i=0; i&lt;n; i++){//表示 n 次排序过程。 for(j=1; j&lt;n-i; j++){ if(a[j-1] &gt; a[j]){//前面的数字大于后面的数字就交换 //交换 a[j-1]和 a[j] int temp; temp = a[j-1]; a[j-1] = a[j]; a[j]=temp; }} } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="21-1-3-插入排序算法"><a href="#21-1-3-插入排序算法" class="headerlink" title="21.1.3 插入排序算法"></a>21.1.3 插入排序算法</h4><p>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应的位置并插入。插入排序非常类似于整扑克牌。在开始摸牌时，左手是空的，牌面朝下放在桌上。接着，**<em>一次从桌上摸起一张牌，并将它插入到左手一把牌中的正确位置上。为了找到这张牌的正确位置，要将它与手中已有的牌从右到左地进行比较。无论什么时候，左手中的牌都是排好序的**</em>。</p><p>如果输入数组已经是排好序的话，插入排序出现最佳情况，其运行时间是输入规模的一个线性函数。如果输入数组是逆序排列的，将出现最坏情况。平均情况与最坏情况一样，其时间代价是(n2)。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/InsertionSort.png"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void sort(int arr[]){for(int i =1; i&lt;arr.length;i++)  {//插入的数int insertVal = arr[i];//被插入的位置(准备和前一个数比较)int index = i-1;//如果插入的数比被插入的数小while(index&gt;=0&amp;&amp;insertVal&lt;arr[index]){ //将把 arr[index] 向后移动 arr[index+1]=arr[index]; //让 index 向前移动 index--; }//把插入的数放入合适位置arr[index+1]=insertVal; }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="21-1-4-快速排序算法"><a href="#21-1-4-快速排序算法" class="headerlink" title="21.1.4 快速排序算法"></a>21.1.4 快速排序算法</h4><p>快速排序的原理：选择一个关键值作为基准值。比基准值小的都在左边序列（一般是无序的），比基准值大的都在右边（一般是无序的）。一般选择序列的第一个元素。一次循环：*<strong>从后往前比较**<em>，用基准值和最后一个值比较，如果比基准值小的交换位置，如果没有继续比较下一个，直到找到第一个比基准值小的值才交换。</em></strong>找到这个值之后，又从前往后开始比较*<strong>，如果有比基准值大的，交换位置，如果没有继续比较下一个，直到找到第一个比基准值大的值才交换。直到**<em>从前往后的比较索引&gt;从后往前比较的索引</em></strong>，结束第一次循环，此时，对于基准值来说，左右两边就是有序的了。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void sort(int[] a,int low,int high){ int start = low; int end = high; int key = a[low];  while(end&gt;start){ //从后往前比较while(end&gt;start&amp;&amp;a[end]&gt;=key) //如果没有比关键值小的，比较下一个，直到有比关键值小的交换位置，然后又从前往后比较  end--;if(a[end]&lt;=key){  int temp = a[end];  a[end] = a[start];  a[start] = temp; } //从前往后比较 while(end&gt;start&amp;&amp;a[start]&lt;=key)//如果没有比关键值大的，比较下一个，直到有比关键值大的交换位置   start++; if(a[start]&gt;=key){   int temp = a[start];   a[start] = a[end];     a[end] = temp; } //此时第一次循环比较结束，关键值的位置已经确定了。左边的值都比关键值小，右边的值都比关键值大，但是两边的顺序还有可能是不一样的，进行下面的递归调用 } //递归 if(start&gt;low) sort(a,low,start-1);//左边序列。第一个索引位置到关键值索引-1 if(end&lt;high) sort(a,end+1,high);//右边序列。从关键值索引+1 到最后一个}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/QuickSort.png"></p><h4 id="21-1-5-希尔排序算法"><a href="#21-1-5-希尔排序算法" class="headerlink" title="21.1.5 希尔排序算法"></a>21.1.5 希尔排序算法</h4><p>基本思想：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p><ol><li><p>操作方法：</p><p>选择一个增量序列 t1，t2，…，tk，其中 ti&gt;tj，tk=1；</p></li><li><p>按增量序列个数 k，对序列进行 k 趟排序；</p></li><li><p>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/HillSort.png"></p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">private void shellSort(int[] a) {int dk = a.length/2; while( dk &gt;= 1 ){ ShellInsertSort(a, dk); dk = dk/2;} }private void ShellInsertSort(int[] a, int dk) {//类似插入排序，只是插入排序增量是 1，这里增量是 dk,把 1 换成 dk 就可以了for(int i=dk;i&lt;a.length;i++){if(a[i]&lt;a[i-dk]){int j;int x=a[i];//x 为待插入元素a[i]=a[i-dk];for(j=i-dk; j&gt;=0 &amp;&amp; x&lt;a[j];j=j-dk){//通过循环，逐个后移一位找到要插入的位置。a[j+dk]=a[j];}a[j+dk]=x;//插入} } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="21-1-6-归并排序算法"><a href="#21-1-6-归并排序算法" class="headerlink" title="21.1.6 归并排序算法"></a>21.1.6 归并排序算法</h4><p>归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/MergeSort.png"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MergeSortTest {  public static void main(String[] args) {  int[] data = new int[] { 5, 3, 6, 2, 1, 9, 4, 8, 7 }; print(data); mergeSort(data); System.out.println("排序后的数组："); print(data);  }  public static void mergeSort(int[] data) { sort(data, 0, data.length - 1);  }      public static void sort(int[] data, int left, int right) { if (left &gt;= right) return; // 找出中间索引 int center = (left + right) / 2; // 对左边数组进行递归 sort(data, left, center); // 对右边数组进行递归 sort(data, center + 1, right); // 合并 merge(data, left, center, right); print(data);  }  /**  * 将两个数组进行归并，归并前面 2 个数组已有序，归并后依然有序 *  * @param data  * 数组对象 * @param left  * 左数组的第一个元素的索引 * @param center  * 左数组的最后一个元素的索引，center+1 是右数组第一个元素的索引 * @param right  * 右数组最后一个元素的索引 */  public static void merge(int[] data, int left, int center, int right) { // 临时数组 int[] tmpArr = new int[data.length]; // 右数组第一个元素索引 int mid = center + 1; // third 记录临时数组的索引 int third = left; // 缓存左数组第一个元素的索引 int tmp = left; while (left &lt;= center &amp;&amp; mid &lt;= right) { // 从两个数组中取出最小的放入临时数组 if (data[left] &lt;= data[mid]) { tmpArr[third++] = data[left++]; } else { tmpArr[third++] = data[mid++]; } } // 剩余部分依次放入临时数组（实际上两个 while 只会执行其中一个） while (mid &lt;= right) { tmpArr[third++] = data[mid++];  } while (left &lt;= center) { tmpArr[third++] = data[left++]; } // 将临时数组中的内容拷贝回原数组中 // （原 left-right 范围的内容被复制回原数组） while (tmp &lt;= right) { data[tmp] = tmpArr[tmp++]; }  }  public static void print(int[] data) { for (int i = 0; i &lt; data.length; i++) { System.out.print(data[i] + "\t"); } System.out.println();  } } <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="21-1-7-桶排序算法"><a href="#21-1-7-桶排序算法" class="headerlink" title="21.1.7 桶排序算法"></a>21.1.7 桶排序算法</h4><p>桶排序的基本思想是： 把数组 arr 划分为 n 个大小相同子区间（桶），每个子区间各自排序，最后合并 。计数排序是桶排序的一种特殊情况，可以把计数排序当成每个桶里只有一个元素的情况。</p><p>1.找出待排序数组中的最大值 max、最小值 min</p><p>2.我们使用 动态数组 ArrayList 作为桶，桶里放的元素也用 ArrayList 存储。桶的数量为(max-min)/arr.length+1</p><p>3.遍历数组 arr，计算每个元素 arr[i] 放的桶</p><p>4.每个桶各自排序</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void bucketSort(int[] arr){int max = Integer.MIN_VALUE;int min = Integer.MAX_VALUE;for(int i = 0; i &lt; arr.length; i++){max = Math.max(max, arr[i]);min = Math.min(min, arr[i]);}//创建桶int bucketNum = (max - min) / arr.length + 1;ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = new ArrayList&lt;&gt;(bucketNum);for(int i = 0; i &lt; bucketNum; i++){bucketArr.add(new ArrayList&lt;Integer&gt;());}//将每个元素放入桶for(int i = 0; i &lt; arr.length; i++){int num = (arr[i] - min) / (arr.length);bucketArr.get(num).add(arr[i]);}//对每个桶进行排序for(int i = 0; i &lt; bucketArr.size(); i++){Collections.sort(bucketArr.get(i));}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="21-1-8-基数排序算法"><a href="#21-1-8-基数排序算法" class="headerlink" title="21.1.8 基数排序算法"></a>21.1.8 基数排序算法</h4><p>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class radixSort {inta[]={49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,101,56,17,18,23,34,15,35,25,53,51};public radixSort(){sort(a);for(inti=0;i&lt;a.length;i++){System.out.println(a[i]);} }public void sort(int[] array){//首先确定排序的趟数;int max=array[0];for(inti=1;i&lt;array.length;i++){if(array[i]&gt;max){max=array[i];} }int time=0;//判断位数;while(max&gt;0){max/=10;time++;}//建立 10 个队列;List&lt;ArrayList&gt; queue=newArrayList&lt;ArrayList&gt;();for(int i=0;i&lt;10;i++){ArrayList&lt;Integer&gt;queue1=new ArrayList&lt;Integer&gt;();queue.add(queue1);}//进行 time 次分配和收集;for(int i=0;i&lt;time;i++){//分配数组元素;for(intj=0;j&lt;array.length;j++){//得到数字的第 time+1 位数;int x=array[j]%(int)Math.pow(10,i+1)/(int)Math.pow(10, i);ArrayList&lt;Integer&gt;queue2=queue.get(x);queue2.add(array[j]);queue.set(x, queue2);}int count=0;//元素计数器;//收集队列元素;for(int k=0;k&lt;10;k++){while(queue.get(k).size()&gt;0){  ArrayList&lt;Integer&gt;queue3=queue.get(k);  array[count]=queue3.get(0);  queue3.remove(0);  count++;} } } } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="21-1-9-剪枝算法"><a href="#21-1-9-剪枝算法" class="headerlink" title="21.1.9 剪枝算法"></a>21.1.9 剪枝算法</h4><p>在搜索算法中优化中，剪枝，就是通过某种判断，避免一些不必要的遍历过程，形象的说，就是剪去了搜索树中的某些“枝条”，故称剪枝。应用剪枝优化的核心问题是设计剪枝判断方法，即确定哪些枝条应当舍弃，哪些枝条应当保留的方法。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/PruningAlgorithm.png"></p><h4 id="21-1-10-回溯算法"><a href="#21-1-10-回溯算法" class="headerlink" title="21.1.10 回溯算法"></a>21.1.10 回溯算法</h4><p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p><h4 id="21-1-11-最短路径算法"><a href="#21-1-11-最短路径算法" class="headerlink" title="21.1.11 最短路径算法"></a>21.1.11 最短路径算法</h4><p>从某顶点出发，沿图的边到达另一顶点所经过的路径中，各边上权值之和最小的一条路径叫做最短路径。解决最短路的问题有以下算法，Dijkstra 算法，Bellman-Ford 算法，Floyd 算法和 SPFA算法等。</p><h4 id="21-1-12-最大子数组算法"><a href="#21-1-12-最大子数组算法" class="headerlink" title="21.1.12 最大子数组算法"></a>21.1.12 最大子数组算法</h4><h4 id="21-1-13-最长公共子序算法"><a href="#21-1-13-最长公共子序算法" class="headerlink" title="21.1.13 最长公共子序算法"></a>21.1.13 最长公共子序算法</h4><h4 id="21-1-14-最小生成树算法"><a href="#21-1-14-最小生成树算法" class="headerlink" title="21.1.14 最小生成树算法"></a>21.1.14 最小生成树算法</h4><p>现在假设有一个很实际的问题：我们要在 n 个城市中建立一个通信网络，则连通这 n 个城市需要布置 n-1 一条通信线路，这个时候我们需要考虑如何在成本最低的情况下建立这个通信网？</p><p>于是我们就可以引入连通图来解决我们遇到的问题，n 个城市就是图上的 n 个顶点，然后，边表示两个城市的通信线路，每条边上的权重就是我们搭建这条线路所需要的成本，所以现在我们有 n 个顶点的连通网可以建立不同的生成树，每一颗生成树都可以作为一个通信网，当我们构造这个连通网所花的成本最小时，搭建该连通网的生成树，就称为最小生成树。1</p><p>构造最小生成树有很多算法，但是他们都是利用了最小生成树的同一种性质：MST 性质（假设N=(V,{E})是一个连通网，U 是顶点集 V 的一个非空子集，如果（u，v）是一条具有最小权值的边，其中 u 属于 U，v 属于 V-U，则必定存在一颗包含边（u，v）的最小生成树），下面就介绍两种使用 MST 性质生成最小生成树的算法：普里姆算法和克鲁斯卡尔算法。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/MinimumSpanningTreeAlgorithm.png"></p><h2 id="22-数据结构"><a href="#22-数据结构" class="headerlink" title="22. 数据结构"></a><strong>22. 数据结构</strong></h2><h4 id="22-1-1-栈（stack）"><a href="#22-1-1-栈（stack）" class="headerlink" title="22.1.1 栈（stack）"></a>22.1.1 栈（stack）</h4><p>栈（stack）是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫做栈顶（top）。它是后进先出（LIFO）的。对栈的基本操作只有 push（进栈）和 pop（出栈）两种，前者相当于插入，后者相当于删除最后的元素。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/StackStorageStructure.png"></p><h4 id="22-1-2-队列（queue）"><a href="#22-1-2-队列（queue）" class="headerlink" title="22.1.2 队列（queue）"></a>22.1.2 队列（queue）</h4><p>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/QueueStructure.png"></p><h4 id="22-1-3-链表（Link）"><a href="#22-1-3-链表（Link）" class="headerlink" title="22.1.3 链表（Link）"></a>22.1.3 链表（Link）</h4><p>链表是一种数据结构，和数组同级。比如，Java 中我们使用的 ArrayList，其实现原理是数组。而LinkedList 的实现原理就是链表了。链表在进行循环遍历时效率不高，但是插入和删除时优势明显。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/LinkStructure.png"></p><h4 id="22-1-4-散列表（Hash-Table）"><a href="#22-1-4-散列表（Hash-Table）" class="headerlink" title="22.1.4 散列表（Hash Table）"></a>22.1.4 散列表（Hash Table）</h4><p>散列表（Hash table，也叫哈希表）是一种查找算法，与链表、树等算法不同的是，散列表算法在查找时不需要进行一系列和关键字（关键字是数据元素中某个数据项的值，用以标识一个数据元素）的比较操作。</p><p><strong><em>散列表算法希望能尽量做到不经过任何比较，通过一次存取就能得到所查找的数据元素</em></strong>，因而必须要在数据元素的存储位置和它的关键字（可用 key 表示）之间建立一个确定的对应关系，使每个关键字和散列表中一个唯一的存储位置相对应。因此在查找时，只要根据这个对应关系找到给定关键字在散列表中的位置即可。这种对应关系被称为散列函数(可用 h(key)表示)。</p><p>用的构造散列函数的方法有：</p><p> （1）直接定址法： 取关键字或关键字的某个线性函数值为散列地址。</p><p>​            即：h(key) = key 或 h(key) = a * key + b，其中 a 和 b 为常数。</p><p> （2）数字分析法</p><p> （3）平方取值法： 取关键字平方后的中间几位为散列地址。</p><p> （4）折叠法：将关键字分割成位数相同的几部分，然后取这几部分的叠加和            作为散列地址。</p><p> （5）除留余数法：取关键字被某个不大于散列表表长 m 的数 p 除后所得的余            数为散列地址，即：h(key) = key MOD p p ≤ m </p><p> （6）随机数法：选择一个随机函数，取关键字的随机函数值为它的散列地址,            即：h(key) = random(key)</p><h4 id="22-1-5-排序二叉树"><a href="#22-1-5-排序二叉树" class="headerlink" title="22.1.5 排序二叉树"></a>22.1.5 排序二叉树</h4><p>首先如果普通二叉树每个节点满足：左子树所有节点值小于它的根节点值，且右子树所有节点值大于它的根节点值，则这样的二叉树就是排序二叉树。</p><h5 id="22-1-5-1-插入操作"><a href="#22-1-5-1-插入操作" class="headerlink" title="22.1.5.1 插入操作"></a>22.1.5.1 插入操作</h5><p>首先要从根节点开始往下找到自己要插入的位置（即新节点的父节点）；具体流程是：新节点与当前节点比较，如果相同则表示已经存在且不能再重复插入；如果小于当前节点，则到左子树中寻找，如果左子树为空则当前节点为要找的父节点，新节点插入到当前节点的左子树即可；如果大于当前节点，则到右子树中寻找，如果右子树为空则当前节点为要找的父节点，新节点插入到当前节点的右子树即可。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/InsertBinaryTree.png"></p><h5 id="22-1-5-2-删除操作"><a href="#22-1-5-2-删除操作" class="headerlink" title="22.1.5.2 删除操作"></a>22.1.5.2 删除操作</h5><p>删除操作主要分为三种情况，**<em>即要删除的节点无子节点，要删除的节点只有一个子节点，要删除的节点有两个子节点**</em>。</p><ol><li><p>对于要删除的节点无子节点可以直接删除，即让其父节点将该子节点置空即可。</p></li><li><p>对于要删除的节点只有一个子节点，则替换要删除的节点为其子节点。</p></li><li><p>对于要删除的节点有两个子节点，**<em>则首先找该节点的替换节点**</em>（即右子树中最小的节点），接着替换要删除的节点为替换节点，然后删除替换节点。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/DeleteTreeNode.png"></p></li></ol><h5 id="22-1-5-3-查询操作"><a href="#22-1-5-3-查询操作" class="headerlink" title="22.1.5.3 查询操作"></a>22.1.5.3 查询操作</h5><p>查找操作的主要流程为：先和根节点比较，如果相同就返回，**<em>如果小于根节点则到左子树中递归查找，如果大于根节点则到右子树中递归查找**</em>。因此在排序二叉树中可以很容易获取最大（最右最深子节点）和最小（最左最深子节点）值。</p><h4 id="22-1-6-红黑树"><a href="#22-1-6-红黑树" class="headerlink" title="22.1.6 红黑树"></a>22.1.6 红黑树</h4><p>R-B Tree，全称是 Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。</p><h5 id="22-1-6-1-红黑树的特性"><a href="#22-1-6-1-红黑树的特性" class="headerlink" title="22.1.6.1 红黑树的特性"></a>22.1.6.1 红黑树的特性</h5><p>（1）每个节点或者是黑色，或者是红色。</p><p>（2）根节点是黑色。</p><p>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL 或        NULL)的叶子节点！] </p><p>（4）如果一个节点是红色的，则它的子节点必须是黑色的。</p><p>（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p><h5 id="22-1-6-2-左旋"><a href="#22-1-6-2-左旋" class="headerlink" title="22.1.6.2 左旋"></a>22.1.6.2 左旋</h5><p>对 x 进行左旋，意味着，将“x 的右孩子”设为“x 的父亲节点”；即，将 x 变成了一个左节点(x成了为 z 的左孩子)！。 因此，左旋中的“左”，意味着“被旋转的节点将变成一个左节点”。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/NodeLeft-handed.png"></p><pre class="line-numbers language-text" data-language="text"><code class="language-text">LEFT-ROTATE(T, x) y ← right[x] // 前提：这里假设 x 的右孩子为 y。下面开始正式操作right[x] ← left[y] // 将 “y 的左孩子” 设为 “x 的右孩子”，即 将β设为 x 的右孩子p[left[y]] ← x // 将 “x” 设为 “y 的左孩子的父亲”，即 将β的父亲设为 xp[y] ← p[x] // 将 “x 的父亲” 设为 “y 的父亲”if p[x] = nil[T] then root[T] ← y // 情况 1：如果 “x 的父亲” 是空节点，则将 y 设为根节点else if x = left[p[x]] then left[p[x]] ← y // 情况 2：如果 x 是它父节点的左孩子，则将 y 设为“x 的父节点的左孩子”else right[p[x]] ← y // 情况 3：(x 是它父节点的右孩子) 将 y 设为“x 的父节点的右孩子”left[y] ← x // 将 “x” 设为 “y 的左孩子”p[x] ← y // 将 “x 的父节点” 设为 “y”<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/NodeLeft-handed2.png"></p><h5 id="22-1-6-3-右旋"><a href="#22-1-6-3-右旋" class="headerlink" title="22.1.6.3 右旋"></a>22.1.6.3 右旋</h5><p>对 x 进行右旋，意味着，将“x 的左孩子”设为“x 的父亲节点”；即，将 x 变成了一个右节点(x成了为 y 的右孩子)！ 因此，右旋中的“右”，意味着“被旋转的节点将变成一个右节点”。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/NodeRight-handed.png"></p><pre class="line-numbers language-text" data-language="text"><code class="language-text">RIGHT-ROTATE(T, y) x ← left[y] // 前提：这里假设 y 的左孩子为 x。下面开始正式操作left[y] ← right[x] // 将 “x 的右孩子” 设为 “y 的左孩子”，即 将β设为 y 的左孩子p[right[x]] ← y // 将 “y” 设为 “x 的右孩子的父亲”，即 将β的父亲设为 yp[x] ← p[y] // 将 “y 的父亲” 设为 “x 的父亲”if p[y] = nil[T] then root[T] ← x // 情况 1：如果 “y 的父亲” 是空节点，则将 x 设为根节点else if y = right[p[y]]  then right[p[y]] ← x // 情况 2：如果 y 是它父节点的右孩子，则将 x 设为“y 的父节点的左孩子” else left[p[y]] ← x // 情况 3：(y 是它父节点的左孩子) 将 x 设为“y 的父节点的左孩子”right[x] ← y // 将 “y” 设为 “x 的右孩子”p[y] ← x // 将 “y 的父节点” 设为 “x”<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="22-1-6-4-添加"><a href="#22-1-6-4-添加" class="headerlink" title="22.1.6.4 添加"></a>22.1.6.4 添加</h5><p>第一步: 将红黑树当作一颗二叉查找树，将节点插入。</p><p>第二步：将插入的节点着色为”红色”。</p><p>​    根据被插入节点的父节点的情况，可以将”当节点 z 被着色为红色节点，并插入二叉树”划分为三种情况来处理。</p><p>① 情况说明：被插入的节点是根节点。</p><p>处理方法：直接把此节点涂为黑色。</p><p>② 情况说明：被插入的节点的父节点是黑色。</p><p>处理方法：什么也不需要做。节点被插入后，仍然是红黑树。</p><p>③ 情况说明：被插入的节点的父节点是红色。这种情况下，被插入节点是一定存在非空祖父节点的；进一步的讲，被插入节点也一定存在叔叔节点(即使叔叔节点为空，我们也视之为存在，空节点本身就是黑色节点)。理解这点之后，我们依据”叔叔节点的情况”，将这种情况进一步划分为 3种情况(Case)。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/AddNode.png"></p><p>第三步: 通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。</p><h5 id="22-1-6-5-删除"><a href="#22-1-6-5-删除" class="headerlink" title="22.1.6.5 删除"></a>22.1.6.5 删除</h5><p>第一步：将红黑树当作一颗二叉查找树，将节点删除。</p><p>这和”删除常规二叉查找树中删除节点的方法是一样的”。分 3 种情况：</p><p>① 被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就 OK 了。</p><p>② 被删除节点只有一个儿子。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置。</p><p>③ 被删除节点有两个儿子。那么，先找出它的后继节点；然后把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。</p><p>第二步：通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。</p><p>因为”第一步”中删除节点之后，可能会违背红黑树的特性。所以需要通过”旋转和重新着色”来修正该树，使之重新成为一棵红黑树。</p><p>选择重着色 3 种情况。</p><p>① 情况说明：x 是“红+黑”节点。</p><p>处理方法：直接把 x 设为黑色，结束。此时红黑树性质全部恢复。</p><p>② 情况说明：x 是“黑+黑”节点，且 x 是根。</p><p>处理方法：什么都不做，结束。此时红黑树性质全部恢复。</p><p>③ 情况说明：x 是“黑+黑”节点，且 x 不是根。</p><p>处理方法：这种情况又可以划分为 4 种子情况。这 4 种子情况如下表所示：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/DeleteNode.png"></p><p>参考：<a href="https://www.jianshu.com/p/038585421b73">https://www.jianshu.com/p/038585421b73</a></p><p>代码实现：<a href="https://www.cnblogs.com/skywang12345/p/3624343.html">https://www.cnblogs.com/skywang12345/p/3624343.html</a></p><h4 id="22-1-7-B-TREE"><a href="#22-1-7-B-TREE" class="headerlink" title="22.1.7 B-TREE"></a>22.1.7 B-TREE</h4><p>B-tree 又叫平衡多路查找树。一棵 m 阶的 B-tree (m 叉树)的特性如下（其中 ceil(x)是一个取上限的函数）：</p><ol><li><p>树中每个结点至多有 m 个孩子；</p></li><li><p>除根结点和叶子结点外，其它每个结点至少有有 ceil(m / 2)个孩子；</p></li><li><p>若根结点不是叶子结点，则至少有 2 个孩子（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）；</p></li><li><p>所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部结点或查询失败的结点，实际上这些结点不存在，指向这些结点的指针都为 null)；</p></li><li><p>每个非终端结点中包含有 n 个关键字信息： (n，P0，K1，P1，K2，P2，……，Kn，Pn)。其中：</p><p>a) Ki (i=1…n)为关键字，且关键字按顺序排序 K(i-1)&lt; Ki。</p><p>b) Pi 为指向子树根的接点，且指针 P(i-1)指向子树种所有结点的关键字均小于 Ki，但都大于 K(i-1)。</p><p>c) 关键字的个数 n 必须满足： ceil(m / 2)-1 &lt;= n &lt;= m-1。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/B-TREE.png"></p></li></ol><p>一棵 m 阶的 B+tree 和 m 阶的 B-tree 的差异在于：</p><p>1.有 n 棵子树的结点中含有 n 个关键字； (B-tree 是 n 棵子树有 n-1 个关键字)</p><p>2.所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (B-tree 的叶子节点并没有包括全部需要查找的信息)</p><p>3.所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。</p><p>(B-tree 的非终节点也包含需要查找的有效信息)</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/B-TREE2.png"></p><p>参考：<a href="https://www.jianshu.com/p/1ed61b4cca12">https://www.jianshu.com/p/1ed61b4cca12</a></p><h4 id="22-1-8-位图"><a href="#22-1-8-位图" class="headerlink" title="22.1.8 位图"></a>22.1.8 位图</h4><p>位图的原理就是用一个 bit 来标识一个数字是否存在，采用一个 bit 来存储一个数据，所以这样可以大大的节省空间。 bitmap 是很常用的数据结构，比如用于 Bloom Filter 中；用于无重复整数的排序等等。bitmap 通常基于数组来实现，数组中每个元素可以看成是一系列二进制数，所有元素组成更大的二进制集合。</p><p><a href="https://www.cnblogs.com/polly333/p/4760275.html">https://www.cnblogs.com/polly333/p/4760275.html</a></p><h2 id="23-加密算法"><a href="#23-加密算法" class="headerlink" title="23. 加密算法"></a><strong>23. 加密算法</strong></h2><h4 id="23-1-1-AES"><a href="#23-1-1-AES" class="headerlink" title="23.1.1 AES"></a>23.1.1 AES</h4><p>高级加密标准(AES,Advanced Encryption Standard)为最常见的对称加密算法(微信小程序加密传输就是用这个加密算法的)。对称加密算法也就是加密和解密用相同的密钥，具体的加密流程如下图：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/AESEncryption.png"></p><h4 id="23-1-2-RSA"><a href="#23-1-2-RSA" class="headerlink" title="23.1.2 RSA"></a>23.1.2 RSA</h4><p>RSA 加密算法是一种典型的非对称加密算法，它基于大数的因式分解数学难题，它也是应用最广泛的非对称加密算法。</p><p>非对称加密是通过两个密钥（公钥-私钥）来实现对数据的加密和解密的。公钥用于加密，私钥用于解密。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/AsymmetricEncryptionAlgorithm.png"></p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/RSAEncryption.png"></p><h4 id="23-1-3-CRC"><a href="#23-1-3-CRC" class="headerlink" title="23.1.3 CRC"></a>23.1.3 CRC</h4><p>循环冗余校验(Cyclic Redundancy Check, CRC)是一种根据网络数据包或电脑文件等数据产生简短固定位数校验码的一种散列函数，主要用来检测或校验数据传输或者保存后可能出现的错误。它是利用除法及余数的原理来作错误侦测的。</p><h4 id="23-1-4-MD5"><a href="#23-1-4-MD5" class="headerlink" title="23.1.4 MD5"></a>23.1.4 MD5</h4><p>MD5 常常作为文件的签名出现，我们在下载文件的时候，常常会看到文件页面上附带一个扩展名为.MD5 的文本或者一行字符，这行字符就是就是把整个文件当作原数据通过 MD5 计算后的值，我们下载文件后，可以用检查文件 MD5 信息的软件对下载到的文件在进行一次计算。两次结果对比就可以确保下载到文件的准确性。 另一种常见用途就是网站敏感信息加密，比如用户名密码，支付签名等等。随着 https 技术的普及，现在的网站广泛采用前台明文传输到后台，MD5 加密（使用偏移量）的方式保护敏感数据保护站点和数据安全。</p><h2 id="24-分布式缓存"><a href="#24-分布式缓存" class="headerlink" title="24. 分布式缓存"></a><strong>24. 分布式缓存</strong></h2><h4 id="24-1-1-缓存雪崩"><a href="#24-1-1-缓存雪崩" class="headerlink" title="24.1.1 缓存雪崩"></a>24.1.1 缓存雪崩</h4><p>缓存雪崩我们可以简单的理解为：由于原有缓存失效，新缓存未到期间所有原本应该访问缓存的请求都去查询数据库了，而对数据库 CPU 和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。一般有三种处理办法：</p><ol><li><p>一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。</p></li><li><p>给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。</p></li><li><p>为 key 设置不同的缓存失效时间。</p></li></ol><h4 id="24-1-2-缓存穿透"><a href="#24-1-2-缓存穿透" class="headerlink" title="24.1.2 缓存穿透"></a>24.1.2 缓存穿透</h4><p>缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。</p><p>有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用*<strong>布隆过滤器**<em>，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法，</em></strong>如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了***，而不会继续访问数据库。</p><h4 id="24-1-3-缓存预热"><a href="#24-1-3-缓存预热" class="headerlink" title="24.1.3 缓存预热"></a>24.1.3 缓存预热</h4><p>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p><h4 id="24-1-4-缓存更新"><a href="#24-1-4-缓存更新" class="headerlink" title="24.1.4 缓存更新"></a>24.1.4 缓存更新</h4><p>缓存更新除了缓存服务器自带的缓存失效策略之外（Redis 默认的有 6 中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p><p>（1）定时去清理过期的缓存；</p><p>（2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</p><h4 id="24-1-5-缓存降级"><a href="#24-1-5-缓存降级" class="headerlink" title="24.1.5 缓存降级"></a>24.1.5 缓存降级</h4><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p><h2 id="25-Hadoop"><a href="#25-Hadoop" class="headerlink" title="25. Hadoop"></a><strong>25. Hadoop</strong></h2><h4 id="25-1-1-概念"><a href="#25-1-1-概念" class="headerlink" title="25.1.1 概念"></a>25.1.1 概念</h4><p>就是一个大数据解决方案。它提供了一套分布式系统基础架构。 核心内容包含 hdfs 和mapreduce。hadoop2.0 以后引入 yarn. </p><p>hdfs 是提供数据存储的，mapreduce 是方便数据计算的。</p><ol><li><p>hdfs 又对应 namenode 和 datanode. namenode 负责保存元数据的基本信息，datanode 直接存放数据本身；</p></li><li><p>mapreduce 对应 jobtracker 和 tasktracker. jobtracker 负责分发任务，tasktracker 负责执行具体任务；</p></li><li><p>对应到 master/slave 架构，namenode 和 jobtracker 就应该对应到 master, datanode和 tasktracker 就应该对应到 slave.</p></li></ol><h4 id="25-1-2-HDFS"><a href="#25-1-2-HDFS" class="headerlink" title="25.1.2 HDFS"></a>25.1.2 HDFS</h4><h5 id="25-1-2-1-Client"><a href="#25-1-2-1-Client" class="headerlink" title="25.1.2.1 Client"></a>25.1.2.1 Client</h5><p>Client（代表用 户） 通过与 NameNode 和 DataNode 交互访问 HDFS 中 的文件。 Client 提供了一个类似 POSIX 的文件系统接口供用户调用。</p><h5 id="25-1-2-2-NameNode"><a href="#25-1-2-2-NameNode" class="headerlink" title="25.1.2.2 NameNode"></a>25.1.2.2 NameNode</h5><p>整个 Hadoop 集群中只有一个 NameNode。 它是整个系统的“ 总管”， 负责管理 HDFS 的目录树和相关的文件元数据信息。 这些信息是以“ fsimage”（ HDFS 元数据镜像文件）和“ editlog”（HDFS 文件改动日志）两个文件形式存放在本地磁盘，当 HDFS 重启时重新构造出来的。此外， NameNode 还负责监控各个 DataNode 的健康状态， 一旦发现某个 DataNode 宕掉，则将该 DataNode 移出 HDFS 并重新备份其上面的数据。</p><h5 id="25-1-2-3-Secondary-NameNode"><a href="#25-1-2-3-Secondary-NameNode" class="headerlink" title="25.1.2.3 Secondary NameNode"></a>25.1.2.3 Secondary NameNode</h5><p>Secondary NameNode 最重要的任务并不是为 NameNode 元数据进行热备份， 而是定期合并fsimage 和 edits 日志， 并传输给 NameNode。 这里需要注意的是，为了减小 NameNode 压力， NameNode 自己并不会合并 fsimage 和 edits， 并将文件存储到磁盘上， 而是交由Secondary NameNode 完成。</p><h5 id="25-1-2-4-DataNode"><a href="#25-1-2-4-DataNode" class="headerlink" title="25.1.2.4 DataNode"></a>25.1.2.4 DataNode</h5><p>一般而言， 每个 Slave 节点上安装一个 DataNode， 它负责实际的数据存储， 并将数据信息定期汇报给 NameNode。 DataNode 以固定大小的 block 为基本单位组织文件内容， 默认情况下block 大小为 64MB。 当用户上传一个大的文件到 HDFS 上时， 该文件会被切分成若干个 block，分别存储到不同的 DataNode ； 同时，为了保证数据可靠， 会将同一个 block 以流水线方式写到若干个（默认是 3，该参数可配置）不同的 DataNode 上。 这种文件切割后存储的过程是对用户透明的。</p><h4 id="25-1-3-MapReduce"><a href="#25-1-3-MapReduce" class="headerlink" title="25.1.3 MapReduce"></a>25.1.3 MapReduce</h4><p>同 HDFS 一样，Hadoop MapReduce 也采用了 Master/Slave（M/S）架构，具体如图所示。它主要由以下几个组件组成：Client、JobTracker、TaskTracker 和 Task。 下面分别对这几个组件进行介绍。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/HadoopMapReduceArchitecture.png"></p><h5 id="25-1-3-1-Client"><a href="#25-1-3-1-Client" class="headerlink" title="25.1.3.1 Client"></a>25.1.3.1 Client</h5><p>用户编写的 MapReduce 程序通过 Client 提交到 JobTracker 端； 同时， 用户可通过 Client 提供的一些接口查看作业运行状态。 在 Hadoop 内部用“作业”（Job） 表示 MapReduce 程序。一个 MapReduce 程序可对应若干个作业，而每个作业会被分解成若干个 Map/Reduce 任务（Task）。</p><h5 id="25-1-3-2-JobTracker"><a href="#25-1-3-2-JobTracker" class="headerlink" title="25.1.3.2  JobTracker"></a>25.1.3.2  JobTracker</h5><p>JobTracker 主要负责资源监控和作业调度。JobTracker 监控所有 TaskTracker 与作业的健康状况，一旦发现失败情况后，其会将相应的任务转移到其他节点；同时 JobTracker 会跟踪任务的执行进度、资源使用量等信息，并将这些信息告诉任务调度器，而调度器会在资源出现空闲时，选择合适的任务使用这些资源。在 Hadoop 中，任务调度器是一个可插拔的模块，用户可以根据自己的需要设计相应的调度器。</p><h5 id="25-1-3-3-TaskTracker"><a href="#25-1-3-3-TaskTracker" class="headerlink" title="25.1.3.3 TaskTracker"></a>25.1.3.3 TaskTracker</h5><p>TaskTracker 会周期性地通过 Heartbeat 将本节点上资源的使用情况和任务的运行进度汇报给JobTracker， 同时接收 JobTracker 发送过来的命令并执行相应的操作（如启动新任务、 杀死任务等）。TaskTracker 使用“slot” 等量划分本节点上的资源量。“slot” 代表计算资源（CPU、内存等）。一个 Task 获取到一个 slot 后才有机会运行，而 Hadoop 调度器的作用就是将各个TaskTracker 上的空闲 slot 分配给 Task 使用。 slot 分为 Map slot 和 Reduce slot 两种，分别供MapTask 和 Reduce Task 使用。 TaskTracker 通过 slot 数目（可配置参数）限定 Task 的并发度。</p><h5 id="25-1-3-4-Task"><a href="#25-1-3-4-Task" class="headerlink" title="25.1.3.4 Task"></a>25.1.3.4 Task</h5><p>Task 分为 Map Task 和 Reduce Task 两种， 均由 TaskTracker 启动。 HDFS 以固定大小的 block 为基本单位存储数据， 而对于 MapReduce 而言， 其处理单位是 split。split 与 block 的对应关系如图所示。 split 是一个逻辑概念， 它只包含一些元数据信息， 比如数据起始位置、数据长度、数据所在节点等。它的划分方法完全由用户自己决定。 但需要注意的是，split 的多少决定了 Map Task 的数目 ，因为每个 split 会交由一个 Map Task 处理。</p><p>Map Task 执行过程如图所示。 由该图可知，Map Task 先将对应的 split 迭代解析成一个个key/value 对，依次调用用户自定义的 map() 函数进行处理，最终将临时结果存放到本地磁盘上，其中临时数据被分成若干个 partition，每个 partition 将被一个 Reduce Task 处理。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/MapTaskProcess.png"></p><h5 id="25-1-3-5-Reduce-Task-执行过程"><a href="#25-1-3-5-Reduce-Task-执行过程" class="headerlink" title="25.1.3.5 Reduce Task 执行过程"></a>25.1.3.5 Reduce Task 执行过程</h5><p>该过程分为三个阶段</p><ol><li><p>从远程节点上读取 MapTask 中间结果（称为“Shuffle 阶段”）；</p></li><li><p>按照 key 对 key/value 对进行排序（称为“ Sort 阶段”）；</p></li><li><p>依次读取&lt;key, value list&gt;，调用用户自定义的 reduce() 函数处理，并将最终结果存到 HDFS 上（称为“ Reduce 阶段”）。</p></li></ol><h4 id="25-1-4-Hadoop-MapReduce-作业的生命周期"><a href="#25-1-4-Hadoop-MapReduce-作业的生命周期" class="headerlink" title="25.1.4 Hadoop MapReduce 作业的生命周期"></a>25.1.4 Hadoop MapReduce 作业的生命周期</h4><p><strong><em>1.作业提交与初始化</em></strong></p><ol><li>用户提交作业后， 首先由 JobClient 实例将作业相关信息， 比如将程序 jar 包、作业配置文件、 分片元信息文件等上传到分布式文件系统（ 一般为 HDFS）上，其中，分片元信息文件记录了每个输入分片的逻辑位置信息。 然后 JobClient 通过 RPC 通知 JobTracker。JobTracker 收到新作业提交请求后， 由 作业调度模块对作业进行初始化：为作业创建一个JobInProgress 对象以跟踪作业运行状况， 而 JobInProgress 则会为每个 Task 创建一个TaskInProgress 对象以跟踪每个任务的运行状态， TaskInProgress 可能需要管理多个“ Task 运行尝试”（ 称为“ Task Attempt”）。</li></ol><p><strong><em>2.任务调度与监控。</em></strong></p><ol start="2"><li>前面提到，任务调度和监控的功能均由 JobTracker 完成。TaskTracker 周期性地通过Heartbeat 向 JobTracker 汇报本节点的资源使用 情况， 一旦出 现空闲资源， JobTracker 会按照一定的策略选择一个合适的任务使用该空闲资源， 这由任务调度器完成。 任务调度器是一个可插拔的独立模块， 且为双层架构， 即首先选择作业， 然后从该作业中选择任务， 其中，选择任务时需要重点考虑数据本地性。 此外，JobTracker 跟踪作业的整个运行过程，并为作业的成功运行提供全方位的保障。 首先， 当 TaskTracker 或者 Task 失败时， 转移计算任务 ； 其次， 当某个 Task 执行进度远落后于同一作业的其他 Task 时，为之启动一个相同Task， 并选取计算快的 Task 结果作为最终结果。</li></ol><p><strong><em>3.任务运行环境准备</em></strong></p><ol start="3"><li>运行环境准备包括 JVM 启动和资源隔 离， 均由 TaskTracker 实现。 TaskTracker 为每个Task 启动一个独立的 JVM 以避免不同 Task 在运行过程中相互影响 ； 同时，TaskTracker 使用了操作系统进程实现资源隔离以防止 Task 滥用资源。</li></ol><p><strong><em>4.任务执行</em></strong></p><ol start="4"><li>TaskTracker 为 Task 准备好运行环境后， 便会启动 Task。 在运行过程中， 每个 Task 的最新进度首先由 Task 通过 RPC 汇报给 TaskTracker， 再由 TaskTracker 汇报给 JobTracker。</li></ol><p><strong><em>5.作业完成。</em></strong></p><ol start="5"><li>待所有 Task 执行完毕后， 整个作业执行成功。</li></ol><h2 id="26-Spark"><a href="#26-Spark" class="headerlink" title="26. Spark"></a><strong>26. Spark</strong></h2><h4 id="26-1-1-概念"><a href="#26-1-1-概念" class="headerlink" title="26.1.1 概念"></a>26.1.1 概念</h4><p>Spark 提供了一个全面、统一的框架用于管理各种有着不同性质（文本数据、图表数据等）的数据集和数据源（批量数据或实时的流数据）的大数据处理的需求。</p><h4 id="26-1-2-核心架构"><a href="#26-1-2-核心架构" class="headerlink" title="26.1.2 核心架构"></a>26.1.2 核心架构</h4><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/SparkCoreArchitecture.png"></p><p><strong>Spark Core</strong></p><p>包含 Spark 的基本功能；尤其是定义 RDD 的 API、操作以及这两者上的动作。其他 Spark 的库都是构建在 RDD 和 Spark Core 之上的</p><p><strong>Spark SQL</strong></p><p>提供通过 Apache Hive 的 SQL 变体 Hive 查询语言（HiveQL）与 Spark 进行交互的 API。每个数据库表被当做一个 RDD，Spark SQL 查询被转换为 Spark 操作。</p><p><strong>Spark Streaming</strong></p><p>对实时数据流进行处理和控制。Spark Streaming 允许程序能够像普通 RDD 一样处理实时数据</p><p><strong>Mllib</strong></p><p>一个常用机器学习算法库，算法被实现为对 RDD 的 Spark 操作。这个库包含可扩展的学习算法，比如分类、回归等需要对大量数据集进行迭代的操作。</p><p><strong>GraphX</strong></p><p>控制图、并行图操作和计算的一组算法和工具的集合。GraphX 扩展了 RDD API，包含控制图、创建子图、访问路径上所有顶点的操作。</p><h4 id="26-1-3-核心组件"><a href="#26-1-3-核心组件" class="headerlink" title="26.1.3 核心组件"></a>26.1.3 核心组件</h4><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/SparkCoreComponents.png"></p><p><strong><em>Cluster Manager-制整个集群，监控 worker</em></strong></p><p>在 standalone 模式中即为 Master 主节点，控制整个集群，监控 worker。在 YARN 模式中为资源管理器</p><p><strong><em>Worker 节点-负责控制计算节点</em></strong></p><p>从节点，负责控制计算节点，启动 Executor 或者 Driver。</p><p><strong><em>Driver： 运行 Application 的 main()函数</em></strong></p><p><strong><em>Executor：执行器，是为某个 Application 运行在 worker node 上的一个进程</em></strong></p><h4 id="26-1-4-SPARK-编程模型"><a href="#26-1-4-SPARK-编程模型" class="headerlink" title="26.1.4 SPARK 编程模型"></a>26.1.4 SPARK 编程模型</h4><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/SparkProgrammingModel.png"></p><p>Spark 应用程序从编写到提交、执行、输出的整个过程如图所示，图中描述的步骤如下：</p><ol><li><p>用户使用 SparkContext 提供的 API（常用的有 textFile、sequenceFile、runJob、stop 等）编写 Driver application 程序。此外 SQLContext、HiveContext 及 StreamingContext 对SparkContext 进行封装，并提供了 SQL、Hive 及流式计算相关的 API。</p></li><li><p>使用SparkContext提交的用户应用程序，首先会使用BlockManager和BroadcastManager将任务的 Hadoop 配置进行广播。然后由 DAGScheduler 将任务转换为 RDD 并组织成 DAG，DAG 还将被划分为不同的 Stage。最后由 TaskScheduler 借助 ActorSystem 将任务提交给集群管理器（Cluster Manager）。</p></li><li><p>集群管理器（ClusterManager）给任务分配资源，即将具体任务分配到Worker上，Worker创建 Executor 来处理任务的运行。Standalone、YARN、Mesos、EC2 等都可以作为 Spark的集群管理器。</p></li></ol><h4 id="26-1-5-SPARK-计算模型"><a href="#26-1-5-SPARK-计算模型" class="headerlink" title="26.1.5 SPARK 计算模型"></a>26.1.5 SPARK 计算模型</h4><p>RDD 可以看做是对各种数据计算模型的统一抽象，Spark 的计算过程主要是 RDD 的迭代计算过程。RDD 的迭代计算过程非常类似于管道。分区数量取决于 partition 数量的设定，每个分区的数据只会在一个 Task 中计算。所有分区可以在多个机器节点的 Executor 上并行执行。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/SparkCalculationModel.png"></p><h4 id="26-1-6-SPARK-运行流程"><a href="#26-1-6-SPARK-运行流程" class="headerlink" title="26.1.6 SPARK 运行流程"></a>26.1.6 SPARK 运行流程</h4><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/SparkRunningProcess.png"></p><p><strong><em>1.构建 Spark Application 的运行环境，启动 SparkContext</em></strong></p><p><strong><em>2. SparkContext 向资源管理器（可以是 Standalone，Mesos，Yarn）申请运行 Executor 资源，并启动 StandaloneExecutorbackend</em></strong></p><p><strong><em>3. Executor 向 SparkContext 申请 Task</em></strong></p><p><strong><em>4. SparkContext 将应用程序分发给 Executor</em></strong></p><p><strong><em>5. SparkContext 构建成 DAG 图，将 DAG 图分解成 Stage、将 Taskset 发送给 Task Scheduler，最后由 Task Scheduler 将 Task 发送给 Executor 运行</em></strong></p><p><strong><em>6. Task 在 Executor 上运行，运行完释放所有资源</em></strong></p><h4 id="26-1-7-SPARK-RDD-流程"><a href="#26-1-7-SPARK-RDD-流程" class="headerlink" title="26.1.7 SPARK RDD 流程"></a>26.1.7 SPARK RDD 流程</h4><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/SparkRDDProcess.png"></p><ol><li><p>创建 RDD 对象</p></li><li><p>DAGScheduler 模块介入运算，计算 RDD 之间的依赖关系，RDD 之间的依赖关系就形成了DAG</p></li><li><p>每一个 Job 被分为多个 Stage。划分 Stage 的一个主要依据是当前计算因子的输入是否是确定的，如果是则将其分在同一个 Stage，避免多个 Stage 之间的消息传递开销</p></li></ol><h4 id="26-1-8-SPARK-RDD"><a href="#26-1-8-SPARK-RDD" class="headerlink" title="26.1.8 SPARK RDD"></a>26.1.8 SPARK RDD</h4><p><strong>（1）RDD 的创建方式</strong></p><p> 1）从 Hadoop 文件系统（或与Hadoop兼容的其他持久化存储系统，如Hive、Cassandra、HBase）输入（例如 HDFS）创建。</p><p> 2）从父 RDD 转换得到新 RDD。</p><p> 3）通过 parallelize 或 makeRDD 将单机数据创建为分布式 RDD。</p><p> <strong>（2）RDD 的两种操作算子（转换（Transformation）与行动（Action））</strong></p><p> 对于 RDD 可以有两种操作算子：转换（Transformation）与行动（Action）。</p><p>1）转换（Transformation）：Transformation操作是延迟计算的，也就是说从一个RDD转换生成另一个 RDD 的转换操作不是马上执行，需要等到有 Action 操作的时候才会真正触发运算。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/RDDTransformation.png"></p><p> 2）行动（Action）：Action 算子会触发 Spark 提交作业（Job），并将数据输出 Spark 系统。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/RDDAction.png"></p><h2 id="27-Storm"><a href="#27-Storm" class="headerlink" title="27. Storm"></a><strong>27. Storm</strong></h2><p><strong>概念</strong></p><p>Storm 是一个免费并开源的分布式实时计算系统。利用 Storm 可以很容易做到可靠地处理无限的数据流，像 Hadoop 批量处理大数据一样，Storm 可以实时处理数据。</p><h4 id="27-1-1-集群架构"><a href="#27-1-1-集群架构" class="headerlink" title="27.1.1 集群架构"></a>27.1.1 集群架构</h4><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/StormClusterArchitecture.png"></p><h5 id="27-1-1-1-Nimbus（master-代码分发给-Supervisor）"><a href="#27-1-1-1-Nimbus（master-代码分发给-Supervisor）" class="headerlink" title="27.1.1.1 Nimbus（master-代码分发给 Supervisor）"></a>27.1.1.1 Nimbus（master-代码分发给 Supervisor）</h5><p>Storm 集群的 Master 节点，负责分发用户代码，指派给具体的 Supervisor 节点上的 Worker 节点，去运行 Topology 对应的组件（Spout/Bolt）的 Task。</p><h5 id="27-1-1-2-Supervisor（slave-管理-Worker-进程的启动和终止）"><a href="#27-1-1-2-Supervisor（slave-管理-Worker-进程的启动和终止）" class="headerlink" title="27.1.1.2 Supervisor（slave-管理 Worker 进程的启动和终止）"></a>27.1.1.2 Supervisor（slave-管理 Worker 进程的启动和终止）</h5><p>Storm 集群的从节点，负责管理运行在 Supervisor 节点上的每一个 Worker 进程的启动和终止。通过 Storm 的配置文件中的 supervisor.slots.ports 配置项，可以指定在一个 Supervisor 上最大允许多少个 Slot，每个 Slot 通过端口号来唯一标识，一个端口号对应一个 Worker 进程（如果该Worker 进程被启动）。</p><h5 id="27-1-1-3-Worker（具体处理组件逻辑的进程）"><a href="#27-1-1-3-Worker（具体处理组件逻辑的进程）" class="headerlink" title="27.1.1.3 Worker（具体处理组件逻辑的进程）"></a>27.1.1.3 Worker（具体处理组件逻辑的进程）</h5><p>运行具体处理组件逻辑的进程。Worker 运行的任务类型只有两种，一种是 Spout 任务，一种是Bolt 任务。</p><h5 id="27-1-1-4-Task"><a href="#27-1-1-4-Task" class="headerlink" title="27.1.1.4 Task"></a>27.1.1.4 Task</h5><p>worker中每一个spout/bolt的线程称为一个task. 在storm0.8 之后，task不再与物理线程对应，不同 spout/bolt 的 task 可能会共享一个物理线程，该线程称为 executor。</p><h5 id="27-1-1-5-ZooKeeper"><a href="#27-1-1-5-ZooKeeper" class="headerlink" title="27.1.1.5 ZooKeeper"></a>27.1.1.5 ZooKeeper</h5><p>用来协调 Nimbus 和 Supervisor，如果 Supervisor 因故障出现问题而无法运行 Topology，Nimbus 会第一时间感知到，并重新分配 Topology 到其它可用的 Supervisor 上运行</p><h4 id="27-1-2-编程模型（spout-gt-tuple-gt-bolt）"><a href="#27-1-2-编程模型（spout-gt-tuple-gt-bolt）" class="headerlink" title="27.1.2 编程模型（spout->tuple->bolt）"></a>27.1.2 编程模型（spout-&gt;tuple-&gt;bolt）</h4><p>strom 在运行中可分为 spout 与 bolt 两个组件，其中，数据源从 spout 开始，数据以 tuple 的方式发送到 bolt，多个 bolt 可以串连起来，一个 bolt 也可以接入多个 spot/bolt.运行时原理如下图：</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/ProgrammingModel.png"></p><h5 id="27-1-2-1-Topology"><a href="#27-1-2-1-Topology" class="headerlink" title="27.1.2.1 Topology"></a>27.1.2.1 Topology</h5><p>Storm 中运行的一个实时应用程序的名称。将 Spout、 Bolt 整合起来的拓扑图。定义了 Spout 和Bolt 的结合关系、并发数量、配置等等。</p><h5 id="27-1-2-2-Spout"><a href="#27-1-2-2-Spout" class="headerlink" title="27.1.2.2 Spout"></a>27.1.2.2 Spout</h5><p>在一个 topology 中获取源数据流的组件。通常情况下 spout 会从外部数据源中读取数据，然后转换为 topology 内部的源数据。</p><h5 id="27-1-2-3-Bolt"><a href="#27-1-2-3-Bolt" class="headerlink" title="27.1.2.3 Bolt"></a>27.1.2.3 Bolt</h5><p>接受数据然后执行处理的组件,用户可以在其中执行自己想要的操作。</p><h5 id="27-1-2-4-Tuple"><a href="#27-1-2-4-Tuple" class="headerlink" title="27.1.2.4 Tuple"></a>27.1.2.4 Tuple</h5><p>一次消息传递的基本单元，理解为一组消息就是一个 Tuple。</p><h5 id="27-1-2-5-Stream"><a href="#27-1-2-5-Stream" class="headerlink" title="27.1.2.5 Stream"></a>27.1.2.5 Stream</h5><p>Tuple 的集合。表示数据的流向。</p><h4 id="27-1-3-Topology-运行"><a href="#27-1-3-Topology-运行" class="headerlink" title="27.1.3 Topology 运行"></a>27.1.3 Topology 运行</h4><p>在 Storm 中,一个实时应用的计算任务被打包作为 Topology 发布，这同 Hadoop MapReduce任务相似。但是有一点不同的是:在 Hadoop 中，MapReduce 任务最终会执行完成后结束；而在Storm 中，Topology 任务一旦提交后永远不会结束，除非你显示去停止任务。计算任务Topology 是由不同的 Spouts 和 Bolts，通过数据流（Stream）连接起来的图｡一个 Storm 在集群上运行一个 Topology 时，主要通过以下 3 个实体来完成 Topology 的执行工作：</p><p><strong>(1). Worker（进程）</strong></p><p><strong>(2). Executor（线程）</strong></p><p><strong>(3). Task</strong></p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/TopologyRunning.png"></p><h5 id="27-1-3-1-Worker-1-个-worker-进程执行的是-1-个-topology-的子集"><a href="#27-1-3-1-Worker-1-个-worker-进程执行的是-1-个-topology-的子集" class="headerlink" title="27.1.3.1 Worker(1 个 worker 进程执行的是 1 个 topology 的子集)"></a>27.1.3.1 Worker(1 个 worker 进程执行的是 1 个 topology 的子集)</h5><p>1 个 worker 进程执行的是 1 个 topology 的子集（注：不会出现 1 个 worker 为多个 topology服务）。1 个 worker 进程会启动 1 个或多个 executor 线程来执行 1 个 topology 的component(spout 或 bolt)。因此，1 个运行中的 topology 就是由集群中多台物理机上的多个worker 进程组成的。</p><h5 id="27-1-3-2-Executor-executor-是-1-个被-worker-进程启动的单独线程"><a href="#27-1-3-2-Executor-executor-是-1-个被-worker-进程启动的单独线程" class="headerlink" title="27.1.3.2 Executor(executor 是 1 个被 worker 进程启动的单独线程)"></a>27.1.3.2 Executor(executor 是 1 个被 worker 进程启动的单独线程)</h5><p>executor 是 1 个被 worker 进程启动的单独线程。每个 executor 只会运行 1 个 topology 的 1 个component(spout 或 bolt)的 task（注：task 可以是 1 个或多个，storm 默认是 1 个component 只生成 1 个 task，executor 线程里会在每次循环里顺序调用所有 task 实例）。</p><h5 id="27-1-3-3-Task-最终运行-spout-或-bolt-中代码的单元"><a href="#27-1-3-3-Task-最终运行-spout-或-bolt-中代码的单元" class="headerlink" title="27.1.3.3 Task(最终运行 spout 或 bolt 中代码的单元)"></a>27.1.3.3 Task(最终运行 spout 或 bolt 中代码的单元)</h5><p>是最终运行 spout 或 bolt 中代码的单元（注：1 个 task 即为 spout 或 bolt 的 1 个实例，executor 线程在执行期间会调用该 task 的 nextTuple 或 execute 方法）。topology 启动后，1 个 component(spout 或 bolt)的 task 数目是固定不变的，但该 component 使用的 executor 线程数可以动态调整（例如：1 个 executor 线程可以执行该 component 的 1 个或多个 task 实例）。这意味着，对于 1 个 component 存在这样的条件：#threads&lt;=#tasks（即：线程数小于等于 task 数目）。默认情况下 task 的数目等于 executor 线程数目，即 1 个 executor 线程只运行 1 个 task。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/TaskSpoutBolt.png"></p><h4 id="27-1-4-Storm-Streaming-Grouping"><a href="#27-1-4-Storm-Streaming-Grouping" class="headerlink" title="27.1.4 Storm Streaming Grouping"></a>27.1.4 Storm Streaming Grouping</h4><p>Storm 中最重要的抽象，应该就是 Stream grouping 了，它能够控制 Spot/Bolt 对应的 Task 以什么样的方式来分发 Tuple，将 Tuple 发射到目的 Spot/Bolt 对应的 Task.</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/StormStreamingGrouping.png"></p><p>目前，Storm Streaming Grouping 支持如下几种类型：</p><h5 id="27-1-4-1-huffle-Grouping"><a href="#27-1-4-1-huffle-Grouping" class="headerlink" title="27.1.4.1 huffle Grouping"></a>27.1.4.1 huffle Grouping</h5><p>随机分组，尽量均匀分布到下游 Bolt 中将流分组定义为混排。这种混排分组意味着来自 Spout 的输入将混排，或随机分发给此 Bolt 中的任务。shuffle grouping 对各个 task 的 tuple 分配的比较均匀。</p><h5 id="27-1-4-2-Fields-Grouping"><a href="#27-1-4-2-Fields-Grouping" class="headerlink" title="27.1.4.2 Fields Grouping"></a>27.1.4.2 Fields Grouping</h5><p>按字段分组，按数据中 field 值进行分组；相同 field 值的 Tuple 被发送到相同的 Task 这种grouping 机制保证相同 field 值的 tuple 会去同一个 task。</p><h5 id="27-1-4-3-All-grouping-：广播"><a href="#27-1-4-3-All-grouping-：广播" class="headerlink" title="27.1.4.3 All grouping ：广播"></a>27.1.4.3 All grouping ：广播</h5><p>广播发送， 对于每一个 tuple 将会复制到每一个 bolt 中处理。</p><h5 id="27-1-4-4-Global-grouping"><a href="#27-1-4-4-Global-grouping" class="headerlink" title="27.1.4.4 Global grouping"></a>27.1.4.4 Global grouping</h5><p>全局分组，Tuple 被分配到一个 Bolt 中的一个 Task，实现事务性的 Topology。Stream 中的所有的 tuple 都会发送给同一个 bolt 任务处理，所有的 tuple 将会发送给拥有最小 task_id 的 bolt任务处理。</p><h5 id="27-1-4-5-None-grouping-：不分组"><a href="#27-1-4-5-None-grouping-：不分组" class="headerlink" title="27.1.4.5 None grouping ：不分组"></a>27.1.4.5 None grouping ：不分组</h5><p>不关注并行处理负载均衡策略时使用该方式，目前等同于 shuffle grouping,另外 storm 将会把bolt 任务和他的上游提供数据的任务安排在同一个线程下。</p><h5 id="27-1-4-6-Direct-grouping-：直接分组-指定分组"><a href="#27-1-4-6-Direct-grouping-：直接分组-指定分组" class="headerlink" title="27.1.4.6. Direct grouping ：直接分组 指定分组"></a>27.1.4.6. Direct grouping ：直接分组 指定分组</h5><p>由 tuple 的发射单元直接决定 tuple 将发射给那个 bolt，一般情况下是由接收 tuple 的 bolt 决定接收哪个 bolt 发射的 Tuple。这是一种比较特别的分组方法，用这种分组意味着消息的发送者指定由消息接收者的哪个 task 处理这个消息。 只有被声明为 Direct Stream 的消息流可以声明这种分组方法。而且这种消息 tuple 必须使用 emitDirect 方法来发射。消息处理者可以通过TopologyContext 来获取处理它的消息的 taskid (OutputCollector.emit 方法也会返回taskid)。</p><h2 id="28-YARN"><a href="#28-YARN" class="headerlink" title="28. YARN"></a><strong>28. YARN</strong></h2><h4 id="28-1-1-概念"><a href="#28-1-1-概念" class="headerlink" title="28.1.1 概念"></a>28.1.1 概念</h4><p>YARN 是一个资源管理、任务调度的框架，主要包含三大模块：ResourceManager（RM）、NodeManager（NM）、ApplicationMaster（AM）。其中，ResourceManager 负责所有资源的监控、分配和管理； ApplicationMaster 负责每一个具体应用程序的调度和协调；NodeManager 负责每一个节点的维护。对于所有的 applications，RM 拥有绝对的控制权和对资源的分配权。而每个 AM 则会和 RM 协商资源，同时和 NodeManager 通信来执行和监控 task。</p><p>几个模块之间的关系如图所示。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/YARNRelationshipBetweenModules.png"></p><h4 id="28-1-2-ResourceManager"><a href="#28-1-2-ResourceManager" class="headerlink" title="28.1.2 ResourceManager"></a>28.1.2 ResourceManager</h4><ol><li><p>ResourceManager 负责整个集群的资源管理和分配，是一个全局的资源管理系统。</p></li><li><p>NodeManager 以心跳的方式向 ResourceManager 汇报资源使用情况（目前主要是 CPU 和内存的使用情况）。RM 只接受 NM 的资源回报信息，对于具体的资源处理则交给 NM 自己处理。</p></li><li><p>YARN Scheduler 根据 application 的请求为其分配资源，不负责 application job 的监控、追踪、运行状态反馈、启动等工作。</p></li></ol><h4 id="28-1-3-NodeManager"><a href="#28-1-3-NodeManager" class="headerlink" title="28.1.3 NodeManager"></a>28.1.3 NodeManager</h4><ol><li><p>NodeManager 是每个节点上的资源和任务管理器，它是管理这台机器的代理，负责该节点程序的运行，以及该节点资源的管理和监控。YARN集群每个节点都运行一个NodeManager。</p></li><li><p>NodeManager 定时向 ResourceManager 汇报本节点资源（CPU、内存）的使用情况和Container 的运行状态。当 ResourceManager 宕机时 NodeManager 自动连接 RM 备用节点。</p></li><li><p>NodeManager 接收并处理来自 ApplicationMaster 的 Container 启动、停止等各种请求。</p></li></ol><h4 id="28-1-4-ApplicationMaster"><a href="#28-1-4-ApplicationMaster" class="headerlink" title="28.1.4 ApplicationMaster"></a>28.1.4 ApplicationMaster</h4><p>用户提交的每个应用程序均包含一个 ApplicationMaster，它可以运行在 ResourceManager 以外的机器上。</p><ol><li><p>负责与 RM 调度器协商以获取资源（用 Container 表示）。</p></li><li><p>将得到的任务进一步分配给内部的任务(资源的二次分配)。</p></li><li><p>与 NM 通信以启动/停止任务。</p></li><li><p>监控所有任务运行状态，并在任务运行失败时重新为任务申请资源以重启任务。</p></li><li><p>当前 YARN 自带了两个 ApplicationMaster 实现，一个是用于演示 AM 编写方法的实例程序DistributedShell，它可以申请一定数目的 Container 以并行运行一个 Shell 命令或者 Shell脚本；另一个是运行 MapReduce 应用程序的 AM—MRAppMaster。</p></li></ol><p>注：RM 只负责监控 AM，并在 AM 运行失败时候启动它。RM 不负责 AM 内部任务的容错，任务的容错由 AM 完成。</p><h4 id="28-1-5-YARN-运行流程"><a href="#28-1-5-YARN-运行流程" class="headerlink" title="28.1.5  YARN 运行流程"></a>28.1.5  YARN 运行流程</h4><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/YARNRunningProcess.png"></p><ol><li><p>client 向 RM 提交应用程序，其中包括启动该应用的 ApplicationMaster 的必须信息，例如ApplicationMaster 程序、启动 ApplicationMaster 的命令、用户程序等。</p></li><li><p>ResourceManager 启动一个 container 用于运行 ApplicationMaster。</p></li><li><p>启动中的ApplicationMaster向ResourceManager注册自己，启动成功后与RM保持心跳。</p></li><li><p>ApplicationMaster 向 ResourceManager 发送请求，申请相应数目的 container。</p></li><li><p>ResourceManager 返回 ApplicationMaster 的申请的 containers 信息。申请成功的container，由 ApplicationMaster 进行初始化。container 的启动信息初始化后，AM 与对应的 NodeManager 通信，要求 NM 启动 container。AM 与 NM 保持心跳，从而对 NM 上运行的任务进行监控和管理。</p></li><li><p>container 运行期间，ApplicationMaster 对 container 进行监控。container 通过 RPC 协议向对应的 AM 汇报自己的进度和状态等信息。</p></li><li><p>应用运行期间，client 直接与 AM 通信获取应用的状态、进度更新等信息。</p></li><li><p>应用运行结束后，ApplicationMaster 向 ResourceManager 注销自己，并允许属于它的container 被收回。</p></li></ol><h2 id="29-机器学习"><a href="#29-机器学习" class="headerlink" title="29. 机器学习"></a><strong>29. 机器学习</strong></h2><h4 id="29-1-1-决策树"><a href="#29-1-1-决策树" class="headerlink" title="29.1.1 决策树"></a>29.1.1 决策树</h4><h4 id="29-1-2-随机森林算法"><a href="#29-1-2-随机森林算法" class="headerlink" title="29.1.2 随机森林算法"></a>29.1.2 随机森林算法</h4><h4 id="29-1-3-逻辑回归"><a href="#29-1-3-逻辑回归" class="headerlink" title="29.1.3 逻辑回归"></a>29.1.3 逻辑回归</h4><h4 id="29-1-4-SVM"><a href="#29-1-4-SVM" class="headerlink" title="29.1.4 SVM"></a>29.1.4 SVM</h4><h4 id="29-1-5-朴素贝叶斯"><a href="#29-1-5-朴素贝叶斯" class="headerlink" title="29.1.5 朴素贝叶斯"></a>29.1.5 朴素贝叶斯</h4><h4 id="29-1-6-K-最近邻算法"><a href="#29-1-6-K-最近邻算法" class="headerlink" title="29.1.6 K 最近邻算法"></a>29.1.6 K 最近邻算法</h4><h4 id="29-1-7-K-均值算法"><a href="#29-1-7-K-均值算法" class="headerlink" title="29.1.7 K 均值算法"></a>29.1.7 K 均值算法</h4><h4 id="29-1-8-Adaboost-算法"><a href="#29-1-8-Adaboost-算法" class="headerlink" title="29.1.8 Adaboost 算法"></a>29.1.8 Adaboost 算法</h4><h4 id="29-1-9-神经网络"><a href="#29-1-9-神经网络" class="headerlink" title="29.1.9 神经网络"></a>29.1.9 神经网络</h4><h4 id="29-1-10-马尔可夫"><a href="#29-1-10-马尔可夫" class="headerlink" title="29.1.10 马尔可夫"></a>29.1.10 马尔可夫</h4><p>参考：<a href="http://www.cyzone.cn/a/20170422/310196.html">http://www.cyzone.cn/a/20170422/310196.html</a></p><h2 id="30-云计算"><a href="#30-云计算" class="headerlink" title="30. 云计算"></a><strong>30. 云计算</strong></h2><h4 id="30-1-1-SaaS"><a href="#30-1-1-SaaS" class="headerlink" title="30.1.1 SaaS"></a>30.1.1 SaaS</h4><p>SaaS 是 Software-as-a-Service（软件即服务）</p><h4 id="30-1-2-PaaS"><a href="#30-1-2-PaaS" class="headerlink" title="30.1.2 PaaS"></a>30.1.2 PaaS</h4><p>PaaS 是 Platform-as-a-Service 的缩写，意思是平台即服务。 把服务器平台作为一种服务提供的商业模式。通过网络进行程序提供的服务称之为 SaaS(Software as a Service)，而云计算时代相应的服务器平台或者开发环境作为服务进行提供就成为了 PaaS(Platform as a Service)。</p><h4 id="30-1-3-IaaS"><a href="#30-1-3-IaaS" class="headerlink" title="30.1.3 IaaS"></a>30.1.3 IaaS</h4><p>IaaS（Infrastructure as a Service），即基础设施即服务。提供给消费者的服务是对所有设施的利用，包括处理、存储、网络和其它基本的计算资源，用户能够部署和运行任意软件，包括操作系统和应用程序。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/LaaS.png"></p><h4 id="30-1-4-Docker"><a href="#30-1-4-Docker" class="headerlink" title="30.1.4 Docker"></a>30.1.4 Docker</h4><h5 id="30-1-4-1-概念"><a href="#30-1-4-1-概念" class="headerlink" title="30.1.4.1 概念"></a>30.1.4.1 概念</h5><table><thead><tr><th>Docker 镜像(Images)</th><th>Docker 镜像是用于创建 Docker 容器的模板。</th></tr></thead><tbody><tr><td>Docker 容器(Container)</td><td>容器是独立运行的一个或一组应用。</td></tr><tr><td>Docker 客户端(Client)</td><td>Docker 客户端通过命令行或者其他工具使用 Docker API 与 Docker 的守护进程通信。</td></tr><tr><td>Docker 主机(Host)</td><td>一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td></tr><tr><td>Docker 仓库(Registry)</td><td>Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub 提供了庞大的镜像集合供使用。</td></tr><tr><td>Docker Machine</td><td>Docker Machine 是一个简化 Docker 安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装 Docker，比如 VirtualBox、 Digital Ocean、Microsoft Azure。</td></tr></tbody></table><p>Docker 的出现一定是因为目前的后端在开发和运维阶段确实需要一种虚拟化技术解决开发环境和生产环境环境一致的问题，通过 Docker 我们可以将程序运行的环境也纳入到版本控制中，排除因为环境造成不同运行结果的可能。但是上述需求虽然推动了虚拟化技术的产生，但是如果没有合适的底层技术支撑，那么我们仍然得不到一个完美的产品。本文剩下的内容会介绍几种 Docker 使用的核心技术，如果我们了解它们的使用方法和原理，就能清楚 Docker 的实现原理。Docker 使用客户端-服务器 (C/S) 架构模式，使用远程 API 来管理和创建 Docker 容器。Docker 容器通过Docker 镜像来创建。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/Docker.png"></p><h5 id="30-1-4-2-Namespaces"><a href="#30-1-4-2-Namespaces" class="headerlink" title="30.1.4.2 Namespaces"></a>30.1.4.2 Namespaces</h5><p>命名空间（namespaces）是 <strong><em>Linux 为我们提供的用于分离进程树、网络接口、挂载点以及进程间通信等资源的方法</em></strong>。在日常使用 Linux 或者 macOS 时，我们并没有运行多个完全分离的服务器的需要，但是如果我们在服务器上启动了多个服务，这些服务其实会相互影响的，每一个服务都能看到其他服务的进程，也可以访问宿主机器上的任意文件，这是很多时候我们都不愿意看到的，我们更希望运行在同一台机器上的不同服务能做到完全隔离，就像运行在多台不同的机器上一样。</p><p>Linux 的命名空间机制提供了以下七种不同的命名空间，包括 <strong><em>CLONE_NEWCGROUP、CLONE_NEWIPC、CLONE_NEWNET、CLONE_NEWNS、CLONE_NEWPID、CLONE_NEWUSER 和 CLONE_NEWUTS</em></strong>，通过这七个选项我们能在创建新的进程时设置新进程应该在哪些资源上与宿主机器进行隔离。</p><h5 id="30-1-4-3-进程-CLONE-NEWPID-实现的进程隔离"><a href="#30-1-4-3-进程-CLONE-NEWPID-实现的进程隔离" class="headerlink" title="30.1.4.3 进程(CLONE_NEWPID 实现的进程隔离)"></a>30.1.4.3 进程(CLONE_NEWPID 实现的进程隔离)</h5><p><strong><em>docker 创建新进程时传入 CLONE_NEWPID 实现的进程隔离</em></strong>，也就是使用 Linux 的命名空间实现进程的隔离，Docker 容器内部的任意进程都对宿主机器的进程一无所知。*<strong>当我们每次运行docker run 或者 docker start 时，都会在创建一个用于设置进程间隔离的 Spec**<em>，同时会设置进程相关的命名空间，还会设置与用户、网络、IPC 以及 UTS 相关的命名空间，</em></strong>所有命名空间相关的设置 Spec 最后都会作为 Create 函数的入参在创建新的容器时进行设置***。</p><h5 id="30-1-4-4-Libnetwork-与网络隔离"><a href="#30-1-4-4-Libnetwork-与网络隔离" class="headerlink" title="30.1.4.4 Libnetwork 与网络隔离"></a>30.1.4.4 Libnetwork 与网络隔离</h5><p>如果 Docker 的容器通过 Linux 的命名空间完成了与宿主机进程的网络隔离，但是却有没有办法通过宿主机的网络与整个互联网相连，就会产生很多限制，所以 Docker 虽然可以通过命名空间创建一个隔离的网络环境，但是 Docker 中的服务仍然需要与外界相连才能发挥作用。</p><p><strong><em>Docker 整个网络部分的功能都是通过 Docker 拆分出来的 libnetwork 实现的</em></strong>，它提供了一个连接不同容器的实现，同时也能够为应用给出一个能够提供一致的编程接口和网络层抽象的容器网络模型。libnetwork 中最重要的概念，容器网络模型由以下的几个主要组件组成，分别是 Sandbox、Endpoint 和 Network。在容器网络模型中，每一个容器内部都包含一个 Sandbox，其中存储着当前容器的网络栈配置，包括容器的接口、路由表和 DNS 设置，**<em>Linux 使用网络命名空间实现这个Sandbox，每一个 Sandbox 中都可能会有一个或多个 Endpoint，在 Linux 上就是一个虚拟的网卡veth，Sandbox 通过 Endpoint 加入到对应的网络中，这里的网络可能就是我们在上面提到的 Linux 网桥或者 VLAN**</em>。</p><p>每一个使用 docker run 启动的容器其实都具有单独的网络命名空间，Docker 为我们提供了四种不同的网络模式，**<em>Host、Container、None 和 Bridge 模式**</em>。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/DockerNetwork.png"></p><p>在这一部分，我们将介绍 Docker 默认的网络设置模式：网桥模式。在这种模式下，除了分配隔离的网络命名空间之外，Docker 还会为所有的容器设置 IP 地址。当 Docker 服务器在主机上启动之后会创建新的虚拟网桥 docker0，随后在该主机上启动的全部服务在默认情况下都与该网桥相连。在默认情况下，每一个容器在创建时都会创建一对虚拟网卡，两个虚拟网卡组成了数据的通道，其中一个会放在创建的容器中，会加入到名为 docker0 网桥中。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/DockerNetworkTorology.png"></p><h5 id="30-1-4-5-资源隔离与-CGroups"><a href="#30-1-4-5-资源隔离与-CGroups" class="headerlink" title="30.1.4.5 资源隔离与 CGroups"></a>30.1.4.5 资源隔离与 CGroups</h5><p>Control Groups（简称 CGroups）能够隔离宿主机器上的物理资源，例如 CPU、内存、磁盘 I/O 和网络带宽。每一个 CGroup 都是一组被相同的标准和参数限制的进程，不同的 CGroup 之间是有层级关系的，也就是说它们之间可以从父类继承一些用于限制资源使用的标准和参数。</p><h5 id="30-1-4-6-镜像与-UnionFS"><a href="#30-1-4-6-镜像与-UnionFS" class="headerlink" title="30.1.4.6 镜像与 UnionFS"></a>30.1.4.6 镜像与 UnionFS</h5><p><strong><em>Linux 的命名空间和控制组分别解决了不同资源隔离的问题，前者解决了进程、网络以及文件系统的隔离，后者实现了 CPU、内存等资源的隔离</em></strong>，但是在 Docker 中还有另一个非常重要的问题需要解决 - 也就是镜像。</p><p>Docker 镜像其实本质就是一个压缩包，我们可以使用命令将一个 Docker 镜像中的文件导出，你可以看到这个**<em>镜像中的目录结构与 Linux 操作系统的根目录中的内容并没有太多的区别，可以说Docker 镜像就是一个文件**</em>。</p><p><strong>30.1.4.7.</strong> <strong>存储驱动</strong></p><p>Docker 使用了一系列不同的存储驱动管理镜像内的文件系统并运行容器，**<em>这些存储驱动与Docker 卷（volume）有些不同，存储引擎管理着能够在多个容器之间共享的存储**</em>。</p><p><strong><em>当镜像被 docker run 命令创建时就会在镜像的最上层添加一个可写的层，也就是容器层，所有对于运行时容器的修改其实都是对这个容器读写层的修改</em></strong>。</p><p><strong><em>容器和镜像的区别就在于，所有的镜像都是只读的，而每一个容器其实等于镜像加上一个可读写的层</em></strong>，也就是同一个镜像可以对应多个容器</p><p>UnionFS 其实是一种为 Linux 操作系统设计的用于把多个文件系统『联合』到同一个挂载点的文件系统服务。而 AUFS 即 Advanced UnionFS 其实就是 UnionFS 的升级版，它能够提供更优秀的性能和效率。</p><p><strong><em>AUFS 只是 Docker 使用的存储驱动的一种，除了 AUFS 之外，Docker 还支持了不同的存储驱动，包括 aufs、devicemapper、overlay2、zfs 和 vfs</em></strong> 等等，在最新的 Docker 中，overlay2 取代了aufs 成为了推荐的存储驱动，但是在没有 overlay2 驱动的机器上仍然会使用 aufs 作为 Docker 的默认驱动。</p><h4 id="30-1-5-Openstack"><a href="#30-1-5-Openstack" class="headerlink" title="30.1.5 Openstack"></a>30.1.5 Openstack</h4></string></object></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题库 </tag>
            
            <tag> 知识总结 </tag>
            
            <tag> Java面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021最新前端面试题库</title>
      <link href="2021/020115070.html"/>
      <url>2021/020115070.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="一、HTML-篇"><a href="#一、HTML-篇" class="headerlink" title="一、HTML 篇"></a><strong>一、HTML 篇</strong></h3><h3 id="1-简述一下你对-HTML-语义化的理解？"><a href="#1-简述一下你对-HTML-语义化的理解？" class="headerlink" title="1. 简述一下你对 HTML 语义化的理解？"></a>1. 简述一下你对 HTML 语义化的理解？</h3><blockquote><p>用正确的标签做正确的事情。<br>html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析；即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的;<br>搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO;<br>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</p></blockquote><h3 id="2-标签上-title-与-alt-属性的区别是什么？"><a href="#2-标签上-title-与-alt-属性的区别是什么？" class="headerlink" title="2. 标签上 title 与 alt 属性的区别是什么？"></a>2. 标签上 title 与 alt 属性的区别是什么？</h3><blockquote><p>alt 是给搜索引擎识别，在图像无法显示时的替代文本；<br>title 是关于元素的注释信息，主要是给用户解读。<br>当鼠标放到文字或是图片上时有 title 文字显示。（因为 IE 不标准）在 IE 浏览器中 alt 起到了 title 的作用，变成文字提示。<br>在定义 img 对象时，将 alt 和 title 属性写全，可以保证在各种浏览器中都能正常使用。</p></blockquote><h3 id="3-iframe的优缺点？"><a href="#3-iframe的优缺点？" class="headerlink" title="3. iframe的优缺点？"></a>3. iframe的优缺点？</h3><blockquote><p>优点：</p><ul><li>解决加载缓慢的第三方内容如图标和广告等的加载问题</li><li>Security sandbox</li><li>并行加载脚本</li></ul><hr><p>缺点：</p><ul><li>iframe会阻塞主页面的Onload事件</li><li>即时内容为空，加载也需要时间</li><li>没有语意</li></ul></blockquote><h3 id="4-href-与-src？"><a href="#4-href-与-src？" class="headerlink" title="4. href 与 src？"></a>4. href 与 src？</h3><blockquote><ul><li>href (Hypertext Reference)指定网络资源的位置，从而在当前元素或者当前文档和由当前属性定义的需要的锚点或资源之间定义一个链接或者关系。（目的不是为了引用资源，而是为了建立联系，让当前标签能够链接到目标地址。）</li><li>src source（缩写），指向外部资源的位置，指向的内容将会应用到文档中当前标签所在位置。</li><li>href与src的区别<ul><li>1、请求资源类型不同：href 指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的联系。在请求 src 资源时会将其指向的资源下载并应用到文档中，比如 JavaScript 脚本，img 图片；</li><li>2、作用结果不同：href 用于在当前文档和引用资源之间确立联系；src 用于替换当前内容；</li><li>3、浏览器解析方式不同：当浏览器解析到src ，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等也如此，类似于将所指向资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。</li></ul></li></ul></blockquote><h3 id="二、CSS-篇"><a href="#二、CSS-篇" class="headerlink" title="二、CSS 篇"></a><strong>二、CSS 篇</strong></h3><h3 id="1-介绍一下-CSS-的盒子模型？"><a href="#1-介绍一下-CSS-的盒子模型？" class="headerlink" title="1. 介绍一下 CSS 的盒子模型？"></a>1. 介绍一下 CSS 的盒子模型？</h3><blockquote><p>有两种， IE 盒子模型、W3C 盒子模型；<br>盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；<br>区 别： IE 的 content 部分把 border 和 padding 计算了进去;</p></blockquote><h3 id="2-css-选择器优先级？"><a href="#2-css-选择器优先级？" class="headerlink" title="2. css 选择器优先级？"></a>2. css 选择器优先级？</h3><blockquote><p>!important &gt; 行内样式（比重1000）&gt; ID 选择器（比重100） &gt; 类选择器（比重10） &gt; 标签（比重1） &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</p></blockquote><h3 id="3-垂直居中几种方式？"><a href="#3-垂直居中几种方式？" class="headerlink" title="3. 垂直居中几种方式？"></a>3. 垂直居中几种方式？</h3><blockquote><p>单行文本: line-height = height<br>图片: vertical-align: middle;<br>absolute 定位: top: 50%;left: 50%;transform: translate(-50%, -50%);<br>flex: display:flex;margin:auto</p></blockquote><h3 id="4-简明说一下-CSS-link-与-import-的区别和用法？"><a href="#4-简明说一下-CSS-link-与-import-的区别和用法？" class="headerlink" title="4. 简明说一下 CSS link 与 @import 的区别和用法？"></a>4. 简明说一下 CSS link 与 @import 的区别和用法？</h3><blockquote><p>link 是 XHTML 标签，除了加载CSS外，还可以定义 RSS 等其他事务；@import 属于 CSS 范畴，只能加载 CSS。<br>link 引用 CSS 时，在页面载入时同时加载；@import 需要页面网页完全载入以后加载。<br>link 是 XHTML 标签，无兼容问题；@import 是在 CSS2.1 提出的，低版本的浏览器不支持。<br>link 支持使用 Javascript 控制 DOM 去改变样式；而@import不支持。</p></blockquote><h3 id="5-rgba和opacity的透明效果有什么不同？"><a href="#5-rgba和opacity的透明效果有什么不同？" class="headerlink" title="5. rgba和opacity的透明效果有什么不同？"></a>5. rgba和opacity的透明效果有什么不同？</h3><blockquote><p>opacity 会继承父元素的 opacity 属性，而 RGBA 设置的元素的后代元素不会继承不透明属性。</p></blockquote><h3 id="6-display-none和visibility-hidden的区别？"><a href="#6-display-none和visibility-hidden的区别？" class="headerlink" title="6. display:none和visibility:hidden的区别？"></a>6. display:none和visibility:hidden的区别？</h3><blockquote><p>display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。<br>visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。</p></blockquote><h3 id="7-position的值，-relative和absolute分别是相对于谁进行定位的？"><a href="#7-position的值，-relative和absolute分别是相对于谁进行定位的？" class="headerlink" title="7. position的值， relative和absolute分别是相对于谁进行定位的？"></a>7. position的值， relative和absolute分别是相对于谁进行定位的？</h3><blockquote><p>relative:相对定位，相对于自己本身在正常文档流中的位置进行定位。<br>absolute:生成绝对定位，相对于最近一级定位不为static的父元素进行定位。<br>fixed: （老版本IE不支持）生成绝对定位，相对于浏览器窗口或者frame进行定位。<br>static:默认值，没有定位，元素出现在正常的文档流中。<br>sticky:生成粘性定位的元素，容器的位置根据正常文档流计算得出。</p></blockquote><h3 id="三、HTML-CSS-混合篇"><a href="#三、HTML-CSS-混合篇" class="headerlink" title="三、HTML / CSS 混合篇"></a><strong>三、HTML / CSS 混合篇</strong></h3><h3 id="1-HTML5、CSS3-里面都新增了那些新特性？"><a href="#1-HTML5、CSS3-里面都新增了那些新特性？" class="headerlink" title="1. HTML5、CSS3 里面都新增了那些新特性？"></a>1. HTML5、CSS3 里面都新增了那些新特性？</h3><blockquote><p><strong>HTML5</strong></p><ul><li>新的语义标签<ul><li>article 独立的内容。</li><li>aside 侧边栏。</li><li>header 头部。</li><li>nav 导航。</li><li>section 文档中的节。</li><li>footer 页脚。</li></ul></li><li>画布(Canvas) API</li><li>地理(Geolocation) API</li><li>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；<br>sessionStorage 的数据在浏览器关闭后自动删除</li><li>新的技术webworker, websocket, Geolocation</li><li>拖拽释放(Drag and drop) API</li><li>音频、视频API(audio,video)</li><li>表单控件，calendar、date、time、email、url、searc</li></ul><hr><p><strong>CSS3</strong></p><ul><li>2d，3d变换</li><li>Transition, animation</li><li>媒体查询</li><li>新的单位（rem, vw，vh 等）</li><li>圆角（border-radius），阴影（box-shadow），对文字加特效（text-shadow），线性渐变（gradient），旋转（transform）transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜</li><li>rgba</li></ul></blockquote><h3 id="2-BFC-是什么？"><a href="#2-BFC-是什么？" class="headerlink" title="2. BFC 是什么？"></a>2. BFC 是什么？</h3><blockquote><p>BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于普通流，即：元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。<br>可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。<br>只要元素满足下面任一条件即可触发 BFC 特性</p><ul><li>body 根元素</li><li>浮动元素：float 除 none 以外的值</li><li>绝对定位元素：position (absolute、fixed)</li><li>display 为 inline-block、table-cells、flex</li><li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li></ul></blockquote><h3 id="3-常见兼容性问题？"><a href="#3-常见兼容性问题？" class="headerlink" title="3. 常见兼容性问题？"></a>3. 常见兼容性问题？</h3><blockquote><ul><li>浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。</li><li>Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,<br>可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决.</li></ul></blockquote><h3 id="四、JS-篇"><a href="#四、JS-篇" class="headerlink" title="四、JS 篇"></a><strong>四、JS 篇</strong></h3><h3 id="1-JS-数据类型"><a href="#1-JS-数据类型" class="headerlink" title="1. JS 数据类型 ?"></a>1. JS 数据类型 ?</h3><blockquote><p>数据类型主要包括两部分：</p><ul><li>基本数据类型： Undefined、Null、Boolean、Number 和 String</li><li>引用数据类型： Object (包括 Object 、Array 、Function)</li><li>ECMAScript 2015 新增:Symbol(创建后独一无二且不可变的数据类型 )</li></ul></blockquote><h3 id="2-判断一个值是什么类型有哪些方法？"><a href="#2-判断一个值是什么类型有哪些方法？" class="headerlink" title="2. 判断一个值是什么类型有哪些方法？"></a>2. 判断一个值是什么类型有哪些方法？</h3><blockquote><ul><li>typeof 运算符</li><li>instanceof 运算符</li><li>Object.prototype.toString 方法</li></ul></blockquote><h3 id="3-null-和-undefined-的区别？"><a href="#3-null-和-undefined-的区别？" class="headerlink" title="3. null 和 undefined 的区别？"></a>3. null 和 undefined 的区别？</h3><blockquote><p>null 表示一个对象被定义了，值为“空值”；<br>undefined 表示不存在这个值。<br>（1）变量被声明了，但没有赋值时，就等于undefined。 （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。 （3）对象没有赋值的属性，该属性的值为undefined。 （4）函数没有返回值时，默认返回undefined。</p></blockquote><h3 id="4-怎么判断一个变量arr的话是否为数组（此题用-typeof-不行）？"><a href="#4-怎么判断一个变量arr的话是否为数组（此题用-typeof-不行）？" class="headerlink" title="4. 怎么判断一个变量arr的话是否为数组（此题用 typeof 不行）？"></a>4. 怎么判断一个变量arr的话是否为数组（此题用 typeof 不行）？</h3><blockquote><p>arr instanceof Array<br>arr.constructor == Array<br>Object.protype.toString.call(arr) == ‘[Object Array]’</p></blockquote><h3 id="5-“-”、“-”的区别？"><a href="#5-“-”、“-”的区别？" class="headerlink" title="5. “ ===”、“ ==”的区别？"></a>5. “ ===”、“ ==”的区别？</h3><blockquote><p>“ == ”，当且仅当两个运算数相等时，它返回 true，即不检查数据类型<br>” === “，只有在无需类型转换运算数就相等的情况下，才返回 true，需要检查数据类型</p></blockquote><h3 id="6-“eval是做什么的？"><a href="#6-“eval是做什么的？" class="headerlink" title="6. “eval是做什么的？"></a>6. “eval是做什么的？</h3><blockquote><p>它的功能是把对应的字符串解析成 JS 代码并运行；<br>应该避免使用 eval，不安全，非常耗性能（2次，一次解析成 js 语句，一次执行）。</p></blockquote><h3 id="7-箭头函数有哪些特点？"><a href="#7-箭头函数有哪些特点？" class="headerlink" title="7. 箭头函数有哪些特点？"></a>7. 箭头函数有哪些特点？</h3><blockquote><p>不需要function关键字来创建函数<br>省略return关键字<br>改变this指向</p></blockquote><h3 id="8-var、let、const-区别？"><a href="#8-var、let、const-区别？" class="headerlink" title="8. var、let、const 区别？"></a>8. var、let、const 区别？</h3><blockquote><p>var 存在变量提升。<br>let 只能在块级作用域内访问。<br>const 用来定义常量，必须初始化，不能修改（对象特殊）</p></blockquote><h3 id="9-new操作符具体干了什么呢？"><a href="#9-new操作符具体干了什么呢？" class="headerlink" title="9. new操作符具体干了什么呢？"></a>9. new操作符具体干了什么呢？</h3><blockquote><p>1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。<br>2、属性和方法被加入到 this 引用的对象中。<br>3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。</p></blockquote><h3 id="10-JSON-的了解？"><a href="#10-JSON-的了解？" class="headerlink" title="10. JSON 的了解？"></a>10. JSON 的了解？</h3><blockquote><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。<br>它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小<br>{‘age’:’12’, ‘name’:’back’}</p></blockquote><h3 id="11-documen-write-和-innerHTML-的区别？"><a href="#11-documen-write-和-innerHTML-的区别？" class="headerlink" title="11. documen.write 和 innerHTML 的区别？"></a>11. documen.write 和 innerHTML 的区别？</h3><blockquote><p>document.write 只能重绘整个页面<br>innerHTML 可以重绘页面的一部分</p></blockquote><h3 id="12-ajax过程？"><a href="#12-ajax过程？" class="headerlink" title="12. ajax过程？"></a>12. ajax过程？</h3><blockquote><p>(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.<br>(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.<br>(3)设置响应HTTP请求状态变化的函数.<br>(4)发送HTTP请求.<br>(5)获取异步调用返回的数据.<br>(6)使用JavaScript和DOM实现局部刷新.</p></blockquote><h3 id="13-请解释一下-JavaScript-的同源策略？"><a href="#13-请解释一下-JavaScript-的同源策略？" class="headerlink" title="13. 请解释一下 JavaScript 的同源策略？"></a>13. 请解释一下 JavaScript 的同源策略？</h3><blockquote><p>概念:同源策略是客户端脚本（尤其是Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。<br>这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。<br>指一段脚本只能读取来自同一来源的窗口和文档的属性。</p></blockquote><h3 id="14-介绍一下闭包和闭包常用场景？"><a href="#14-介绍一下闭包和闭包常用场景？" class="headerlink" title="14. 介绍一下闭包和闭包常用场景？"></a>14. 介绍一下闭包和闭包常用场景？</h3><blockquote><ul><li>闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包常见方式，就是在一个函数的内部创建另一个函数</li><li>使用闭包主要为了设计私有的方法和变量，闭包的优点是可以避免变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念。</li><li>闭包有三个特性：<ul><li>函数嵌套函数</li><li>函数内部可以引用外部的参数和变量</li><li>参数和变量不会被垃圾回收机制回收</li></ul></li><li>应用场景，设置私有变量的方法</li><li>不适用场景：返回闭包的函数是个非常大的函数</li><li>闭包的缺点就是常驻内存，会增大内存使用量，使用不当会造成内存泄漏</li></ul></blockquote><h3 id="15-javascript的内存-垃圾-回收机制？"><a href="#15-javascript的内存-垃圾-回收机制？" class="headerlink" title="15. javascript的内存(垃圾)回收机制？"></a>15. javascript的内存(垃圾)回收机制？</h3><blockquote><ul><li>垃圾回收器会每隔一段时间找出那些不再使用的内存，然后为其释放内存</li><li>一般使用<strong>标记清除方法(mark and sweep)</strong>, 当变量进入环境标记为进入环境，离开环境标记为离开环境<br>垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了</li><li>还有<strong>引用计数方法(reference counting)</strong>, 在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。</li><li>在IE中虽然JavaScript对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的， 也就是说只要涉及BOM及DOM就会出现循环引用问题。</li></ul></blockquote><h3 id="16-JavaScript原型，原型链-有什么特点？"><a href="#16-JavaScript原型，原型链-有什么特点？" class="headerlink" title="16. JavaScript原型，原型链 ? 有什么特点？"></a>16. JavaScript原型，原型链 ? 有什么特点？</h3><blockquote><ul><li>每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，<br>如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，<br>于是就这样一直找下去，也就是我们平时所说的原型链的概念。</li><li>关系：instance.constructor.prototype = instance.<strong>proto</strong></li><li>特点：<br>JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</li></ul></blockquote><h3 id="五、Vue-篇"><a href="#五、Vue-篇" class="headerlink" title="五、Vue 篇"></a><strong>五、Vue 篇</strong></h3><h3 id="1-谈谈你对MVVM开发模式的理解？"><a href="#1-谈谈你对MVVM开发模式的理解？" class="headerlink" title="1. 谈谈你对MVVM开发模式的理解？"></a>1. 谈谈你对MVVM开发模式的理解？</h3><blockquote><p>MVVM分为Model、View、ViewModel三者。<br>Model 代表数据模型，数据和业务逻辑都在Model层中定义；<br>View 代表UI视图，负责数据的展示；<br>ViewModel 负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作；<br>Model 和 View 并无直接关联，而是通过 ViewModel 来进行联系的，Model 和 ViewModel 之间有着双向数据绑定的联系。因此当 Model 中的数据改变时会触发 View 层的刷新，View 中由于用户交互操作而改变的数据也会在 Model 中同步。<br>这种模式实现了 Model 和 View 的数据自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要自己操作 dom。</p></blockquote><h3 id="2-v-if-和-v-show-有什么区别？"><a href="#2-v-if-和-v-show-有什么区别？" class="headerlink" title="2. v-if 和 v-show 有什么区别？"></a>2. v-if 和 v-show 有什么区别？</h3><blockquote><ul><li>v-if 是真正的条件渲染，会控制这个 DOM 节点的存在与否。因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</li><li>v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。</li><li>当我们需要经常切换某个元素的显示/隐藏时，使用v-show会更加节省性能上的开销；当只需要一次显示或隐藏时，使用v-if更加合理。</li></ul></blockquote><h3 id="3-你使用过-Vuex-吗？"><a href="#3-你使用过-Vuex-吗？" class="headerlink" title="3. 你使用过 Vuex 吗？"></a>3. 你使用过 Vuex 吗？</h3><blockquote><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p><ul><li>（1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li><li>（2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</li></ul><hr><p><strong>主要包括以下几个模块：</strong></p><ul><li>State =&gt; 基本数据，定义了应用状态的数据结构，可以在这里设置默认的初始状态。</li><li>Getter =&gt; 从基本数据派生的数据，允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li><li>Mutation =&gt; 是唯一更改 store 中状态的方法，且必须是同步函数。</li><li>Action =&gt; 像一个装饰器，包裹mutations，使之可以异步。用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</li><li>Module =&gt; 模块化Vuex，允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</li></ul></blockquote><h3 id="4-说说你对-SPA-单页面的理解，它的优缺点分别是什么？"><a href="#4-说说你对-SPA-单页面的理解，它的优缺点分别是什么？" class="headerlink" title="4. 说说你对 SPA 单页面的理解，它的优缺点分别是什么？"></a>4. 说说你对 SPA 单页面的理解，它的优缺点分别是什么？</h3><blockquote><p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页&gt; 面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 &gt; HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p><ul><li>优点：<br>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；<br>基于上面一点，SPA 相对对服务器压力小；<br>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li><li>缺点：<br>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一&gt; 加载，部分页面按需加载；<br>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所&gt; 有的页面切换需要自己建立堆栈管理；<br>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li></ul></blockquote><h3 id="5-Class-与-Style-如何动态绑定？"><a href="#5-Class-与-Style-如何动态绑定？" class="headerlink" title="5. Class 与 Style 如何动态绑定？"></a>5. Class 与 Style 如何动态绑定？</h3><blockquote><p>Class 可以通过对象语法和数组语法进行动态绑定：</p></blockquote><ul><li>对象语法：</li></ul><pre class="line-numbers language-none"><code class="language-none">&lt;div v-bind:class="{ active: isActive, 'text-danger': hasError }"&gt;&lt;/div&gt;data: {isActive: true,  hasError: false}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>数组语法：</li></ul><pre class="line-numbers language-none"><code class="language-none">&lt;div v-bind:class="[isActive ? activeClass : '', errorClass]"&gt;&lt;/div&gt;data: {  activeClass: 'active',  errorClass: 'text-danger'}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>Style 也可以通过对象语法和数组语法进行动态绑定：</p></blockquote><ul><li>对象语法：</li></ul><pre class="line-numbers language-none"><code class="language-none">&lt;div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"&gt;&lt;/div&gt;data: {  activeColor: 'red',  fontSize: 30}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>数组语法：</li></ul><pre class="line-numbers language-none"><code class="language-none">&lt;div v-bind:style="[styleColor, styleSize]"&gt;&lt;/div&gt;data: {  styleColor: {     color: 'red'   },  styleSize:{     fontSize:'23px'  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-怎样理解-Vue-的单向数据流？"><a href="#6-怎样理解-Vue-的单向数据流？" class="headerlink" title="6. 怎样理解 Vue 的单向数据流？"></a>6. 怎样理解 Vue 的单向数据流？</h3><blockquote><p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。<br>这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。<br>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。<br>这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。<br>子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p></blockquote><h3 id="7-computed-和-watch-的区别和运用的场景？"><a href="#7-computed-和-watch-的区别和运用的场景？" class="headerlink" title="7. computed 和 watch 的区别和运用的场景？"></a>7. computed 和 watch 的区别和运用的场景？</h3><blockquote><ul><li>computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；</li><li>watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</li><li>运用场景：<ul><li>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</li><li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li></ul></li></ul></blockquote><h3 id="8-直接给一个数组项赋值，Vue-能检测到变化吗？"><a href="#8-直接给一个数组项赋值，Vue-能检测到变化吗？" class="headerlink" title="8. 直接给一个数组项赋值，Vue 能检测到变化吗？"></a>8. 直接给一个数组项赋值，Vue 能检测到变化吗？</h3><blockquote><p>由于 JavaScript 的限制，Vue 不能检测到以下数组的变动：</p><ul><li>当你利用索引直接设置一个数组项时，例如：<code>vm.items[indexOfItem] = newValue</code></li><li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li></ul></blockquote><ul><li>为了解决第一个问题，Vue 提供了以下操作方法：</li></ul><pre class="line-numbers language-none"><code class="language-none">// Vue.setVue.set(vm.items, indexOfItem, newValue)// vm.$set，Vue.set的一个别名vm.$set(vm.items, indexOfItem, newValue)// Array.prototype.splicevm.items.splice(indexOfItem, 1, newValue)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>为了解决第二个问题，Vue 提供了以下操作方法：</li></ul><pre class="line-numbers language-none"><code class="language-none">// Array.prototype.splicevm.items.splice(newLength)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="9-谈谈你对-Vue-生命周期的理解？"><a href="#9-谈谈你对-Vue-生命周期的理解？" class="headerlink" title="9. 谈谈你对 Vue 生命周期的理解？"></a>9. 谈谈你对 Vue 生命周期的理解？</h3><ul><li><strong>生命周期是什么？</strong></li></ul><blockquote><p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p></blockquote><ul><li><strong>各个生命周期的作用</strong></li></ul><blockquote><table><thead><tr><th>生命周期</th><th>描述</th></tr></thead><tbody><tr><td>beforeCreate</td><td>组件实例被创建之初，组件的属性生效之前</td></tr><tr><td>created</td><td>组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用</td></tr><tr><td>beforeMount</td><td>在挂载开始之前被调用：相关的 render 函数首次被调用</td></tr><tr><td>mounted</td><td>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</td></tr><tr><td>beforeUpdate</td><td>组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</td></tr><tr><td>updated</td><td>组件数据更新之后</td></tr><tr><td>activited</td><td>keep-alive 专属，组件被激活时调用</td></tr><tr><td>deadctivated</td><td>keep-alive 专属，组件被销毁时调用</td></tr><tr><td>beforeDestory</td><td>组件销毁前调用</td></tr><tr><td>destoryed</td><td>组件销毁后调用</td></tr></tbody></table></blockquote><h3 id="10-Vue-的父组件和子组件生命周期钩子函数执行顺序？"><a href="#10-Vue-的父组件和子组件生命周期钩子函数执行顺序？" class="headerlink" title="10. Vue 的父组件和子组件生命周期钩子函数执行顺序？"></a>10. Vue 的父组件和子组件生命周期钩子函数执行顺序？</h3><blockquote><p>Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：</p><ul><li>加载渲染过程 :<br>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</li><li>子组件更新过程 :<br>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</li><li>父组件更新过程 :<br>父 beforeUpdate -&gt; 父 updated</li><li>销毁过程 :<br>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</li></ul></blockquote><h3 id="11-父组件可以监听到子组件的生命周期吗？"><a href="#11-父组件可以监听到子组件的生命周期吗？" class="headerlink" title="11. 父组件可以监听到子组件的生命周期吗？"></a>11. 父组件可以监听到子组件的生命周期吗？</h3><blockquote><p>比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：</p></blockquote><pre class="line-numbers language-none"><code class="language-none">// Parent.vue&lt;Child @mounted="doSomething"/&gt;// Child.vuemounted() {  this.$emit("mounted");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示：</p></blockquote><pre class="line-numbers language-none"><code class="language-none">//  Parent.vue&lt;Child @hook:mounted="doSomething" &gt;&lt;/Child&gt;doSomething() {   console.log('父组件监听到 mounted 钩子函数 ...');},//  Child.vuemounted(){   console.log('子组件触发 mounted 钩子函数 ...');},    // 以上输出顺序为：// 子组件触发 mounted 钩子函数 ...// 父组件监听到 mounted 钩子函数 ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。</p></blockquote><h3 id="12-谈谈你对-keep-alive-的了解？"><a href="#12-谈谈你对-keep-alive-的了解？" class="headerlink" title="12. 谈谈你对 keep-alive 的了解？"></a>12. 谈谈你对 keep-alive 的了解？</h3><blockquote><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</p><ul><li>一般结合路由和动态组件一起使用，用于缓存组件；</li><li>提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；</li><li>对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</li></ul></blockquote><h3 id="13-组件中-data-为什么是一个函数？"><a href="#13-组件中-data-为什么是一个函数？" class="headerlink" title="13. 组件中 data 为什么是一个函数？"></a>13. 组件中 data 为什么是一个函数？</h3><ul><li><strong>为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？</strong></li></ul><blockquote><ul><li>因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，</li><li>如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。</li></ul></blockquote><h3 id="14-v-model-的原理？"><a href="#14-v-model-的原理？" class="headerlink" title="14. v-model 的原理？"></a>14. v-model 的原理？</h3><blockquote><p>我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p><ul><li>text 和 textarea 元素使用 value 属性和 input 事件；</li><li>checkbox 和 radio 使用 checked 属性和 change 事件；</li><li>select 字段将 value 作为 prop 并将 change 作为事件。</li></ul></blockquote><ul><li>以 input 表单元素为例：</li></ul><pre class="line-numbers language-none"><code class="language-none">&lt;input v-model='something'&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>相当于</p><pre class="line-numbers language-none"><code class="language-none">&lt;input v-bind:value="something" v-on:input="something = $event.target.value"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示：</p><pre class="line-numbers language-none"><code class="language-none">父组件：&lt;ModelChild v-model="message"&gt;&lt;/ModelChild&gt;子组件：&lt;div&gt;{{value}}&lt;/div&gt;props:{    value: String},methods: {  test1(){     this.$emit('input', '小红')  },},<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="15-Vue-组件间通信有哪几种方式？"><a href="#15-Vue-组件间通信有哪几种方式？" class="headerlink" title="15. Vue 组件间通信有哪几种方式？"></a>15. Vue 组件间通信有哪几种方式？</h3><p>Vue 组件间通信是面试常考的知识点之一，这题有点类似于开放题，你回答出越多方法当然越加分，表明你对 Vue 掌握的越熟练。</p><blockquote><p>Vue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信。<br><strong>（1）<code>props / $emit</code>适用 父子组件通信</strong></p><ul><li>这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。</li></ul><p><strong>（2）<code>ref</code>与 <code>$parent / $children</code>适用 父子组件通信</strong></p><ul><li><code>ref</code>：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例</li><li><code>$parent / $children</code>：访问父 / 子实例</li></ul><p><strong>（3）<code>EventBus （$emit / $on）</code>适用于 父子、隔代、兄弟组件通信</strong></p><ul><li>这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。</li></ul><p><strong>（4）<code>$attrs/$listeners</code>适用于 隔代组件通信</strong></p><ul><li><code>$attrs</code>：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 <code>v-bind="$attrs"</code>传入内部组件。通常配合 inheritAttrs 选项一起使用。</li><li><code>$listeners</code>：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 <code>v-on="$listeners"</code>传入内部组件</li></ul><p><strong>（5）<code>provide / inject</code>适用于 隔代组件通信</strong></p><ul><li>祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。<code>provide / inject API</code>主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。</li></ul><p><strong>（6）<code>Vuex</code>适用于 父子、隔代、兄弟组件通信</strong></p><ul><li>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</li><li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li><li>改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</li></ul></blockquote><h3 id="16-使用过-Vue-SSR-吗？说说-SSR？"><a href="#16-使用过-Vue-SSR-吗？说说-SSR？" class="headerlink" title="16. 使用过 Vue SSR 吗？说说 SSR？"></a>16. 使用过 Vue SSR 吗？说说 SSR？</h3><blockquote><ul><li>Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。</li><li>即：SSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。</li></ul><hr><p><strong>服务端渲染 SSR 的优缺点如下：</strong></p><ul><li>（1）服务端渲染的优点：<ul><li>更好的 SEO：因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</li><li>更快的内容到达时间（首屏加载更快）：SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；</li></ul></li><li>（2) 服务端渲染的缺点：<ul><li>更多的开发条件限制：例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；</li><li>更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</li></ul></li></ul></blockquote><h3 id="17-vue-router-路由模式有几种？"><a href="#17-vue-router-路由模式有几种？" class="headerlink" title="17. vue-router 路由模式有几种？"></a>17. vue-router 路由模式有几种？</h3><blockquote><p>vue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示：</p></blockquote><pre class="line-numbers language-none"><code class="language-none">switch (mode) {  case 'history':    this.history = new HTML5History(this, options.base)    break  case 'hash':    this.history = new HashHistory(this, options.base, this.fallback)    break  case 'abstract':    this.history = new AbstractHistory(this, options.base)    break  default:    if (process.env.NODE_ENV !== 'production') {      assert(false, `invalid mode: ${mode}`)    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>其中，3 种路由模式的说明如下：</p><ul><li>hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；</li><li>history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；</li><li>abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</li></ul></blockquote><h3 id="18-能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？"><a href="#18-能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？" class="headerlink" title="18. 能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？"></a>18. 能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？</h3><blockquote><p>（1）hash 模式的实现原理<br>早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 ‘#search’：<br><code>https://www.word.com#search</code><br>hash 路由模式的实现主要是基于下面几个特性：</p><ul><li>URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；</li><li>hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；</li><li>可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；</li><li>我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。</li></ul><hr><p>（2）history 模式的实现原理<br>HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。<br><strong>唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：</strong><br><code>window.history.pushState(null, null, path);</code><br><code>window.history.replaceState(null, null, path);</code><br>history 路由模式的实现主要基于存在下面几个特性：</p><ul><li>pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；</li><li>我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）；</li><li>history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。</li></ul></blockquote><h3 id="19-Vue-框架怎么实现对象和数组的监听？"><a href="#19-Vue-框架怎么实现对象和数组的监听？" class="headerlink" title="19. Vue 框架怎么实现对象和数组的监听？"></a>19. Vue 框架怎么实现对象和数组的监听？</h3><blockquote><p>Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据。<br>即：</p><ul><li>输入框内容变化时，Data 中的数据同步变化。即 View =&gt; Data 的变化。</li><li>Data 中的数据变化时，文本节点的内容同步变化。即 Data =&gt; View 的变化。</li></ul><p>其中，<strong>View 变化更新 Data ，可以通过事件监听的方式来实现</strong>，所以 Vue 的数据双向绑定的工作主要是<strong>如何根据 Data 变化更新 View</strong>。<br>Vue 主要通过以下 4 个步骤来实现数据双向绑定的：</p><ul><li>实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。</li><li>实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。</li><li>实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。</li><li>实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。<br><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/Vueinterview.png"></li></ul></blockquote><h3 id="20-Vue-是如何实现数据双向绑定的？"><a href="#20-Vue-是如何实现数据双向绑定的？" class="headerlink" title="20. Vue 是如何实现数据双向绑定的？"></a>20. Vue 是如何实现数据双向绑定的？</h3><blockquote><p>如果被问到 Vue 怎么实现数据双向绑定，大家肯定都会回答 通过 Object.defineProperty() 对数据进行劫持，但是 Object.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持。<br>同理无法对数组进行劫持，但是我们在使用 Vue 框架中都知道，Vue 能检测到对象和数组（部分方法的操作）的变化，那它是怎么实现的呢？我们查看相关代码如下：</p></blockquote><pre class="line-numbers language-none"><code class="language-none">/** * Observe a list of Array items. */observeArray (items: Array&lt;any&gt;) {  for (let i = 0, l = items.length; i &lt; l; i++) {    observe(items[i])  // observe 功能为监测数据的变化  }}/** * 对属性进行递归遍历 */let childOb = !shallow &amp;&amp; observe(val) // observe 功能为监测数据的变化<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>通过以上 Vue 源码部分查看，我们就能知道 Vue 框架是通过遍历数组 和递归遍历对象，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。</p></blockquote><h3 id="21-Vue-怎么用-vm-set-解决对象新增属性不能响应的问题-？"><a href="#21-Vue-怎么用-vm-set-解决对象新增属性不能响应的问题-？" class="headerlink" title="21. Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？"></a>21. Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？</h3><blockquote><p>受现代 JavaScript 的限制 ，Vue 无法检测到对象属性的添加或删除。<br>由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。<br>但是 Vue 提供了 <code>Vue.set (object, propertyName, value) / vm.$set (object, propertyName, value)</code>来实现为对象添加响应式属性，那框架本身是如何实现的呢？</p><ul><li>我们查看对应的 Vue 源码：<code>vue/src/core/instance/index.js</code></li></ul></blockquote><pre class="line-numbers language-none"><code class="language-none">export function set (target: Array&lt;any&gt; | Object, key: any, val: any): any {  // target 为数组  if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) {    // 修改数组的长度, 避免索引&gt;数组长度导致splcie()执行有误    target.length = Math.max(target.length, key)    // 利用数组的splice变异方法触发响应式    target.splice(key, 1, val)    return val  }  // key 已经存在，直接修改属性值  if (key in target &amp;&amp; !(key in Object.prototype)) {    target[key] = val    return val  }  const ob = (target: any).__ob__  // target 本身就不是响应式数据, 直接赋值  if (!ob) {    target[key] = val    return val  }  // 对属性进行响应式处理  defineReactive(ob.value, key, val)  ob.dep.notify()  return val}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>我们阅读以上源码可知，vm.$set 的实现原理是：</p><ul><li>如果目标是数组，直接使用数组的 splice 方法触发相应式；</li><li>如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）</li></ul></blockquote><h3 id="22-虚拟-DOM-的优缺点？"><a href="#22-虚拟-DOM-的优缺点？" class="headerlink" title="22. 虚拟 DOM 的优缺点？"></a>22. 虚拟 DOM 的优缺点？</h3><blockquote><p>优点：</p><ul><li>保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</li><li>无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</li><li>跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</li></ul><p>缺点:</p><ul><li>无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。</li></ul></blockquote><h3 id="23-虚拟-DOM-实现原理？"><a href="#23-虚拟-DOM-实现原理？" class="headerlink" title="23. 虚拟 DOM 实现原理？"></a>23. 虚拟 DOM 实现原理？</h3><blockquote><p>虚拟 DOM 的实现原理主要包括以下 3 部分：</p><ul><li>用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；</li><li>diff 算法 — 比较两棵虚拟 DOM 树的差异；</li><li>pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。</li></ul></blockquote><h3 id="24-Vue-中的-key-有什么作用？"><a href="#24-Vue-中的-key-有什么作用？" class="headerlink" title="24. Vue 中的 key 有什么作用？"></a>24. Vue 中的 key 有什么作用？</h3><blockquote><p><strong>key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。</strong><br>Vue 的 diff 过程可以概括为：oldCh 和 newCh 各有两个头尾的变量 oldStartIndex、oldEndIndex 和 newStartIndex、newEndIndex，它们会新节点和旧节点会进行两两对比，即一共有4种比较方式：newStartIndex 和oldStartIndex 、newEndIndex 和 oldEndIndex 、newStartIndex 和 oldEndIndex 、newEndIndex 和 oldStartIndex，如果以上 4 种比较都没匹配，如果设置了key，就会用 key 再进行比较，在比较的过程中，遍历会往中间靠，一旦 StartIdx &gt; EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较。<br><strong>所以 Vue 中 key 的作用是：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速!</strong></p><ul><li>更准确：因为带 key 就不是就地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。</li><li>更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快，源码如下：</li></ul></blockquote><pre class="line-numbers language-none"><code class="language-none">function createKeyToOldIdx (children, beginIdx, endIdx) {  let i, key  const map = {}  for (i = beginIdx; i &lt;= endIdx; ++i) {    key = children[i].key    if (isDef(key)) map[key] = i  }  return map}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="25-你有对-Vue-项目进行哪些优化？"><a href="#25-你有对-Vue-项目进行哪些优化？" class="headerlink" title="25. 你有对 Vue 项目进行哪些优化？"></a>25. 你有对 Vue 项目进行哪些优化？</h3><blockquote><p>（1）代码层面的优化</p><ul><li>v-if 和 v-show 区分使用场景</li><li>computed 和 watch 区分使用场景</li><li>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</li><li>长列表性能优化</li><li>事件的销毁</li><li>图片资源懒加载</li><li>路由懒加载</li><li>第三方插件的按需引入</li><li>优化无限列表性能</li><li>服务端渲染 SSR or 预渲染</li></ul><hr><p>（2）Webpack 层面的优化</p><ul><li>Webpack 对图片进行压缩</li><li>减少 ES6 转为 ES5 的冗余代码</li><li>提取公共代码</li><li>模板预编译</li><li>提取组件的 CSS</li><li>优化 SourceMap</li><li>构建结果输出分析</li><li>Vue 项目的编译优化</li></ul><hr><p>（3）基础的 Web 技术的优化</p><ul><li>开启 gzip 压缩</li><li>浏览器缓存</li><li>CDN 的使用</li><li>使用 Chrome Performance 查找性能瓶颈</li></ul></blockquote><h3 id="26-对于-vue3-0-特性你有什么了解的吗？"><a href="#26-对于-vue3-0-特性你有什么了解的吗？" class="headerlink" title="26. 对于 vue3.0 特性你有什么了解的吗？"></a>26. 对于 vue3.0 特性你有什么了解的吗？</h3><blockquote><p>Vue 3.0 的目标是让 Vue 核心变得更小、更快、更强大，因此 Vue 3.0 增加以下这些新特性：</p><blockquote><p>（1）监测机制的改变<br>3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的反应性跟踪。这消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：</p><ul><li>只能监测属性，不能监测对象</li><li>检测属性的添加和删除；</li><li>检测数组索引和长度的变更；</li><li>支持 Map、Set、WeakMap 和 WeakSet。</li></ul><p>新的 observer 还提供了以下特性：</p><ul><li>用于创建 observable 的公开 API。这为中小规模场景提供了简单轻量级的跨组件状态管理解决方案。</li><li>默认采用惰性观察。在 2.x 中，不管反应式数据有多大，都会在启动时被观察到。如果你的数据集很大，这可能会在应用启动时带来明显的开销。在 3.x 中，只观察用于渲染应用程序最初可见部分的数据。</li><li>更精确的变更通知。在 2.x 中，通过 Vue.set 强制添加新属性将导致依赖于该对象的 watcher 收到变更通知。在 3.x 中，只有依赖于特定属性的 watcher 才会收到通知。</li><li>不可变的 observable：我们可以创建值的“不可变”版本（即使是嵌套属性），除非系统在内部暂时将其“解禁”。这个机制可用于冻结 prop 传递或 Vuex 状态树以外的变化。</li><li>更好的调试功能：我们可以使用新的 renderTracked 和 renderTriggered 钩子精确地跟踪组件在什么时候以及为什么重新渲染。</li></ul></blockquote><blockquote><p><strong>（2）模板</strong><br>模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。<br>同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。</p></blockquote><blockquote><p><strong>（3）对象式的组件声明方式</strong><br>vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。<br>3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易。<br>此外，vue 的源码也改用了 TypeScript 来写。其实当代码的功能复杂之后，必须有一个静态类型系统来做一些辅助管理。<br>现在 vue3.0 也全面改用 TypeScript 来重写了，更是使得对外暴露的 api 更容易结合 TypeScript。静态类型系统对于复杂代码的维护确实很有必要。</p></blockquote><blockquote><p><strong>（4）其它方面的更改</strong><br>vue3.0 的改变是全面的，上面只涉及到主要的 3 个方面，还有一些其他的更改：</p><ul><li>支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。</li><li>支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。</li><li>基于 treeshaking 优化，提供了更多的内置功能。</li></ul></blockquote></blockquote><h3 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a><strong>六、其他</strong></h3><h3 id="1-常见的浏览器内核有哪些？"><a href="#1-常见的浏览器内核有哪些？" class="headerlink" title="1. 常见的浏览器内核有哪些？"></a>1. 常见的浏览器内核有哪些？</h3><blockquote><ul><li>主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。<ul><li>渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。</li><li>JS引擎则：解析和执行javascript来实现网页的动态效果。</li></ul></li><li>最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。</li><li>常见内核<ul><li>Trident 内核：IE, MaxThon, TT, The World, 360, 搜狗浏览器等。[又称 MSHTML]</li><li>Gecko 内核：Netscape6 及以上版本，FF, MozillaSuite / SeaMonkey 等</li><li>Presto 内核：Opera7 及以上。 [Opera内核原为：Presto，现为：Blink;]</li><li>Webkit 内核：Safari, Chrome等。 [ Chrome的：Blink（WebKit 的分支）]</li></ul></li></ul></blockquote><h3 id="2-网页前端性能优化的方式有哪些？"><a href="#2-网页前端性能优化的方式有哪些？" class="headerlink" title="2. 网页前端性能优化的方式有哪些？"></a>2. 网页前端性能优化的方式有哪些？</h3><blockquote><p>1.压缩 css, js, 图片<br>2.减少 http 请求次数， 合并 css、js 、合并图片（雪碧图）<br>3.使用 CDN<br>4.减少 dom 元素数量<br>5.图片懒加载<br>6.静态资源另外用无 cookie 的域名<br>7.减少 dom 的访问（缓存 dom）<br>8.巧用事件委托<br>9.样式表置顶、脚本置低</p></blockquote><h3 id="3-网页从输入网址到渲染完成经历了哪些过程？"><a href="#3-网页从输入网址到渲染完成经历了哪些过程？" class="headerlink" title="3. 网页从输入网址到渲染完成经历了哪些过程？"></a>3. 网页从输入网址到渲染完成经历了哪些过程？</h3><blockquote><p>大致可以分为如下7步：</p><ul><li>输入网址；</li><li>发送到DNS服务器，并获取域名对应的web服务器对应的ip地址；</li><li>与web服务器建立TCP连接；</li><li>浏览器向web服务器发送http请求；</li><li>web服务器响应请求，并返回指定url的数据（或错误信息，或重定向的新的url地址）；</li><li>浏览器下载web服务器返回的数据及解析html源文件；</li><li>生成DOM树，解析css和js，渲染页面，直至显示完成；</li></ul></blockquote><h3 id="4-线程与进程的区别？"><a href="#4-线程与进程的区别？" class="headerlink" title="4. 线程与进程的区别？"></a>4. 线程与进程的区别？</h3><blockquote><ul><li>一个程序至少有一个进程,一个进程至少有一个线程.</li><li>线程的划分尺度小于进程，使得多线程程序的并发性高。</li><li>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</li><li>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li><li>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</li></ul></blockquote><h3 id="5-HTTP常见的状态码？"><a href="#5-HTTP常见的状态码？" class="headerlink" title="5. HTTP常见的状态码？"></a>5. HTTP常见的状态码？</h3><blockquote><p>100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息<br>200 OK 正常返回信息<br>201 Created 请求成功并且服务器创建了新的资源<br>202 Accepted 服务器已接受请求，但尚未处理<br>301 Moved Permanently 请求的网页已永久移动到新位置。<br>302 Found 临时性重定向。<br>303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。<br>304 Not Modified 自从上次请求后，请求的网页未修改过。<br>400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。<br>401 Unauthorized 请求未授权。<br>403 Forbidden 禁止访问。<br>404 Not Found 找不到如何与 URI 相匹配的资源。<br>500 Internal Server Error 最常见的服务器端错误。<br>503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</p></blockquote><h3 id="6-图片懒加载？"><a href="#6-图片懒加载？" class="headerlink" title="6. 图片懒加载？"></a>6. 图片懒加载？</h3><blockquote><p>当页面滚动的时间被触发 -&gt; 执行加载图片操作 -&gt; 判断图片是否在可视区域内 -&gt; 在，则动态将data-src的值赋予该图片</p></blockquote><h3 id="7-移动端性能优化？"><a href="#7-移动端性能优化？" class="headerlink" title="7. 移动端性能优化？"></a>7. 移动端性能优化？</h3><blockquote><ul><li>尽量使用css3动画，开启硬件加速</li><li>适当使用touch时间代替click时间</li><li>避免使用css3渐变阴影效果</li><li>可以用transform: translateZ(0) 来开启硬件加速</li><li>不滥用float。float在渲染时计算量比较大，尽量减少使用</li><li>不滥用web字体。web字体需要下载，解析，重绘当前页面</li><li>合理使用requestAnimationFrame动画代替setTimeout</li><li>css中的属性（css3 transitions、css3 3D transforms、opacity、webGL、video）会触发GUP渲染，耗电</li></ul></blockquote><h3 id="8-TCP-传输的三次握手、四次挥手策略"><a href="#8-TCP-传输的三次握手、四次挥手策略" class="headerlink" title="8. TCP 传输的三次握手、四次挥手策略"></a>8. TCP 传输的三次握手、四次挥手策略</h3><blockquote><ul><li><p>三次握手：</p><p>为了准确无误地吧数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，他一定会向对方确认是否送达，握手过程中使用TCP的标志：SYN和ACK</p><ul><li>发送端首先发送一个带SYN的标志的数据包给对方</li><li>接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息</li><li>最后，发送端再回传一个带ACK的标志的数据包，代表“握手”结束</li></ul></li><li><p>如在握手过程中某个阶段莫明中断，TCP协议会再次以相同的顺序发送相同的数据包</p></li></ul><hr><ul><li>断开一个TCP连接需要“四次挥手”<ul><li>第一次挥手：主动关闭方发送一个FIN，用来关注主动方到被动关闭方的数据传送，也即是主动关闭方告诫被动关闭方：我已经不会再给你发数据了（在FIN包之前发送的数据，如果没有收到对应的ACK确认报文，主动关闭方依然会重发这些数据）。但是，此时主动关闭方还可以接受数据</li><li>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号收到序号 +1（与SYN相同，一个 FIN占用一个序号）</li><li>第三次挥手：被动关闭方发送一个 FIN。用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会给你发送数据了</li><li>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手</li></ul></li></ul></blockquote><h3 id="9-HTTP-和-HTTPS，为什么HTTPS安全？"><a href="#9-HTTP-和-HTTPS，为什么HTTPS安全？" class="headerlink" title="9. HTTP 和 HTTPS，为什么HTTPS安全？"></a>9. HTTP 和 HTTPS，为什么HTTPS安全？</h3><blockquote><ul><li>HTTP协议通常承载与 TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS</li><li>默认HTTP的端口号为80，HTTPS的端口号为443</li><li>因为网络请求需要中间有很多的服务器路由的转发，中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有，https之所有说比http安全，是因为他利用ssl/tls协议传输。包含证书，流量转发，负载均衡，页面适配，浏览器适配，refer传递等，保障了传输过程的安全性</li></ul></blockquote><h3 id="七、主观题篇"><a href="#七、主观题篇" class="headerlink" title="七、主观题篇"></a><strong>七、主观题篇</strong></h3><h3 id="1-你都做过什么项目呢？具体聊某一个项目中运用的技术"><a href="#1-你都做过什么项目呢？具体聊某一个项目中运用的技术" class="headerlink" title="1. 你都做过什么项目呢？具体聊某一个项目中运用的技术."></a>1. 你都做过什么项目呢？具体聊某一个项目中运用的技术.</h3><blockquote><p>注意：用心找自己做的项目中自己感觉最拿出来手的（复杂度最高，用的技术最多的项目），描述的时候尽可能往里面添加一些技术名词<br>布局我们用html5+css3<br>我们会用reset.css重置浏览器的默认样式<br>JS框架的话我们选用的是jQuery(也可能是Zepto)<br>我们用版本控制工具git来协同开发<br>我们会基于gulp搭建的前端自动化工程来开发（里面包含有我们的项目结构、我们需要引用的第三方库等一些信息，我们还实现了sass编译、CSS3加前缀等的自动化）<br>我们的项目中还用到了表单验证validate插件、图片懒加载Lazyload插件</p></blockquote><h3 id="2-你遇到过比较难的技术问题是？你是如何解决的？"><a href="#2-你遇到过比较难的技术问题是？你是如何解决的？" class="headerlink" title="2. 你遇到过比较难的技术问题是？你是如何解决的？"></a>2. 你遇到过比较难的技术问题是？你是如何解决的？</h3><h3 id="3-常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？"><a href="#3-常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？" class="headerlink" title="3. 常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？"></a>3. 常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？</h3><h3 id="4-除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？"><a href="#4-除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？" class="headerlink" title="4. 除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？"></a>4. 除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？</h3><h3 id="5-对前端开发工程师这个职位是怎么样理解的？它的前景会怎么样？"><a href="#5-对前端开发工程师这个职位是怎么样理解的？它的前景会怎么样？" class="headerlink" title="5. 对前端开发工程师这个职位是怎么样理解的？它的前景会怎么样？"></a>5. 对前端开发工程师这个职位是怎么样理解的？它的前景会怎么样？</h3><blockquote><p>前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。<br>1、实现界面交互<br>2、提升用户体验<br>3、有了Node.js，前端可以实现服务端的一些事情<br>前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，<br>参与项目，快速高质量完成实现效果图，精确到1px；<br>与团队成员，UI设计，产品经理的沟通；<br>做好的页面结构，页面重构和用户体验；<br>处理hack，兼容、写出优美的代码格式；<br>针对服务器的优化、拥抱最新前端技术。</p></blockquote><h3 id="6-你的优点是什么？缺点是什么？"><a href="#6-你的优点是什么？缺点是什么？" class="headerlink" title="6. 你的优点是什么？缺点是什么？"></a>6. 你的优点是什么？缺点是什么？</h3><h3 id="八、补充"><a href="#八、补充" class="headerlink" title="八、补充"></a><strong>八、补充</strong></h3><h3 id="1-说说前端中的事件流？"><a href="#1-说说前端中的事件流？" class="headerlink" title="1.说说前端中的事件流？"></a>1.说说前端中的事件流？</h3><p>HTML中与javascript交互是通过事件驱动来实现的，例如鼠标点击事件onclick、页面的滚动事件onscroll等等，可以向文档或者文档中的元素添加事件侦听器来预订事件。想要知道这些事件是在什么时候进行调用的，就需要了解一下“事件流”的概念。</p><p>什么是事件流：事件流描述的是从页面中接收事件的顺序，DOM2级事件流包括下面几个阶段：</p><p>事件捕获阶段处于目标阶段事件冒泡阶段addEventListener：addEventListener 是DOM2 级事件新增的指定事件处理程序的操作，这个方法接收3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序；IE只支持事件冒泡。</p><h3 id="2-如何让事件先冒泡后捕获？"><a href="#2-如何让事件先冒泡后捕获？" class="headerlink" title="2.如何让事件先冒泡后捕获？"></a>2.如何让事件先冒泡后捕获？</h3><p>在DOM标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获之间。</p><h3 id="3-js如何判断类型？"><a href="#3-js如何判断类型？" class="headerlink" title="3.js如何判断类型？"></a>3.js如何判断类型？</h3><p>判断方法：typeof()，instanceof，Object.prototype.toString.call()等。</p><h3 id="4-js数组常用方法？"><a href="#4-js数组常用方法？" class="headerlink" title="4.js数组常用方法？"></a>4.js数组常用方法？</h3><p>push()，pop()，shift()，unshift()，splice()，sort()，reverse()，map()等。</p><h3 id="5-js事件代理在捕获阶段的实际应用？"><a href="#5-js事件代理在捕获阶段的实际应用？" class="headerlink" title="5.js事件代理在捕获阶段的实际应用？"></a>5.js事件代理在捕获阶段的实际应用？</h3><p>可以在父元素层面阻止事件向子元素传播，也可代替子元素执行某些操作。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端面试题 </tag>
            
            <tag> 题库 </tag>
            
            <tag> 知识总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法——经典题库练习</title>
      <link href="2021/012549764.html"/>
      <url>2021/012549764.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="数据结构与算法-经典题库练习"><a href="#数据结构与算法-经典题库练习" class="headerlink" title="数据结构与算法 经典题库练习"></a>数据结构与算法 经典题库练习</h1><h2 id="一、字符串、时间复杂度与逻辑思维训练"><a href="#一、字符串、时间复杂度与逻辑思维训练" class="headerlink" title="一、字符串、时间复杂度与逻辑思维训练"></a>一、字符串、时间复杂度与逻辑思维训练</h2><h4 id="1、Z字形变换"><a href="#1、Z字形变换" class="headerlink" title="1、Z字形变换"></a>1、Z字形变换</h4><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。<br>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">L   C   I   RE T O E S I I GE   D   H   N<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。</p><p>请你实现这个将字符串进行指定行数变换的函数：</p><p><strong>string convert(string s, int numRows);</strong></p><pre class="line-numbers language-none"><code class="language-none">示例 1:输入: s = "LEETCODEISHIRING", numRows = 3输出: "LCIRETOESIIGEDHN"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">示例 2:输入: s = "LEETCODEISHIRING", numRows = 4输出: "LDREOEIIECIHNTSG"解释:L     D     RE   O E   I IE C   I H   NT     S     G<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>考察点：字符串、时间复杂度、逻辑思维</strong></p><h4 id="2、字符串转换整数（atoi）"><a href="#2、字符串转换整数（atoi）" class="headerlink" title="2、字符串转换整数（atoi）"></a>2、字符串转换整数（atoi）</h4><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：</p><p>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。<br>假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。<br>该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。<br>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0 。</p><p><strong>提示：</strong><br>本题中的空白字符只包括空格字符 ‘ ‘ 。<br>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">示例 1:输入: "42"输出: 42示例 2:输入: "   -42"输出: -42解释: 第一个非空白字符为 '-', 它是一个负号。我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。示例 3:输入: "4193 with words"输出: 4193解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。示例 4:输入: "words and 987"输出: 0解释: 第一个非空字符是 'w', 但它不是数字或正、负号。     因此无法执行有效的转换。示例 5:输入: "-91283472332"输出: -2147483648解释: 数字 "-91283472332" 超过 32 位有符号整数范围。      因此返回 INT_MIN (−231) 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>考察点：字符串、时间复杂度、数学逻辑思维</strong></p><h4 id="3、字符流中第一个不重复的字符"><a href="#3、字符流中第一个不重复的字符" class="headerlink" title="3、字符流中第一个不重复的字符"></a>3、字符流中第一个不重复的字符</h4><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p><p>解法:使用map实现</p><p><strong>进阶：使用哈希+队列实现</strong></p><p><strong>考察点：哈希表、字符串</strong></p><h4 id="4、小易的英语软件"><a href="#4、小易的英语软件" class="headerlink" title="4、小易的英语软件"></a>4、小易的英语软件</h4><p>小易是班级的英语课代表, 他开发了一款软件开处理他的工作。<br>小易的软件有一个神奇的功能，能够通过一个百分数来反应你的成绩在班上的位置。“成绩超过班级 …% 的同学”。<br>设这个百分数为 p，考了 s 分，则可以通过以下式子计算得出 p：<br>p = ( 分数不超过 s 的人数 - 1)  班级总人数<br>突然一天的英语考试之后，软件突然罢工了，这可忙坏了小易。成绩输入这些对于字写得又快又好的小易当然没有问题，但是计算这些百分数……这庞大的数据量吓坏了他。<br>于是他来找到你，希望他编一个程序模拟这个软件：给出班级人数 n，以及每个人的成绩，请求出某几位同学的百分数。</p><p>第一行一个整数 n，表示班级人数。<br>第二行共 n 个自然数，第 i 个数表示第 i 位同学的成绩 a_i。<br>第三行一个整数 q，表示询问的次数。<br>接下来 q 行，每行一个数 x，表示询问第 x 位同学的百分数。</p><p>输出应有 q 行，每行一个百分数，对应每一次的询问。<br>为了方便，不需要输出百分号，只需要输出百分号前的数字即可。四舍五入保留六位小数即可。</p><pre class="line-numbers language-none"><code class="language-none">输入例子1:3100 98 873123输出例子1:66.66666733.3333330.000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>考察点：网易2020校招笔试题、数学逻辑思维</strong></p><h2 id="二、指针、数组、链表组合练习"><a href="#二、指针、数组、链表组合练习" class="headerlink" title="二、指针、数组、链表组合练习"></a>二、指针、数组、链表组合练习</h2><h4 id="5、盛最多水的容器"><a href="#5、盛最多水的容器" class="headerlink" title="5、盛最多水的容器"></a>5、盛最多水的容器</h4><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器，且 n 的值至少为 2。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/container.jpg" alt="container"></p><pre class="line-numbers language-none"><code class="language-none">示例：输入：[1,8,6,2,5,4,8,3,7]输出：49<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>考察点：双指针、数组</strong></p><h4 id="6、删除链表的倒数第N个节点"><a href="#6、删除链表的倒数第N个节点" class="headerlink" title="6、删除链表的倒数第N个节点"></a>6、删除链表的倒数第N个节点</h4><ul><li>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</li></ul><pre class="line-numbers language-none"><code class="language-none">示例：给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        说明：给定的 n 保证是有效的。</p><ul><li><strong>难度提升</strong>：<br>使用一趟扫描实现。</li></ul><p><strong>考察点：链表、双指针</strong></p><h4 id="7、最小覆盖子串"><a href="#7、最小覆盖子串" class="headerlink" title="7、最小覆盖子串"></a>7、最小覆盖子串</h4><p>给你一个字符串 S、一个字符串 T 。请你设计一种算法，可以在 O(n) 的时间复杂度内，从字符串 S 里面找出：包含 T 所有字符的最小子串。</p><pre class="line-numbers language-none"><code class="language-none">示例：输入：S = "ADOBECODEBANC", T = "ABC"输出："BANC"提示：如果 S 中不存这样的子串，则返回空字符串 ""。如果 S 中存在这样的子串，我们保证它是唯一的答案。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>考点：暴力解析<br>提升：滑动窗口（集合思维）</p><p><strong>考察点：哈希表、双指针、字符串、Sliding Window</strong></p><h4 id="8、数组中相加和为0的三元组"><a href="#8、数组中相加和为0的三元组" class="headerlink" title="8、数组中相加和为0的三元组"></a>8、数组中相加和为0的三元组</h4><p>给出一个有n个元素的数组S，S中是否有元素a,b,c满足a+b+c=0？找出数组S中所有满足条件的三元组。<br>注意：<br>三元组（a、b、c）中的元素必须按非降序排列。（即a≤b≤c）</p><p>解集中不能包含重复的三元组。</p><p>例如，给定的数组 S = {-1 0 1 2 -1 -4},解集为(-1, 0, 1) (-1, -1, 2)</p><p><strong>考察点：数组、双指针</strong></p><h4 id="9、矩阵"><a href="#9、矩阵" class="headerlink" title="9、矩阵"></a>9、矩阵</h4><p>小易有一个体积巨大的货物，具体来说，是个在二维平面上占地c<em>d的货物。<br>小易有一个n</em>m的广场，想把货物放在这个广场上。不幸的是，广场上已经有了一些障碍物，障碍物所在的格子不能放置你的货物。小易现在想知道能否成功地放置货物。</p><p>第一行数字t，表示有t组数据。<br>对于每一组数据，第一行三个数字n,m,k，表示广场的大小和障碍物的个数。接下来k行，每行两个数x,y，表示一个障碍物的坐标。<br>接下来一行两个数c,d，表示货物的大小。<br>1&lt;=n,m&lt;=1000,1&lt;=c&lt;=n,1&lt;=d&lt;=m,0&lt;=k&lt;=n*m</p><p>对于每组数据，输出”YES”或者”NO”表示货物是否可以被放置。</p><pre class="line-numbers language-none"><code class="language-none">输入例子1:23 3 11 12 23 3 1  2 2  2 2  输出例子1:YESNO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>考察点：网易2020校招笔试题、深度优先搜索、广度优先搜索、数组</strong></p><h4 id="10、shopee的链表笔试题"><a href="#10、shopee的链表笔试题" class="headerlink" title="10、shopee的链表笔试题"></a>10、shopee的链表笔试题</h4><pre class="line-numbers language-none"><code class="language-none">1.输入一个链表，反转链表后，输出新链表的表头2.判断给定的链表中是否有环<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>考察点：链表、双指针</strong></p><h4 id="11、顺时针打印矩阵"><a href="#11、顺时针打印矩阵" class="headerlink" title="11、顺时针打印矩阵"></a>11、顺时针打印矩阵</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">实现方法：    public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>考察点：数组</strong></p><p>※强化：时间复杂度O（n）或空间复杂度O（1）</p><h2 id="三、二分法"><a href="#三、二分法" class="headerlink" title="三、二分法"></a>三、二分法</h2><h4 id="12、机器人跳跃问题"><a href="#12、机器人跳跃问题" class="headerlink" title="12、机器人跳跃问题"></a>12、机器人跳跃问题</h4><p>机器人正在玩一个古老的基于DOS的游戏。游戏中有N+1座建筑——从0到N编号，从左到右排列。编号为0的建筑高度为0个单位，编号为i的建筑的高度为H(i)个单位。 </p><p>起初， 机器人在编号为0的建筑处。每一步，它跳到下一个（右边）建筑。假设机器人在第k个建筑，且它现在的能量值是E, 下一步它将跳到第k+1个建筑。它将会得到或者失去正比于与H(k+1)与E之差的能量。如果 H(k+1) &gt; E 那么机器人就失去 H(k+1) - E 的能量值，否则它将得到 E - H(k+1) 的能量值。</p><p>游戏目标是到达第个N建筑，在这个过程中，能量值不能为负数个单位。现在的问题是机器人以多少能量值开始游戏，才可以保证成功完成游戏？</p><p>输入描述:<br>第一行输入，表示一共有 N 组数据.</p><p>第二个是 N 个空格分隔的整数，H1, H2, H3, …, Hn 代表建筑物的高度</p><p>输出描述:<br>输出一个单独的数表示完成游戏所需的最少单位的初始能量</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">输入例子1:53 4 3 2 4输出例子1:4输入例子2:34 4 4输出例子2:4输入例子3:31 6 4输出例子3:3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>考察点：二分法、数学方法、逆推法</strong></p><h4 id="13、百度春招笔试题"><a href="#13、百度春招笔试题" class="headerlink" title="13、百度春招笔试题"></a>13、百度春招笔试题</h4><ul><li>请实现有重复数字的有序数组的二分查找。<br>输出在数组中第一个大于等于查找值的位置，如果数组中不存在这样的数，则输出数组长度加一</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">示例1：输入5,4,[1,2,4,4,5]输出3方法：二分查找实现：    /**     * 二分查找     * @param n int整型 数组长度     * @param v int整型 查找值     * @param a int整型一维数组 有序数组     * @return int整型     */    public int upper_bound_ (int n, int v, int[] a) {}；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组[3,4,5,1,2]为[1,2,3,4,5]的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">实现：public int minNumberInRotateArray(int [] array){}；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p><strong>考察点：二分查找、数组</strong></p><h4 id="14、旋转数组的最小数字"><a href="#14、旋转数组的最小数字" class="headerlink" title="14、旋转数组的最小数字"></a>14、旋转数组的最小数字</h4><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p><p>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。</p><pre class="line-numbers language-none"><code class="language-none">例如数组[3,4,5,1,2]为[1,2,3,4,5]的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>考察点：二分查找</strong></p><h2 id="四、泛型"><a href="#四、泛型" class="headerlink" title="四、泛型"></a>四、泛型</h2><h4 id="15、泛型"><a href="#15、泛型" class="headerlink" title="15、泛型"></a>15、泛型</h4><p>使用泛型编写程序，使用ArrayList和LinkedList。<br>首先创建一个包含Integer实例对象的数组表ArrayList，依次往里面添加1,2,3,1,3这几个整型对象后，将其打印出来，然后将第4、5个对象进行更改，更改为4和5这两个整型对象，然后用Iterator接口将ArrayList中的元素全部打印出来；最后在ArrayList中在创建LinkedList，将第0，3位置的插入整型对象元素10和30，然后用Iterator接口遍历LinkedList中的各元素，将值小于4的元素输出后输出LinkedList中的各元素。</p><p><strong>考察点：泛型、逻辑思维</strong></p><h2 id="五、二叉树、深度优先搜索"><a href="#五、二叉树、深度优先搜索" class="headerlink" title="五、二叉树、深度优先搜索"></a>五、二叉树、深度优先搜索</h2><h4 id="16、验证二叉搜索树"><a href="#16、验证二叉搜索树" class="headerlink" title="16、验证二叉搜索树"></a>16、验证二叉搜索树</h4><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><p>节点的左子树只包含小于当前节点的数。<br>节点的右子树只包含大于当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">示例 1:输入:    2   / \  1   3输出: true示例 2:输入:    5   / \  1   4     / \    3   6输出: false解释: 输入为: [5,1,4,null,null,3,6]。     根节点的值为 5 ，但是其右子节点值为 4 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>考察点：树、深度优先搜索、递归</strong></p><h4 id="17、二叉树的最大深度"><a href="#17、二叉树的最大深度" class="headerlink" title="17、二叉树的最大深度"></a>17、二叉树的最大深度</h4><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><pre class="line-numbers language-none"><code class="language-none">示例：给定二叉树 [3,9,20,null,null,15,7]，它的最大深度为3 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>方法一：递归</p><p>方法二：BFS(广度优先搜索)<br>提示：队列</p><p>方法三：DFS（深度优先搜索）<br>提示：栈</p><p><strong>考察点：树、深度优先搜索</strong></p><h4 id="18、二叉树加强训练"><a href="#18、二叉树加强训练" class="headerlink" title="18、二叉树加强训练"></a>18、二叉树加强训练</h4><ul><li><p><strong>二叉树的镜像</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">实现方法：    public void Mirror(TreeNode root)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>操作给定的二叉树，将其变换为源二叉树的镜像。<br>输入描述:</p></li></ul><pre class="line-numbers language-none"><code class="language-none">二叉树的镜像定义：         源二叉树 ：        8       /  \      6   10     / \   / \    5   7 9  11        镜像二叉树：                8              /   \             10    6            / \    / \            11 9   7  5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>树的子结构</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">实现方法：    public boolean HasSubtree(TreeNode root1,TreeNode root2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">例如:给定的树 A:    3   / \  4   5 / \1   2给定的树 B：   4   / 1返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。示例 1：输入：A = [1,2,3], B = [3,1]输出：false示例 2：输入：A = [3,4,5,1,2], B = [4,1]输出：true限制：0 &lt;= 节点个数 &lt;= 10000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>考察点：二叉树</strong></p><h2 id="六、堆、栈、列表"><a href="#六、堆、栈、列表" class="headerlink" title="六、堆、栈、列表"></a>六、堆、栈、列表</h2><h4 id="19、最小栈"><a href="#19、最小栈" class="headerlink" title="19、最小栈"></a>19、最小栈</h4><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><p>push(x) —— 将元素 x 推入栈中。<br>pop() —— 删除栈顶的元素。<br>top() —— 获取栈顶元素。<br>getMin() —— 检索栈中的最小元素。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">示例:输入：["MinStack","push","push","push","getMin","pop","top","getMin"][[],[-2],[0],[-3],[],[],[],[]]输出：[null,null,null,null,-3,null,0,-2]解释：MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin();   --&gt; 返回 -3.minStack.pop();minStack.top();      --&gt; 返回 0.minStack.getMin();   --&gt; 返回 -2.提示：pop、top 和 getMin 操作总是在 非空栈 上调用。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>考察点：栈、设计</strong></p><h4 id="20、栈的压入弹出序列"><a href="#20、栈的压入弹出序列" class="headerlink" title="20、栈的压入弹出序列"></a>20、栈的压入弹出序列</h4><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">示例 1：输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]输出：true解释：我们可以按以下顺序执行：push(1), push(2), push(3), push(4), pop() -&gt; 4,push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1示例 2：输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]输出：false解释：1 不能在 2 之前弹出。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>考察点：栈、时间复杂度、贪心算法</strong></p><h4 id="21、有序矩阵中的第K小的元素"><a href="#21、有序矩阵中的第K小的元素" class="headerlink" title="21、有序矩阵中的第K小的元素"></a>21、有序矩阵中的第K小的元素</h4><p>给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。<br>请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">示例：matrix = [   [ 1,   5,    9],   [10, 11, 13],   [12, 13, 15]]k = 8,返回 13<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解法：暴力解析（二维合并为一维）</p><p>进阶：二分查找</p><p>提升：归并排序</p><p><strong>考察点：堆、二分查找</strong></p><h4 id="22、小米笔试题——栈"><a href="#22、小米笔试题——栈" class="headerlink" title="22、小米笔试题——栈"></a>22、小米笔试题——栈</h4><ul><li>给出一个仅包含字符’(‘,’)’,’{‘,’}’,’[‘和’]’,的字符串，判断给出的字符串是否是合法的括号序列<br>括号必须以正确的顺序关闭，”()”和”()[]{}”都是合法的括号序列，但”(]”和”([)]”不合法。</li></ul><pre class="line-numbers language-none"><code class="language-none">示例1输入"["输出false示例2输入"[]"输出true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>考点：栈、字符串</strong></p><ul><li>给你一个1-&gt;n的排列和一个栈，入栈顺序给定<br>你要在不打乱入栈顺序的情况下，对数组进行从大到小排序<br>当无法完全排序时，请输出字典序最大的出栈序列</li></ul><pre class="line-numbers language-none"><code class="language-none">输入[2,1,5,3,4]输出[5,4,3,1,2]说明2入栈；1入栈；5入栈；5出栈；3入栈；4入栈；4出栈；3出栈；1出栈；2出栈备注:n&lt;=1e6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>考点：栈、排序</strong></p><h2 id="七、递归、回溯、贪心算法"><a href="#七、递归、回溯、贪心算法" class="headerlink" title="七、递归、回溯、贪心算法"></a>七、递归、回溯、贪心算法</h2><h4 id="23、两数相加"><a href="#23、两数相加" class="headerlink" title="23、两数相加"></a>23、两数相加</h4><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><img src="https://liuleisex.oss-cn-chengdu.aliyuncs.com/Hexo/twotogether.jpg" alt="twotogether"></p><pre class="line-numbers language-none"><code class="language-none">示例：输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>考察点：递归、链表、数学方法</strong></p><h4 id="24、字符串的排列"><a href="#24、字符串的排列" class="headerlink" title="24、字符串的排列"></a>24、字符串的排列</h4><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则按字典序打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><pre class="line-numbers language-none"><code class="language-none">输入描述:输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。提示：输出字符串不能重复<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>考察点：字符串、递归、回溯</strong></p><h4 id="25、剪绳子"><a href="#25、剪绳子" class="headerlink" title="25、剪绳子"></a>25、剪绳子</h4><p>给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1，m&lt;=n），每段绳子的长度记为k[1],…,k[m]。请问k[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><pre class="line-numbers language-none"><code class="language-none">输入描述:输入一个数n，意义见题面。（2 &lt;= n &lt;= 60）输出描述:输出答案。示例：输入8    输出18<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法一：递归<br>方法二：动态规划<br>方法三：贪婪解法</p><p><strong>考察点：贪心  数组  数量关系  高级算法  组合数学</strong></p><h2 id="八、动态规划"><a href="#八、动态规划" class="headerlink" title="八、动态规划"></a>八、动态规划</h2><h4 id="26、篮球队"><a href="#26、篮球队" class="headerlink" title="26、篮球队"></a>26、篮球队</h4><p> 小Q是篮球训练队的教练，篮球队新加入了N名队员，第i名队员的篮球水平值为Ai。<br>小Q现在要把他们按照以下的要求分为A队和B队进行训练:<br>1、A队的队员水平值之和严格大于B队的队员水平值之和<br>2、对于A队中的任意一名队员，如果把他分配到B队，A队的水平值之和就会严格小于B队的水平值之和。<br>3、每个队员必须要加入一个队伍<br>小Q现在想知道有多少种方案可以按照以上要求完成分队。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">输入描述:输入包括两行, 输入的第一行为一个正整数n(2 &lt;= N &lt;= 50), 表示队员的数量。第二行包括N个正整数 Ai(1 &lt;= Ai&lt;= 6 x 10^4), 表示每名队员的篮球水平值, 以空格分割。输出描述:输出一个正整数, 表示方案数。示例1输入45 4 7 6输出2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>考察点：动态规划</strong></p><h4 id="27、最长回文子串"><a href="#27、最长回文子串" class="headerlink" title="27、最长回文子串"></a>27、最长回文子串</h4><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><pre class="line-numbers language-none"><code class="language-none">示例 1：输入: "babad"输出: "bab"注意: "aba" 也是一个有效答案。示例 2：输入: "cbbd"输出: "bb"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解法：暴力解析</p><p>提升：动态规划</p><p><strong>考察点：哈希表、字符串、动态规划</strong></p><h4 id="28、动态规划经典例题"><a href="#28、动态规划经典例题" class="headerlink" title="28、动态规划经典例题"></a>28、动态规划经典例题</h4><ul><li><p><strong>连续子数组的最大和：</strong></p><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？</p><pre class="line-numbers language-none"><code class="language-none">例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><ul><li><strong>买卖股票的最佳时机问题整合：</strong></li><li>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li></ul><pre class="line-numbers language-none"><code class="language-none">示例 1:输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。示例 2:输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。示例 3:输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。提示：1 &lt;= prices.length &lt;= 3 * 10 ^ 40 &lt;= prices[i] &lt;= 10 ^ 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>考察点：动态规划（可选择暴力搜索、贪心算法）</strong></p><ul><li>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。<br>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。<br>返回获得利润的最大值。<br>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易只需要为支付一次手续费。</li></ul><pre class="line-numbers language-none"><code class="language-none">示例 1:输入: prices = [1, 3, 2, 8, 4, 9], fee = 2输出: 8解释: 能够达到的最大利润:  在此处买入 prices[0] = 1在此处卖出 prices[3] = 8在此处买入 prices[4] = 4在此处卖出 prices[5] = 9总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.注意:0 &lt; prices.length &lt;= 50000.0 &lt; prices[i] &lt; 50000.0 &lt;= fee &lt; 50000.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>考察点：动态规划</strong></p><ul><li>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。<br>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:<br>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><pre class="line-numbers language-none"><code class="language-none">示例:输入: [1,2,3,0,2]输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>考察点：动态规划</strong></p><ul><li>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。<br>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li></ul><pre class="line-numbers language-none"><code class="language-none">示例 1:输入: [3,3,5,0,0,3,1,4]输出: 6解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。示例 2:输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。        注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。        因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。示例 3:输入: [7,6,4,3,1] 输出: 0 解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>考察点：动态规划</strong></p><ul><li>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。<br>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li></ul><pre class="line-numbers language-none"><code class="language-none">示例 1:输入: [2,4,1], k = 2输出: 2解释: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。示例 2:输入: [3,2,6,5,0,3], k = 2输出: 7解释: 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>考点：动态规划（可考虑递归）</strong></p><h4 id="29、字节跳动笔试题-动态规划"><a href="#29、字节跳动笔试题-动态规划" class="headerlink" title="29、字节跳动笔试题-动态规划"></a>29、字节跳动笔试题-动态规划</h4><p>假设你有一个数组，其中第 i 个元素是股票在第 i 天的价格。<br>你有一次买入和卖出的机会。（只有买入了股票以后才能卖出）。<br>请你设计一个算法来计算可以获得的最大收益。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">示例1输入[1,4,2]输出3示例2输入[2,4,1]输出2实现：public int maxProfit (int[] prices){}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>考察点：动态规划 数组</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 大厂笔试题 </tag>
            
            <tag> 逻辑思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习路线</title>
      <link href="2021/011963587.html"/>
      <url>2021/011963587.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Java学习路线"><a href="#Java学习路线" class="headerlink" title="Java学习路线"></a>Java学习路线</h2><h4 id="一、java基础"><a href="#一、java基础" class="headerlink" title="一、java基础"></a>一、java基础</h4><p>​    1.java基础语法</p><p>​    2.流程控制语句和方法</p><p>​    3.数组</p><p>​    4.面向对象编程</p><p>​    5.异常</p><p>​    6.常用类</p><p>​    7.集合框架</p><p>​    8.IO流</p><p>​    9.多线程</p><p>​    10.GUI编程</p><p>​    11.网络编程</p><p>​    12.注解和反射</p><p>​    13.JUC编程</p><p>​    14.JVM探究</p><p>​    15.23中设计模式</p><p>​    16.数据结构和算法</p><p>​    17.正则表达式</p><hr><h4 id="二、JavaWeb"><a href="#二、JavaWeb" class="headerlink" title="二、JavaWeb"></a>二、JavaWeb</h4><p>​    1.MySQL初级</p><p>​    2.JDBC</p><p>​    3.HTML2</p><p>​    4.CSS3</p><p>​    5.JavaScript</p><p>​    6.jQuery</p><p>​    7.Layui&amp;VBootStrap</p><p>​    8.Http协议</p><p>​    9.Tomcat</p><p>​    10.Servlet</p><p>​    11.Cookie&amp;Session</p><p>​    12.JSP</p><p>​    13.JSTL&amp;EL表达式</p><p>​    14.MVC三层架构</p><p>​    15.过滤器</p><p>​    16.监听器</p><p>​    17.文件上传下载</p><p>​    18.邮件收发</p><p>​    19.富文本编辑器</p><hr><h4 id="三、SSM框架"><a href="#三、SSM框架" class="headerlink" title="三、SSM框架"></a>三、SSM框架</h4><ol><li>Maven</li><li>Junit</li><li>Log4J</li><li>MyBatis</li><li>Spring</li><li>SpringMVC</li><li>JSON</li><li>Ajax</li><li>SSM框架整合</li><li>Shiro</li><li>Soir</li><li>Git</li><li>MyBatis-Plus</li><li>MySQL高级</li><li>Netty</li><li>MyCat</li></ol><hr><h4 id="四、Linux运维"><a href="#四、Linux运维" class="headerlink" title="四、Linux运维"></a>四、Linux运维</h4><ol><li>Linux基础</li><li>Shell编程</li><li>Linux系统管理</li><li>Linux网络</li><li>LAMP平台部署</li><li>LNMP平台部署</li><li>Nginx</li><li>ELK日志分析</li><li>MySQL集群</li><li>Redis</li><li>Linux集群</li><li>Docker</li><li>OpenStack</li><li>Kubernetes</li></ol><hr><h4 id="五、微服务和分布式"><a href="#五、微服务和分布式" class="headerlink" title="五、微服务和分布式"></a>五、微服务和分布式</h4><ol><li>Vue</li><li>NodeJS</li><li>SpringBoot原理</li><li>SpringBootWeb开发</li><li>SpringData</li><li>SpringSecurity</li><li>SpringBoot分布式开发</li><li>ActiveMQ</li><li>Elsticsearch</li><li>Dobbo+Zookeeper</li><li>SpringCloud Netfix全家桶</li><li>SpringCloud Alibaba全家桶</li></ol><hr><h4 id="六、大数据开发"><a href="#六、大数据开发" class="headerlink" title="六、大数据开发"></a>六、大数据开发</h4><ol><li>负载均衡</li><li>Hadoop</li><li>Hive</li><li>HBase</li><li>Flume</li><li>Sqoop</li><li>Zookeeper</li><li>Impala</li><li>Scala编程</li><li>Spark系列</li><li>Kafka</li></ol><hr><h4 id="七、进阶路线"><a href="#七、进阶路线" class="headerlink" title="七、进阶路线"></a>七、进阶路线</h4><ol><li>Java8新特性</li><li>Java9新特性</li><li>Java10新特性</li><li>Java11新特性</li><li>Java12新特性</li><li>Service Mesh</li><li>计算机网络原理</li><li>操作系统</li></ol><hr><h4 id="八、学习方式"><a href="#八、学习方式" class="headerlink" title="八、学习方式"></a>八、学习方式</h4><p>​        成为一个合格的工程师需要 1~3 年时间，最好的学习方法就是找经典的书籍 <strong>系统</strong> 地学习，而不要遇到一个问题到网上搜搜然后就解决了事。例如 Java 的各种数据结构的实现原理，只有深入掌握其实现原理，才能对其优缺点和使用场景有深刻理解，这样在做具体方案设计的时候才能选择合适的数据结构。</p>]]></content>
      
      
      <categories>
          
          <category> 职业发展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习大纲 </tag>
            
            <tag> 发展路线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零到一，搭建属于自己的hexo博客</title>
      <link href="2021/011528371.html"/>
      <url>2021/011528371.html</url>
      
        <content type="html"><![CDATA[<h2 id="从零到一，搭建属于自己的hexo博客"><a href="#从零到一，搭建属于自己的hexo博客" class="headerlink" title="从零到一，搭建属于自己的hexo博客"></a>从零到一，搭建属于自己的hexo博客</h2><h4 id="第一步：安装Nodejs"><a href="#第一步：安装Nodejs" class="headerlink" title="第一步：安装Nodejs"></a>第一步：安装Nodejs</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">node -v#查看node版本npm -v#查看npm版本npm install -gcnpm --registry=http://registry.npm.taobao.org#安装淘宝的cnpm 管理器cnpm -v#查看cnpm版本cnpm install -g hexo-cli    #安装hexo框架hexo -v#查看hexo版本mkdir blog#创建blog目录cd blog #进入blog目录sudo hexo init #生成博客 初始化博客hexo s#启动本地博客服务'http://localhost:4000/'#本地访问地址hexo n "我的第一篇文章" #创建新的文章<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="第二步：返回blog目录"><a href="#第二步：返回blog目录" class="headerlink" title="第二步：返回blog目录"></a>第二步：返回blog目录</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hexo clean #清理hexo g #生成<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="第三步：Github创建一个新的仓库YourGithubName-github-io"><a href="#第三步：Github创建一个新的仓库YourGithubName-github-io" class="headerlink" title="第三步：Github创建一个新的仓库YourGithubName.github.io"></a>第三步：Github创建一个新的仓库YourGithubName.github.io</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cnpm install --save hexo-deployer-git #在blog目录下安装git部署插件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="第四步：配置-config-yml"><a href="#第四步：配置-config-yml" class="headerlink" title="第四步：配置_config.yml"></a>第四步：配置_config.yml</h4><p>在_config.yml中做如下修改：</p><p>#Deployment<br>##Docs: <a href="https://hexo.io/docs/deployment.html">https://hexo.io/docs/deployment.html</a><br>deploy:<br>      type: git<br>      repo:<a href="https://github.com/YourGithubName/YourGithubName.github.io.git">https://github.com/YourGithubName/YourGithubName.github.io.git</a><br>      branch: master</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hexo d#部署到Github仓库里'https://YourGithubName.github.io/'  #访问这个地址可以查看博客<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="第五步：下载yilia主题到本地"><a href="#第五步：下载yilia主题到本地" class="headerlink" title="第五步：下载yilia主题到本地"></a>第五步：下载yilia主题到本地</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia  #下载yilia主题到本地<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="第六步：修改hexo根目录下的-config-yml-文件"><a href="#第六步：修改hexo根目录下的-config-yml-文件" class="headerlink" title="第六步：修改hexo根目录下的 _config.yml 文件"></a>第六步：修改hexo根目录下的 _config.yml 文件</h4><p>先在_config.yml文件中修改theme为theme: yilia</p><p>然后进行下列操作：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hexo c#清理一下hexo g#生成hexo d#部署到远程Github仓库'https://YourGithubName.github.io/'  #查看博客<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> yilia </tag>
            
            <tag> Nodejs </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
